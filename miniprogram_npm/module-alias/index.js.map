{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar BuiltinModule = require('module')\n\n// Guard against poorly mocked module constructors\nvar Module = module.constructor.length > 1\n  ? module.constructor\n  : BuiltinModule\n\nvar nodePath = require('path')\n\nvar modulePaths = []\nvar moduleAliases = {}\nvar moduleAliasNames = []\n\nvar oldNodeModulePaths = Module._nodeModulePaths\nModule._nodeModulePaths = function (from) {\n  var paths = oldNodeModulePaths.call(this, from)\n\n  // Only include the module path for top-level modules\n  // that were not installed:\n  if (from.indexOf('node_modules') === -1) {\n    paths = modulePaths.concat(paths)\n  }\n\n  return paths\n}\n\nvar oldResolveFilename = Module._resolveFilename\nModule._resolveFilename = function (request, parentModule, isMain, options) {\n  for (var i = moduleAliasNames.length; i-- > 0;) {\n    var alias = moduleAliasNames[i]\n    if (isPathMatchesAlias(request, alias)) {\n      var aliasTarget = moduleAliases[alias]\n      // Custom function handler\n      if (typeof moduleAliases[alias] === 'function') {\n        var fromPath = parentModule.filename\n        aliasTarget = moduleAliases[alias](fromPath, request, alias)\n        if (!aliasTarget || typeof aliasTarget !== 'string') {\n          throw new Error('[module-alias] Expecting custom handler function to return path.')\n        }\n      }\n      request = nodePath.join(aliasTarget, request.substr(alias.length))\n      // Only use the first match\n      break\n    }\n  }\n\n  return oldResolveFilename.call(this, request, parentModule, isMain, options)\n}\n\nfunction isPathMatchesAlias (path, alias) {\n  // Matching /^alias(\\/|$)/\n  if (path.indexOf(alias) === 0) {\n    if (path.length === alias.length) return true\n    if (path[alias.length] === '/') return true\n  }\n\n  return false\n}\n\nfunction addPathHelper (path, targetArray) {\n  path = nodePath.normalize(path)\n  if (targetArray && targetArray.indexOf(path) === -1) {\n    targetArray.unshift(path)\n  }\n}\n\nfunction removePathHelper (path, targetArray) {\n  if (targetArray) {\n    var index = targetArray.indexOf(path)\n    if (index !== -1) {\n      targetArray.splice(index, 1)\n    }\n  }\n}\n\nfunction addPath (path) {\n  var parent\n  path = nodePath.normalize(path)\n\n  if (modulePaths.indexOf(path) === -1) {\n    modulePaths.push(path)\n    // Enable the search path for the current top-level module\n    var mainModule = getMainModule()\n    if (mainModule) {\n      addPathHelper(path, mainModule.paths)\n    }\n    parent = module.parent\n\n    // Also modify the paths of the module that was used to load the\n    // app-module-paths module and all of it's parents\n    while (parent && parent !== mainModule) {\n      addPathHelper(path, parent.paths)\n      parent = parent.parent\n    }\n  }\n}\n\nfunction addAliases (aliases) {\n  for (var alias in aliases) {\n    addAlias(alias, aliases[alias])\n  }\n}\n\nfunction addAlias (alias, target) {\n  moduleAliases[alias] = target\n  // Cost of sorting is lower here than during resolution\n  moduleAliasNames = Object.keys(moduleAliases)\n  moduleAliasNames.sort()\n}\n\n/**\n * Reset any changes maded (resets all registered aliases\n * and custom module directories)\n * The function is undocumented and for testing purposes only\n */\nfunction reset () {\n  var mainModule = getMainModule()\n\n  // Reset all changes in paths caused by addPath function\n  modulePaths.forEach(function (path) {\n    if (mainModule) {\n      removePathHelper(path, mainModule.paths)\n    }\n\n    // Delete from require.cache if the module has been required before.\n    // This is required for node >= 11\n    Object.getOwnPropertyNames(require.cache).forEach(function (name) {\n      if (name.indexOf(path) !== -1) {\n        delete require.cache[name]\n      }\n    })\n\n    var parent = module.parent\n    while (parent && parent !== mainModule) {\n      removePathHelper(path, parent.paths)\n      parent = parent.parent\n    }\n  })\n\n  modulePaths = []\n  moduleAliases = {}\n  moduleAliasNames = []\n}\n\n/**\n * Import aliases from package.json\n * @param {object} options\n */\nfunction init (options) {\n  if (typeof options === 'string') {\n    options = { base: options }\n  }\n\n  options = options || {}\n\n  var candidatePackagePaths\n  if (options.base) {\n    candidatePackagePaths = [nodePath.resolve(options.base.replace(/\\/package\\.json$/, ''))]\n  } else {\n    // There is probably 99% chance that the project root directory in located\n    // above the node_modules directory,\n    // Or that package.json is in the node process' current working directory (when\n    // running a package manager script, e.g. `yarn start` / `npm run start`)\n    candidatePackagePaths = [nodePath.join(__dirname, '../..'), process.cwd()]\n  }\n\n  var npmPackage\n  var base\n  for (var i in candidatePackagePaths) {\n    try {\n      base = candidatePackagePaths[i]\n\n      npmPackage = require(nodePath.join(base, 'package.json'))\n      break\n    } catch (e) {\n      // noop\n    }\n  }\n\n  if (typeof npmPackage !== 'object') {\n    var pathString = candidatePackagePaths.join(',\\n')\n    throw new Error('Unable to find package.json in any of:\\n[' + pathString + ']')\n  }\n\n  //\n  // Import aliases\n  //\n\n  var aliases = npmPackage._moduleAliases || {}\n\n  for (var alias in aliases) {\n    if (aliases[alias][0] !== '/') {\n      aliases[alias] = nodePath.join(base, aliases[alias])\n    }\n  }\n\n  addAliases(aliases)\n\n  //\n  // Register custom module directories (like node_modules)\n  //\n\n  if (npmPackage._moduleDirectories instanceof Array) {\n    npmPackage._moduleDirectories.forEach(function (dir) {\n      if (dir === 'node_modules') return\n\n      var modulePath = nodePath.join(base, dir)\n      addPath(modulePath)\n    })\n  }\n}\n\nfunction getMainModule () {\n  return require.main._simulateRepl ? undefined : require.main\n}\n\nmodule.exports = init\nmodule.exports.addPath = addPath\nmodule.exports.addAlias = addAlias\nmodule.exports.addAliases = addAliases\nmodule.exports.isPathMatchesAlias = isPathMatchesAlias\nmodule.exports.reset = reset\n"]}