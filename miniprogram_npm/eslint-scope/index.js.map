{"version":3,"sources":["index.js","scope-manager.js","scope.js","reference.js","variable.js","definition.js","referencer.js","pattern-visitor.js","../package.json"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA,AENA;AJaA,AGTA,AFMA,ACHA,AENA;AJaA,AGTA,AFMA,ACHA,AENA;ACFA,ALeA,AGTA,AFMA,ACHA,AENA;ACFA,ALeA,AGTA,AFMA,ACHA,AENA;ACFA,ALeA,AGTA,AFMA,ACHA,AENA;ACFA,ALeA,AGTA,AGTA,ALeA,ACHA,AENA;ACFA,ALeA,AGTA,AGTA,ALeA,ACHA,AENA;ACFA,ALeA,AGTA,AGTA,ALeA,ACHA,AENA;ACFA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;ACFA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;ACFA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA,AENA;AIXA,AHSA,ALeA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AFOA,AOrBA,AJYA,AGTA,ALeA,ACHA;AKdA,AJYA,AGTA,ALeA,ACHA;AKdA,AJYA,AGTA,ALeA,ACHA;AKdA,AJYA,AGTA,ALeA,ACHA;AKdA,AJYA,AGTA,ALeA,ACHA;AKdA,AJYA,AGTA,ALeA,ACHA;AKdA,AJYA,AGTA,ALeA,ACHA;AKdA,AJYA,AGTA,ALeA,ACHA;AKdA,AJYA,AGTA,ALeA,ACHA;ACFA,AGTA,ALeA,ACHA;ACFA,AGTA,ALeA,ACHA;ACFA,AGTA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,ALeA,ACHA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>\n  Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Escope (<a href=\"http://github.com/estools/escope\">escope</a>) is an <a\n * href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript</a>\n * scope analyzer extracted from the <a\n * href=\"http://github.com/estools/esmangle\">esmangle project</a/>.\n * <p>\n * <em>escope</em> finds lexical scopes in a source program, i.e. areas of that\n * program where different occurrences of the same identifier refer to the same\n * variable. With each scope the contained variables are collected, and each\n * identifier reference in code is linked to its corresponding variable (if\n * possible).\n * <p>\n * <em>escope</em> works on a syntax tree of the parsed source code which has\n * to adhere to the <a\n * href=\"https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\">\n * Mozilla Parser API</a>. E.g. <a href=\"https://github.com/eslint/espree\">espree</a> is a parser\n * that produces such syntax trees.\n * <p>\n * The main interface is the {@link analyze} function.\n * @module escope\n */\n\n\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"__currentScope\"] }] */\n\nconst assert = require(\"assert\");\n\nconst ScopeManager = require(\"./scope-manager\");\nconst Referencer = require(\"./referencer\");\nconst Reference = require(\"./reference\");\nconst Variable = require(\"./variable\");\nconst Scope = require(\"./scope\").Scope;\nconst version = require(\"../package.json\").version;\n\n/**\n * Set the default options\n * @returns {Object} options\n */\nfunction defaultOptions() {\n    return {\n        optimistic: false,\n        directive: false,\n        nodejsScope: false,\n        impliedStrict: false,\n        sourceType: \"script\",  // one of ['script', 'module']\n        ecmaVersion: 5,\n        childVisitorKeys: null,\n        fallback: \"iteration\"\n    };\n}\n\n/**\n * Preform deep update on option object\n * @param {Object} target - Options\n * @param {Object} override - Updates\n * @returns {Object} Updated options\n */\nfunction updateDeeply(target, override) {\n\n    /**\n     * Is hash object\n     * @param {Object} value - Test value\n     * @returns {boolean} Result\n     */\n    function isHashObject(value) {\n        return typeof value === \"object\" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);\n    }\n\n    for (const key in override) {\n        if (override.hasOwnProperty(key)) {\n            const val = override[key];\n\n            if (isHashObject(val)) {\n                if (isHashObject(target[key])) {\n                    updateDeeply(target[key], val);\n                } else {\n                    target[key] = updateDeeply({}, val);\n                }\n            } else {\n                target[key] = val;\n            }\n        }\n    }\n    return target;\n}\n\n/**\n * Main interface function. Takes an Espree syntax tree and returns the\n * analyzed scopes.\n * @function analyze\n * @param {espree.Tree} tree - Abstract Syntax Tree\n * @param {Object} providedOptions - Options that tailor the scope analysis\n * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag\n * @param {boolean} [providedOptions.directive=false]- the directive flag\n * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls\n * @param {boolean} [providedOptions.nodejsScope=false]- whether the whole\n * script is executed under node.js environment. When enabled, escope adds\n * a function scope immediately following the global scope.\n * @param {boolean} [providedOptions.impliedStrict=false]- implied strict mode\n * (if ecmaVersion >= 5).\n * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'\n * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered\n * @param {Object} [providedOptions.childVisitorKeys=null] - Additional known visitor keys. See [esrecurse](https://github.com/estools/esrecurse)'s the `childVisitorKeys` option.\n * @param {string} [providedOptions.fallback='iteration'] - A kind of the fallback in order to encounter with unknown node. See [esrecurse](https://github.com/estools/esrecurse)'s the `fallback` option.\n * @returns {ScopeManager} ScopeManager\n */\nfunction analyze(tree, providedOptions) {\n    const options = updateDeeply(defaultOptions(), providedOptions);\n    const scopeManager = new ScopeManager(options);\n    const referencer = new Referencer(options, scopeManager);\n\n    referencer.visit(tree);\n\n    assert(scopeManager.__currentScope === null, \"currentScope should be null.\");\n\n    return scopeManager;\n}\n\nmodule.exports = {\n\n    /** @name module:escope.version */\n    version,\n\n    /** @name module:escope.Reference */\n    Reference,\n\n    /** @name module:escope.Variable */\n    Variable,\n\n    /** @name module:escope.Scope */\n    Scope,\n\n    /** @name module:escope.ScopeManager */\n    ScopeManager,\n    analyze\n};\n\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/* eslint-disable no-underscore-dangle */\n\nconst Scope = require(\"./scope\");\nconst assert = require(\"assert\");\n\nconst GlobalScope = Scope.GlobalScope;\nconst CatchScope = Scope.CatchScope;\nconst WithScope = Scope.WithScope;\nconst ModuleScope = Scope.ModuleScope;\nconst ClassScope = Scope.ClassScope;\nconst SwitchScope = Scope.SwitchScope;\nconst FunctionScope = Scope.FunctionScope;\nconst ForScope = Scope.ForScope;\nconst FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;\nconst BlockScope = Scope.BlockScope;\n\n/**\n * @class ScopeManager\n */\nclass ScopeManager {\n    constructor(options) {\n        this.scopes = [];\n        this.globalScope = null;\n        this.__nodeToScope = new WeakMap();\n        this.__currentScope = null;\n        this.__options = options;\n        this.__declaredVariables = new WeakMap();\n    }\n\n    __useDirective() {\n        return this.__options.directive;\n    }\n\n    __isOptimistic() {\n        return this.__options.optimistic;\n    }\n\n    __ignoreEval() {\n        return this.__options.ignoreEval;\n    }\n\n    __isNodejsScope() {\n        return this.__options.nodejsScope;\n    }\n\n    isModule() {\n        return this.__options.sourceType === \"module\";\n    }\n\n    isImpliedStrict() {\n        return this.__options.impliedStrict;\n    }\n\n    isStrictModeSupported() {\n        return this.__options.ecmaVersion >= 5;\n    }\n\n    // Returns appropriate scope for this node.\n    __get(node) {\n        return this.__nodeToScope.get(node);\n    }\n\n    /**\n     * Get variables that are declared by the node.\n     *\n     * \"are declared by the node\" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.\n     * If the node declares nothing, this method returns an empty array.\n     * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.\n     *\n     * @param {Espree.Node} node - a node to get.\n     * @returns {Variable[]} variables that declared by the node.\n     */\n    getDeclaredVariables(node) {\n        return this.__declaredVariables.get(node) || [];\n    }\n\n    /**\n     * acquire scope from node.\n     * @method ScopeManager#acquire\n     * @param {Espree.Node} node - node for the acquired scope.\n     * @param {boolean=} inner - look up the most inner scope, default value is false.\n     * @returns {Scope?} Scope from node\n     */\n    acquire(node, inner) {\n\n        /**\n         * predicate\n         * @param {Scope} testScope - scope to test\n         * @returns {boolean} predicate\n         */\n        function predicate(testScope) {\n            if (testScope.type === \"function\" && testScope.functionExpressionScope) {\n                return false;\n            }\n            return true;\n        }\n\n        const scopes = this.__get(node);\n\n        if (!scopes || scopes.length === 0) {\n            return null;\n        }\n\n        // Heuristic selection from all scopes.\n        // If you would like to get all scopes, please use ScopeManager#acquireAll.\n        if (scopes.length === 1) {\n            return scopes[0];\n        }\n\n        if (inner) {\n            for (let i = scopes.length - 1; i >= 0; --i) {\n                const scope = scopes[i];\n\n                if (predicate(scope)) {\n                    return scope;\n                }\n            }\n        } else {\n            for (let i = 0, iz = scopes.length; i < iz; ++i) {\n                const scope = scopes[i];\n\n                if (predicate(scope)) {\n                    return scope;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * acquire all scopes from node.\n     * @method ScopeManager#acquireAll\n     * @param {Espree.Node} node - node for the acquired scope.\n     * @returns {Scopes?} Scope array\n     */\n    acquireAll(node) {\n        return this.__get(node);\n    }\n\n    /**\n     * release the node.\n     * @method ScopeManager#release\n     * @param {Espree.Node} node - releasing node.\n     * @param {boolean=} inner - look up the most inner scope, default value is false.\n     * @returns {Scope?} upper scope for the node.\n     */\n    release(node, inner) {\n        const scopes = this.__get(node);\n\n        if (scopes && scopes.length) {\n            const scope = scopes[0].upper;\n\n            if (!scope) {\n                return null;\n            }\n            return this.acquire(scope.block, inner);\n        }\n        return null;\n    }\n\n    attach() { } // eslint-disable-line class-methods-use-this\n\n    detach() { } // eslint-disable-line class-methods-use-this\n\n    __nestScope(scope) {\n        if (scope instanceof GlobalScope) {\n            assert(this.__currentScope === null);\n            this.globalScope = scope;\n        }\n        this.__currentScope = scope;\n        return scope;\n    }\n\n    __nestGlobalScope(node) {\n        return this.__nestScope(new GlobalScope(this, node));\n    }\n\n    __nestBlockScope(node) {\n        return this.__nestScope(new BlockScope(this, this.__currentScope, node));\n    }\n\n    __nestFunctionScope(node, isMethodDefinition) {\n        return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));\n    }\n\n    __nestForScope(node) {\n        return this.__nestScope(new ForScope(this, this.__currentScope, node));\n    }\n\n    __nestCatchScope(node) {\n        return this.__nestScope(new CatchScope(this, this.__currentScope, node));\n    }\n\n    __nestWithScope(node) {\n        return this.__nestScope(new WithScope(this, this.__currentScope, node));\n    }\n\n    __nestClassScope(node) {\n        return this.__nestScope(new ClassScope(this, this.__currentScope, node));\n    }\n\n    __nestSwitchScope(node) {\n        return this.__nestScope(new SwitchScope(this, this.__currentScope, node));\n    }\n\n    __nestModuleScope(node) {\n        return this.__nestScope(new ModuleScope(this, this.__currentScope, node));\n    }\n\n    __nestFunctionExpressionNameScope(node) {\n        return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));\n    }\n\n    __isES6() {\n        return this.__options.ecmaVersion >= 6;\n    }\n}\n\nmodule.exports = ScopeManager;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable no-undefined */\n\nconst Syntax = require(\"estraverse\").Syntax;\n\nconst Reference = require(\"./reference\");\nconst Variable = require(\"./variable\");\nconst Definition = require(\"./definition\").Definition;\nconst assert = require(\"assert\");\n\n/**\n * Test if scope is struct\n * @param {Scope} scope - scope\n * @param {Block} block - block\n * @param {boolean} isMethodDefinition - is method definiton\n * @param {boolean} useDirective - use directive\n * @returns {boolean} is strict scope\n */\nfunction isStrictScope(scope, block, isMethodDefinition, useDirective) {\n    let body;\n\n    // When upper scope is exists and strict, inner scope is also strict.\n    if (scope.upper && scope.upper.isStrict) {\n        return true;\n    }\n\n    if (isMethodDefinition) {\n        return true;\n    }\n\n    if (scope.type === \"class\" || scope.type === \"module\") {\n        return true;\n    }\n\n    if (scope.type === \"block\" || scope.type === \"switch\") {\n        return false;\n    }\n\n    if (scope.type === \"function\") {\n        if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) {\n            return false;\n        }\n\n        if (block.type === Syntax.Program) {\n            body = block;\n        } else {\n            body = block.body;\n        }\n\n        if (!body) {\n            return false;\n        }\n    } else if (scope.type === \"global\") {\n        body = block;\n    } else {\n        return false;\n    }\n\n    // Search 'use strict' directive.\n    if (useDirective) {\n        for (let i = 0, iz = body.body.length; i < iz; ++i) {\n            const stmt = body.body[i];\n\n            if (stmt.type !== Syntax.DirectiveStatement) {\n                break;\n            }\n            if (stmt.raw === \"\\\"use strict\\\"\" || stmt.raw === \"'use strict'\") {\n                return true;\n            }\n        }\n    } else {\n        for (let i = 0, iz = body.body.length; i < iz; ++i) {\n            const stmt = body.body[i];\n\n            if (stmt.type !== Syntax.ExpressionStatement) {\n                break;\n            }\n            const expr = stmt.expression;\n\n            if (expr.type !== Syntax.Literal || typeof expr.value !== \"string\") {\n                break;\n            }\n            if (expr.raw !== null && expr.raw !== undefined) {\n                if (expr.raw === \"\\\"use strict\\\"\" || expr.raw === \"'use strict'\") {\n                    return true;\n                }\n            } else {\n                if (expr.value === \"use strict\") {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Register scope\n * @param {ScopeManager} scopeManager - scope manager\n * @param {Scope} scope - scope\n * @returns {void}\n */\nfunction registerScope(scopeManager, scope) {\n    scopeManager.scopes.push(scope);\n\n    const scopes = scopeManager.__nodeToScope.get(scope.block);\n\n    if (scopes) {\n        scopes.push(scope);\n    } else {\n        scopeManager.__nodeToScope.set(scope.block, [scope]);\n    }\n}\n\n/**\n * Should be statically\n * @param {Object} def - def\n * @returns {boolean} should be statically\n */\nfunction shouldBeStatically(def) {\n    return (\n        (def.type === Variable.ClassName) ||\n        (def.type === Variable.Variable && def.parent.kind !== \"var\")\n    );\n}\n\n/**\n * @class Scope\n */\nclass Scope {\n    constructor(scopeManager, type, upperScope, block, isMethodDefinition) {\n\n        /**\n         * One of 'module', 'block', 'switch', 'function', 'catch', 'with', 'function', 'class', 'global'.\n         * @member {String} Scope#type\n         */\n        this.type = type;\n\n         /**\n         * The scoped {@link Variable}s of this scope, as <code>{ Variable.name\n         * : Variable }</code>.\n         * @member {Map} Scope#set\n         */\n        this.set = new Map();\n\n        /**\n         * The tainted variables of this scope, as <code>{ Variable.name :\n         * boolean }</code>.\n         * @member {Map} Scope#taints */\n        this.taints = new Map();\n\n        /**\n         * Generally, through the lexical scoping of JS you can always know\n         * which variable an identifier in the source code refers to. There are\n         * a few exceptions to this rule. With 'global' and 'with' scopes you\n         * can only decide at runtime which variable a reference refers to.\n         * Moreover, if 'eval()' is used in a scope, it might introduce new\n         * bindings in this or its parent scopes.\n         * All those scopes are considered 'dynamic'.\n         * @member {boolean} Scope#dynamic\n         */\n        this.dynamic = this.type === \"global\" || this.type === \"with\";\n\n        /**\n         * A reference to the scope-defining syntax node.\n         * @member {espree.Node} Scope#block\n         */\n        this.block = block;\n\n         /**\n         * The {@link Reference|references} that are not resolved with this scope.\n         * @member {Reference[]} Scope#through\n         */\n        this.through = [];\n\n         /**\n         * The scoped {@link Variable}s of this scope. In the case of a\n         * 'function' scope this includes the automatic argument <em>arguments</em> as\n         * its first element, as well as all further formal arguments.\n         * @member {Variable[]} Scope#variables\n         */\n        this.variables = [];\n\n         /**\n         * Any variable {@link Reference|reference} found in this scope. This\n         * includes occurrences of local variables as well as variables from\n         * parent scopes (including the global scope). For local variables\n         * this also includes defining occurrences (like in a 'var' statement).\n         * In a 'function' scope this does not include the occurrences of the\n         * formal parameter in the parameter list.\n         * @member {Reference[]} Scope#references\n         */\n        this.references = [];\n\n         /**\n         * For 'global' and 'function' scopes, this is a self-reference. For\n         * other scope types this is the <em>variableScope</em> value of the\n         * parent scope.\n         * @member {Scope} Scope#variableScope\n         */\n        this.variableScope =\n            (this.type === \"global\" || this.type === \"function\" || this.type === \"module\") ? this : upperScope.variableScope;\n\n         /**\n         * Whether this scope is created by a FunctionExpression.\n         * @member {boolean} Scope#functionExpressionScope\n         */\n        this.functionExpressionScope = false;\n\n         /**\n         * Whether this is a scope that contains an 'eval()' invocation.\n         * @member {boolean} Scope#directCallToEvalScope\n         */\n        this.directCallToEvalScope = false;\n\n         /**\n         * @member {boolean} Scope#thisFound\n         */\n        this.thisFound = false;\n\n        this.__left = [];\n\n         /**\n         * Reference to the parent {@link Scope|scope}.\n         * @member {Scope} Scope#upper\n         */\n        this.upper = upperScope;\n\n         /**\n         * Whether 'use strict' is in effect in this scope.\n         * @member {boolean} Scope#isStrict\n         */\n        this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());\n\n         /**\n         * List of nested {@link Scope}s.\n         * @member {Scope[]} Scope#childScopes\n         */\n        this.childScopes = [];\n        if (this.upper) {\n            this.upper.childScopes.push(this);\n        }\n\n        this.__declaredVariables = scopeManager.__declaredVariables;\n\n        registerScope(scopeManager, this);\n    }\n\n    __shouldStaticallyClose(scopeManager) {\n        return (!this.dynamic || scopeManager.__isOptimistic());\n    }\n\n    __shouldStaticallyCloseForGlobal(ref) {\n\n        // On global scope, let/const/class declarations should be resolved statically.\n        const name = ref.identifier.name;\n\n        if (!this.set.has(name)) {\n            return false;\n        }\n\n        const variable = this.set.get(name);\n        const defs = variable.defs;\n\n        return defs.length > 0 && defs.every(shouldBeStatically);\n    }\n\n    __staticCloseRef(ref) {\n        if (!this.__resolve(ref)) {\n            this.__delegateToUpperScope(ref);\n        }\n    }\n\n    __dynamicCloseRef(ref) {\n\n        // notify all names are through to global\n        let current = this;\n\n        do {\n            current.through.push(ref);\n            current = current.upper;\n        } while (current);\n    }\n\n    __globalCloseRef(ref) {\n\n        // let/const/class declarations should be resolved statically.\n        // others should be resolved dynamically.\n        if (this.__shouldStaticallyCloseForGlobal(ref)) {\n            this.__staticCloseRef(ref);\n        } else {\n            this.__dynamicCloseRef(ref);\n        }\n    }\n\n    __close(scopeManager) {\n        let closeRef;\n\n        if (this.__shouldStaticallyClose(scopeManager)) {\n            closeRef = this.__staticCloseRef;\n        } else if (this.type !== \"global\") {\n            closeRef = this.__dynamicCloseRef;\n        } else {\n            closeRef = this.__globalCloseRef;\n        }\n\n        // Try Resolving all references in this scope.\n        for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n            const ref = this.__left[i];\n\n            closeRef.call(this, ref);\n        }\n        this.__left = null;\n\n        return this.upper;\n    }\n\n    // To override by function scopes.\n    // References in default parameters isn't resolved to variables which are in their function body.\n    __isValidResolution(ref, variable) { // eslint-disable-line class-methods-use-this, no-unused-vars\n        return true;\n    }\n\n    __resolve(ref) {\n        const name = ref.identifier.name;\n\n        if (!this.set.has(name)) {\n            return false;\n        }\n        const variable = this.set.get(name);\n\n        if (!this.__isValidResolution(ref, variable)) {\n            return false;\n        }\n        variable.references.push(ref);\n        variable.stack = variable.stack && ref.from.variableScope === this.variableScope;\n        if (ref.tainted) {\n            variable.tainted = true;\n            this.taints.set(variable.name, true);\n        }\n        ref.resolved = variable;\n\n        return true;\n    }\n\n    __delegateToUpperScope(ref) {\n        if (this.upper) {\n            this.upper.__left.push(ref);\n        }\n        this.through.push(ref);\n    }\n\n    __addDeclaredVariablesOfNode(variable, node) {\n        if (node === null || node === undefined) {\n            return;\n        }\n\n        let variables = this.__declaredVariables.get(node);\n\n        if (variables === null || variables === undefined) {\n            variables = [];\n            this.__declaredVariables.set(node, variables);\n        }\n        if (variables.indexOf(variable) === -1) {\n            variables.push(variable);\n        }\n    }\n\n    __defineGeneric(name, set, variables, node, def) {\n        let variable;\n\n        variable = set.get(name);\n        if (!variable) {\n            variable = new Variable(name, this);\n            set.set(name, variable);\n            variables.push(variable);\n        }\n\n        if (def) {\n            variable.defs.push(def);\n            this.__addDeclaredVariablesOfNode(variable, def.node);\n            this.__addDeclaredVariablesOfNode(variable, def.parent);\n        }\n        if (node) {\n            variable.identifiers.push(node);\n        }\n    }\n\n    __define(node, def) {\n        if (node && node.type === Syntax.Identifier) {\n            this.__defineGeneric(\n                    node.name,\n                    this.set,\n                    this.variables,\n                    node,\n                    def);\n        }\n    }\n\n    __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {\n\n        // because Array element may be null\n        if (!node || node.type !== Syntax.Identifier) {\n            return;\n        }\n\n        // Specially handle like `this`.\n        if (node.name === \"super\") {\n            return;\n        }\n\n        const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);\n\n        this.references.push(ref);\n        this.__left.push(ref);\n    }\n\n    __detectEval() {\n        let current = this;\n\n        this.directCallToEvalScope = true;\n        do {\n            current.dynamic = true;\n            current = current.upper;\n        } while (current);\n    }\n\n    __detectThis() {\n        this.thisFound = true;\n    }\n\n    __isClosed() {\n        return this.__left === null;\n    }\n\n    /**\n     * returns resolved {Reference}\n     * @method Scope#resolve\n     * @param {Espree.Identifier} ident - identifier to be resolved.\n     * @returns {Reference} reference\n     */\n    resolve(ident) {\n        let ref, i, iz;\n\n        assert(this.__isClosed(), \"Scope should be closed.\");\n        assert(ident.type === Syntax.Identifier, \"Target should be identifier.\");\n        for (i = 0, iz = this.references.length; i < iz; ++i) {\n            ref = this.references[i];\n            if (ref.identifier === ident) {\n                return ref;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * returns this scope is static\n     * @method Scope#isStatic\n     * @returns {boolean} static\n     */\n    isStatic() {\n        return !this.dynamic;\n    }\n\n    /**\n     * returns this scope has materialized arguments\n     * @method Scope#isArgumentsMaterialized\n     * @returns {boolean} arguemnts materialized\n     */\n    isArgumentsMaterialized() { // eslint-disable-line class-methods-use-this\n        return true;\n    }\n\n    /**\n     * returns this scope has materialized `this` reference\n     * @method Scope#isThisMaterialized\n     * @returns {boolean} this materialized\n     */\n    isThisMaterialized() { // eslint-disable-line class-methods-use-this\n        return true;\n    }\n\n    isUsedName(name) {\n        if (this.set.has(name)) {\n            return true;\n        }\n        for (let i = 0, iz = this.through.length; i < iz; ++i) {\n            if (this.through[i].identifier.name === name) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nclass GlobalScope extends Scope {\n    constructor(scopeManager, block) {\n        super(scopeManager, \"global\", null, block, false);\n        this.implicit = {\n            set: new Map(),\n            variables: [],\n\n            /**\n            * List of {@link Reference}s that are left to be resolved (i.e. which\n            * need to be linked to the variable they refer to).\n            * @member {Reference[]} Scope#implicit#left\n            */\n            left: []\n        };\n    }\n\n    __close(scopeManager) {\n        const implicit = [];\n\n        for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n            const ref = this.__left[i];\n\n            if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {\n                implicit.push(ref.__maybeImplicitGlobal);\n            }\n        }\n\n        // create an implicit global variable from assignment expression\n        for (let i = 0, iz = implicit.length; i < iz; ++i) {\n            const info = implicit[i];\n\n            this.__defineImplicit(info.pattern,\n                    new Definition(\n                        Variable.ImplicitGlobalVariable,\n                        info.pattern,\n                        info.node,\n                        null,\n                        null,\n                        null\n                    ));\n\n        }\n\n        this.implicit.left = this.__left;\n\n        return super.__close(scopeManager);\n    }\n\n    __defineImplicit(node, def) {\n        if (node && node.type === Syntax.Identifier) {\n            this.__defineGeneric(\n                    node.name,\n                    this.implicit.set,\n                    this.implicit.variables,\n                    node,\n                    def);\n        }\n    }\n}\n\nclass ModuleScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"module\", upperScope, block, false);\n    }\n}\n\nclass FunctionExpressionNameScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"function-expression-name\", upperScope, block, false);\n        this.__define(block.id,\n                new Definition(\n                    Variable.FunctionName,\n                    block.id,\n                    block,\n                    null,\n                    null,\n                    null\n                ));\n        this.functionExpressionScope = true;\n    }\n}\n\nclass CatchScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"catch\", upperScope, block, false);\n    }\n}\n\nclass WithScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"with\", upperScope, block, false);\n    }\n\n    __close(scopeManager) {\n        if (this.__shouldStaticallyClose(scopeManager)) {\n            return super.__close(scopeManager);\n        }\n\n        for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n            const ref = this.__left[i];\n\n            ref.tainted = true;\n            this.__delegateToUpperScope(ref);\n        }\n        this.__left = null;\n\n        return this.upper;\n    }\n}\n\nclass BlockScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"block\", upperScope, block, false);\n    }\n}\n\nclass SwitchScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"switch\", upperScope, block, false);\n    }\n}\n\nclass FunctionScope extends Scope {\n    constructor(scopeManager, upperScope, block, isMethodDefinition) {\n        super(scopeManager, \"function\", upperScope, block, isMethodDefinition);\n\n        // section 9.2.13, FunctionDeclarationInstantiation.\n        // NOTE Arrow functions never have an arguments objects.\n        if (this.block.type !== Syntax.ArrowFunctionExpression) {\n            this.__defineArguments();\n        }\n    }\n\n    isArgumentsMaterialized() {\n\n        // TODO(Constellation)\n        // We can more aggressive on this condition like this.\n        //\n        // function t() {\n        //     // arguments of t is always hidden.\n        //     function arguments() {\n        //     }\n        // }\n        if (this.block.type === Syntax.ArrowFunctionExpression) {\n            return false;\n        }\n\n        if (!this.isStatic()) {\n            return true;\n        }\n\n        const variable = this.set.get(\"arguments\");\n\n        assert(variable, \"Always have arguments variable.\");\n        return variable.tainted || variable.references.length !== 0;\n    }\n\n    isThisMaterialized() {\n        if (!this.isStatic()) {\n            return true;\n        }\n        return this.thisFound;\n    }\n\n    __defineArguments() {\n        this.__defineGeneric(\n                \"arguments\",\n                this.set,\n                this.variables,\n                null,\n                null);\n        this.taints.set(\"arguments\", true);\n    }\n\n    // References in default parameters isn't resolved to variables which are in their function body.\n    //     const x = 1\n    //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.\n    //         const x = 2\n    //         console.log(a)\n    //     }\n    __isValidResolution(ref, variable) {\n\n        // If `options.nodejsScope` is true, `this.block` becomes a Program node.\n        if (this.block.type === \"Program\") {\n            return true;\n        }\n\n        const bodyStart = this.block.body.range[0];\n\n        // It's invalid resolution in the following case:\n        return !(\n            variable.scope === this &&\n            ref.identifier.range[0] < bodyStart &&                 // the reference is in the parameter part.\n            variable.defs.every(d => d.name.range[0] >= bodyStart) // the variable is in the body.\n        );\n    }\n}\n\nclass ForScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"for\", upperScope, block, false);\n    }\n}\n\nclass ClassScope extends Scope {\n    constructor(scopeManager, upperScope, block) {\n        super(scopeManager, \"class\", upperScope, block, false);\n    }\n}\n\nmodule.exports = {\n    Scope,\n    GlobalScope,\n    ModuleScope,\n    FunctionExpressionNameScope,\n    CatchScope,\n    WithScope,\n    BlockScope,\n    SwitchScope,\n    FunctionScope,\n    ForScope,\n    ClassScope\n};\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nconst READ = 0x1;\nconst WRITE = 0x2;\nconst RW = READ | WRITE;\n\n/**\n * A Reference represents a single occurrence of an identifier in code.\n * @class Reference\n */\nclass Reference {\n    constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {\n\n        /**\n         * Identifier syntax node.\n         * @member {espreeIdentifier} Reference#identifier\n         */\n        this.identifier = ident;\n\n        /**\n         * Reference to the enclosing Scope.\n         * @member {Scope} Reference#from\n         */\n        this.from = scope;\n\n        /**\n         * Whether the reference comes from a dynamic scope (such as 'eval',\n         * 'with', etc.), and may be trapped by dynamic scopes.\n         * @member {boolean} Reference#tainted\n         */\n        this.tainted = false;\n\n        /**\n         * The variable this reference is resolved with.\n         * @member {Variable} Reference#resolved\n         */\n        this.resolved = null;\n\n        /**\n         * The read-write mode of the reference. (Value is one of {@link\n         * Reference.READ}, {@link Reference.RW}, {@link Reference.WRITE}).\n         * @member {number} Reference#flag\n         * @private\n         */\n        this.flag = flag;\n        if (this.isWrite()) {\n\n            /**\n             * If reference is writeable, this is the tree being written to it.\n             * @member {espreeNode} Reference#writeExpr\n             */\n            this.writeExpr = writeExpr;\n\n            /**\n             * Whether the Reference might refer to a partial value of writeExpr.\n             * @member {boolean} Reference#partial\n             */\n            this.partial = partial;\n\n            /**\n             * Whether the Reference is to write of initialization.\n             * @member {boolean} Reference#init\n             */\n            this.init = init;\n        }\n        this.__maybeImplicitGlobal = maybeImplicitGlobal;\n    }\n\n    /**\n     * Whether the reference is static.\n     * @method Reference#isStatic\n     * @returns {boolean} static\n     */\n    isStatic() {\n        return !this.tainted && this.resolved && this.resolved.scope.isStatic();\n    }\n\n    /**\n     * Whether the reference is writeable.\n     * @method Reference#isWrite\n     * @returns {boolean} write\n     */\n    isWrite() {\n        return !!(this.flag & Reference.WRITE);\n    }\n\n    /**\n     * Whether the reference is readable.\n     * @method Reference#isRead\n     * @returns {boolean} read\n     */\n    isRead() {\n        return !!(this.flag & Reference.READ);\n    }\n\n    /**\n     * Whether the reference is read-only.\n     * @method Reference#isReadOnly\n     * @returns {boolean} read only\n     */\n    isReadOnly() {\n        return this.flag === Reference.READ;\n    }\n\n    /**\n     * Whether the reference is write-only.\n     * @method Reference#isWriteOnly\n     * @returns {boolean} write only\n     */\n    isWriteOnly() {\n        return this.flag === Reference.WRITE;\n    }\n\n    /**\n     * Whether the reference is read-write.\n     * @method Reference#isReadWrite\n     * @returns {boolean} read write\n     */\n    isReadWrite() {\n        return this.flag === Reference.RW;\n    }\n}\n\n/**\n * @constant Reference.READ\n * @private\n */\nReference.READ = READ;\n\n/**\n * @constant Reference.WRITE\n * @private\n */\nReference.WRITE = WRITE;\n\n/**\n * @constant Reference.RW\n * @private\n */\nReference.RW = RW;\n\nmodule.exports = Reference;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/**\n * A Variable represents a locally scoped identifier. These include arguments to\n * functions.\n * @class Variable\n */\nclass Variable {\n    constructor(name, scope) {\n\n        /**\n         * The variable name, as given in the source code.\n         * @member {String} Variable#name\n         */\n        this.name = name;\n\n        /**\n         * List of defining occurrences of this variable (like in 'var ...'\n         * statements or as parameter), as AST nodes.\n         * @member {espree.Identifier[]} Variable#identifiers\n         */\n        this.identifiers = [];\n\n        /**\n         * List of {@link Reference|references} of this variable (excluding parameter entries)\n         * in its defining scope and all nested scopes. For defining\n         * occurrences only see {@link Variable#defs}.\n         * @member {Reference[]} Variable#references\n         */\n        this.references = [];\n\n        /**\n         * List of defining occurrences of this variable (like in 'var ...'\n         * statements or as parameter), as custom objects.\n         * @member {Definition[]} Variable#defs\n         */\n        this.defs = [];\n\n        this.tainted = false;\n\n        /**\n         * Whether this is a stack variable.\n         * @member {boolean} Variable#stack\n         */\n        this.stack = true;\n\n        /**\n         * Reference to the enclosing Scope.\n         * @member {Scope} Variable#scope\n         */\n        this.scope = scope;\n    }\n}\n\nVariable.CatchClause = \"CatchClause\";\nVariable.Parameter = \"Parameter\";\nVariable.FunctionName = \"FunctionName\";\nVariable.ClassName = \"ClassName\";\nVariable.Variable = \"Variable\";\nVariable.ImportBinding = \"ImportBinding\";\nVariable.ImplicitGlobalVariable = \"ImplicitGlobalVariable\";\n\nmodule.exports = Variable;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nconst Variable = require(\"./variable\");\n\n/**\n * @class Definition\n */\nclass Definition {\n    constructor(type, name, node, parent, index, kind) {\n\n        /**\n         * @member {String} Definition#type - type of the occurrence (e.g. \"Parameter\", \"Variable\", ...).\n         */\n        this.type = type;\n\n        /**\n         * @member {espree.Identifier} Definition#name - the identifier AST node of the occurrence.\n         */\n        this.name = name;\n\n        /**\n         * @member {espree.Node} Definition#node - the enclosing node of the identifier.\n         */\n        this.node = node;\n\n        /**\n         * @member {espree.Node?} Definition#parent - the enclosing statement node of the identifier.\n         */\n        this.parent = parent;\n\n        /**\n         * @member {Number?} Definition#index - the index in the declaration statement.\n         */\n        this.index = index;\n\n        /**\n         * @member {String?} Definition#kind - the kind of the declaration statement.\n         */\n        this.kind = kind;\n    }\n}\n\n/**\n * @class ParameterDefinition\n */\nclass ParameterDefinition extends Definition {\n    constructor(name, node, index, rest) {\n        super(Variable.Parameter, name, node, null, index, null);\n\n        /**\n         * Whether the parameter definition is a part of a rest parameter.\n         * @member {boolean} ParameterDefinition#rest\n         */\n        this.rest = rest;\n    }\n}\n\nmodule.exports = {\n    ParameterDefinition,\n    Definition\n};\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable no-undefined */\n\nconst Syntax = require(\"estraverse\").Syntax;\nconst esrecurse = require(\"esrecurse\");\nconst Reference = require(\"./reference\");\nconst Variable = require(\"./variable\");\nconst PatternVisitor = require(\"./pattern-visitor\");\nconst definition = require(\"./definition\");\nconst assert = require(\"assert\");\n\nconst ParameterDefinition = definition.ParameterDefinition;\nconst Definition = definition.Definition;\n\n/**\n * Traverse identifier in pattern\n * @param {Object} options - options\n * @param {pattern} rootPattern - root pattern\n * @param {Refencer} referencer - referencer\n * @param {callback} callback - callback\n * @returns {void}\n */\nfunction traverseIdentifierInPattern(options, rootPattern, referencer, callback) {\n\n    // Call the callback at left hand identifier nodes, and Collect right hand nodes.\n    const visitor = new PatternVisitor(options, rootPattern, callback);\n\n    visitor.visit(rootPattern);\n\n    // Process the right hand nodes recursively.\n    if (referencer !== null && referencer !== undefined) {\n        visitor.rightHandNodes.forEach(referencer.visit, referencer);\n    }\n}\n\n// Importing ImportDeclaration.\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation\n// https://github.com/estree/estree/blob/master/es6.md#importdeclaration\n// FIXME: Now, we don't create module environment, because the context is\n// implementation dependent.\n\nclass Importer extends esrecurse.Visitor {\n    constructor(declaration, referencer) {\n        super(null, referencer.options);\n        this.declaration = declaration;\n        this.referencer = referencer;\n    }\n\n    visitImport(id, specifier) {\n        this.referencer.visitPattern(id, pattern => {\n            this.referencer.currentScope().__define(pattern,\n                new Definition(\n                    Variable.ImportBinding,\n                    pattern,\n                    specifier,\n                    this.declaration,\n                    null,\n                    null\n                    ));\n        });\n    }\n\n    ImportNamespaceSpecifier(node) {\n        const local = (node.local || node.id);\n\n        if (local) {\n            this.visitImport(local, node);\n        }\n    }\n\n    ImportDefaultSpecifier(node) {\n        const local = (node.local || node.id);\n\n        this.visitImport(local, node);\n    }\n\n    ImportSpecifier(node) {\n        const local = (node.local || node.id);\n\n        if (node.name) {\n            this.visitImport(node.name, node);\n        } else {\n            this.visitImport(local, node);\n        }\n    }\n}\n\n// Referencing variables and creating bindings.\nclass Referencer extends esrecurse.Visitor {\n    constructor(options, scopeManager) {\n        super(null, options);\n        this.options = options;\n        this.scopeManager = scopeManager;\n        this.parent = null;\n        this.isInnerMethodDefinition = false;\n    }\n\n    currentScope() {\n        return this.scopeManager.__currentScope;\n    }\n\n    close(node) {\n        while (this.currentScope() && node === this.currentScope().block) {\n            this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);\n        }\n    }\n\n    pushInnerMethodDefinition(isInnerMethodDefinition) {\n        const previous = this.isInnerMethodDefinition;\n\n        this.isInnerMethodDefinition = isInnerMethodDefinition;\n        return previous;\n    }\n\n    popInnerMethodDefinition(isInnerMethodDefinition) {\n        this.isInnerMethodDefinition = isInnerMethodDefinition;\n    }\n\n    referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {\n        const scope = this.currentScope();\n\n        assignments.forEach(assignment => {\n            scope.__referencing(\n                pattern,\n                Reference.WRITE,\n                assignment.right,\n                maybeImplicitGlobal,\n                pattern !== assignment.left,\n                init);\n        });\n    }\n\n    visitPattern(node, options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = { processRightHandNodes: false };\n        }\n        traverseIdentifierInPattern(\n            this.options,\n            node,\n            options.processRightHandNodes ? this : null,\n            callback);\n    }\n\n    visitFunction(node) {\n        let i, iz;\n\n        // FunctionDeclaration name is defined in upper scope\n        // NOTE: Not referring variableScope. It is intended.\n        // Since\n        //  in ES5, FunctionDeclaration should be in FunctionBody.\n        //  in ES6, FunctionDeclaration should be block scoped.\n\n        if (node.type === Syntax.FunctionDeclaration) {\n\n            // id is defined in upper scope\n            this.currentScope().__define(node.id,\n                    new Definition(\n                        Variable.FunctionName,\n                        node.id,\n                        node,\n                        null,\n                        null,\n                        null\n                    ));\n        }\n\n        // FunctionExpression with name creates its special scope;\n        // FunctionExpressionNameScope.\n        if (node.type === Syntax.FunctionExpression && node.id) {\n            this.scopeManager.__nestFunctionExpressionNameScope(node);\n        }\n\n        // Consider this function is in the MethodDefinition.\n        this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);\n\n        const that = this;\n\n        /**\n         * Visit pattern callback\n         * @param {pattern} pattern - pattern\n         * @param {Object} info - info\n         * @returns {void}\n         */\n        function visitPatternCallback(pattern, info) {\n            that.currentScope().__define(pattern,\n                new ParameterDefinition(\n                    pattern,\n                    node,\n                    i,\n                    info.rest\n                ));\n\n            that.referencingDefaultValue(pattern, info.assignments, null, true);\n        }\n\n        // Process parameter declarations.\n        for (i = 0, iz = node.params.length; i < iz; ++i) {\n            this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback);\n        }\n\n        // if there's a rest argument, add that\n        if (node.rest) {\n            this.visitPattern({\n                type: \"RestElement\",\n                argument: node.rest\n            }, pattern => {\n                this.currentScope().__define(pattern,\n                    new ParameterDefinition(\n                        pattern,\n                        node,\n                        node.params.length,\n                        true\n                    ));\n            });\n        }\n\n        // In TypeScript there are a number of function-like constructs which have no body,\n        // so check it exists before traversing\n        if (node.body) {\n\n            // Skip BlockStatement to prevent creating BlockStatement scope.\n            if (node.body.type === Syntax.BlockStatement) {\n                this.visitChildren(node.body);\n            } else {\n                this.visit(node.body);\n            }\n        }\n\n        this.close(node);\n    }\n\n    visitClass(node) {\n        if (node.type === Syntax.ClassDeclaration) {\n            this.currentScope().__define(node.id,\n                    new Definition(\n                        Variable.ClassName,\n                        node.id,\n                        node,\n                        null,\n                        null,\n                        null\n                    ));\n        }\n\n        this.visit(node.superClass);\n\n        this.scopeManager.__nestClassScope(node);\n\n        if (node.id) {\n            this.currentScope().__define(node.id,\n                    new Definition(\n                        Variable.ClassName,\n                        node.id,\n                        node\n                    ));\n        }\n        this.visit(node.body);\n\n        this.close(node);\n    }\n\n    visitProperty(node) {\n        let previous;\n\n        if (node.computed) {\n            this.visit(node.key);\n        }\n\n        const isMethodDefinition = node.type === Syntax.MethodDefinition;\n\n        if (isMethodDefinition) {\n            previous = this.pushInnerMethodDefinition(true);\n        }\n        this.visit(node.value);\n        if (isMethodDefinition) {\n            this.popInnerMethodDefinition(previous);\n        }\n    }\n\n    visitForIn(node) {\n        if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== \"var\") {\n            this.scopeManager.__nestForScope(node);\n        }\n\n        if (node.left.type === Syntax.VariableDeclaration) {\n            this.visit(node.left);\n            this.visitPattern(node.left.declarations[0].id, pattern => {\n                this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);\n            });\n        } else {\n            this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {\n                let maybeImplicitGlobal = null;\n\n                if (!this.currentScope().isStrict) {\n                    maybeImplicitGlobal = {\n                        pattern,\n                        node\n                    };\n                }\n                this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n                this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);\n            });\n        }\n        this.visit(node.right);\n        this.visit(node.body);\n\n        this.close(node);\n    }\n\n    visitVariableDeclaration(variableTargetScope, type, node, index) {\n\n        const decl = node.declarations[index];\n        const init = decl.init;\n\n        this.visitPattern(decl.id, { processRightHandNodes: true }, (pattern, info) => {\n            variableTargetScope.__define(\n                pattern,\n                new Definition(\n                    type,\n                    pattern,\n                    decl,\n                    node,\n                    index,\n                    node.kind\n                )\n            );\n\n            this.referencingDefaultValue(pattern, info.assignments, null, true);\n            if (init) {\n                this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);\n            }\n        });\n    }\n\n    AssignmentExpression(node) {\n        if (PatternVisitor.isPattern(node.left)) {\n            if (node.operator === \"=\") {\n                this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {\n                    let maybeImplicitGlobal = null;\n\n                    if (!this.currentScope().isStrict) {\n                        maybeImplicitGlobal = {\n                            pattern,\n                            node\n                        };\n                    }\n                    this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n                    this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);\n                });\n            } else {\n                this.currentScope().__referencing(node.left, Reference.RW, node.right);\n            }\n        } else {\n            this.visit(node.left);\n        }\n        this.visit(node.right);\n    }\n\n    CatchClause(node) {\n        this.scopeManager.__nestCatchScope(node);\n\n        this.visitPattern(node.param, { processRightHandNodes: true }, (pattern, info) => {\n            this.currentScope().__define(pattern,\n                new Definition(\n                    Variable.CatchClause,\n                    node.param,\n                    node,\n                    null,\n                    null,\n                    null\n                ));\n            this.referencingDefaultValue(pattern, info.assignments, null, true);\n        });\n        this.visit(node.body);\n\n        this.close(node);\n    }\n\n    Program(node) {\n        this.scopeManager.__nestGlobalScope(node);\n\n        if (this.scopeManager.__isNodejsScope()) {\n\n            // Force strictness of GlobalScope to false when using node.js scope.\n            this.currentScope().isStrict = false;\n            this.scopeManager.__nestFunctionScope(node, false);\n        }\n\n        if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {\n            this.scopeManager.__nestModuleScope(node);\n        }\n\n        if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {\n            this.currentScope().isStrict = true;\n        }\n\n        this.visitChildren(node);\n        this.close(node);\n    }\n\n    Identifier(node) {\n        this.currentScope().__referencing(node);\n    }\n\n    UpdateExpression(node) {\n        if (PatternVisitor.isPattern(node.argument)) {\n            this.currentScope().__referencing(node.argument, Reference.RW, null);\n        } else {\n            this.visitChildren(node);\n        }\n    }\n\n    MemberExpression(node) {\n        this.visit(node.object);\n        if (node.computed) {\n            this.visit(node.property);\n        }\n    }\n\n    Property(node) {\n        this.visitProperty(node);\n    }\n\n    MethodDefinition(node) {\n        this.visitProperty(node);\n    }\n\n    BreakStatement() {} // eslint-disable-line class-methods-use-this\n\n    ContinueStatement() {} // eslint-disable-line class-methods-use-this\n\n    LabeledStatement(node) {\n        this.visit(node.body);\n    }\n\n    ForStatement(node) {\n\n        // Create ForStatement declaration.\n        // NOTE: In ES6, ForStatement dynamically generates\n        // per iteration environment. However, escope is\n        // a static analyzer, we only generate one scope for ForStatement.\n        if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== \"var\") {\n            this.scopeManager.__nestForScope(node);\n        }\n\n        this.visitChildren(node);\n\n        this.close(node);\n    }\n\n    ClassExpression(node) {\n        this.visitClass(node);\n    }\n\n    ClassDeclaration(node) {\n        this.visitClass(node);\n    }\n\n    CallExpression(node) {\n\n        // Check this is direct call to eval\n        if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === \"eval\") {\n\n            // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and\n            // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.\n            this.currentScope().variableScope.__detectEval();\n        }\n        this.visitChildren(node);\n    }\n\n    BlockStatement(node) {\n        if (this.scopeManager.__isES6()) {\n            this.scopeManager.__nestBlockScope(node);\n        }\n\n        this.visitChildren(node);\n\n        this.close(node);\n    }\n\n    ThisExpression() {\n        this.currentScope().variableScope.__detectThis();\n    }\n\n    WithStatement(node) {\n        this.visit(node.object);\n\n        // Then nest scope for WithStatement.\n        this.scopeManager.__nestWithScope(node);\n\n        this.visit(node.body);\n\n        this.close(node);\n    }\n\n    VariableDeclaration(node) {\n        const variableTargetScope = (node.kind === \"var\") ? this.currentScope().variableScope : this.currentScope();\n\n        for (let i = 0, iz = node.declarations.length; i < iz; ++i) {\n            const decl = node.declarations[i];\n\n            this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);\n            if (decl.init) {\n                this.visit(decl.init);\n            }\n        }\n    }\n\n    // sec 13.11.8\n    SwitchStatement(node) {\n        this.visit(node.discriminant);\n\n        if (this.scopeManager.__isES6()) {\n            this.scopeManager.__nestSwitchScope(node);\n        }\n\n        for (let i = 0, iz = node.cases.length; i < iz; ++i) {\n            this.visit(node.cases[i]);\n        }\n\n        this.close(node);\n    }\n\n    FunctionDeclaration(node) {\n        this.visitFunction(node);\n    }\n\n    FunctionExpression(node) {\n        this.visitFunction(node);\n    }\n\n    ForOfStatement(node) {\n        this.visitForIn(node);\n    }\n\n    ForInStatement(node) {\n        this.visitForIn(node);\n    }\n\n    ArrowFunctionExpression(node) {\n        this.visitFunction(node);\n    }\n\n    ImportDeclaration(node) {\n        assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), \"ImportDeclaration should appear when the mode is ES6 and in the module context.\");\n\n        const importer = new Importer(node, this);\n\n        importer.visit(node);\n    }\n\n    visitExportDeclaration(node) {\n        if (node.source) {\n            return;\n        }\n        if (node.declaration) {\n            this.visit(node.declaration);\n            return;\n        }\n\n        this.visitChildren(node);\n    }\n\n    ExportDeclaration(node) {\n        this.visitExportDeclaration(node);\n    }\n\n    ExportNamedDeclaration(node) {\n        this.visitExportDeclaration(node);\n    }\n\n    ExportSpecifier(node) {\n        const local = (node.id || node.local);\n\n        this.visit(local);\n    }\n\n    MetaProperty() { // eslint-disable-line class-methods-use-this\n\n        // do nothing.\n    }\n}\n\nmodule.exports = Referencer;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/* eslint-disable no-undefined */\n\nconst Syntax = require(\"estraverse\").Syntax;\nconst esrecurse = require(\"esrecurse\");\n\n/**\n * Get last array element\n * @param {array} xs - array\n * @returns {any} Last elment\n */\nfunction getLast(xs) {\n    return xs[xs.length - 1] || null;\n}\n\nclass PatternVisitor extends esrecurse.Visitor {\n    static isPattern(node) {\n        const nodeType = node.type;\n\n        return (\n            nodeType === Syntax.Identifier ||\n            nodeType === Syntax.ObjectPattern ||\n            nodeType === Syntax.ArrayPattern ||\n            nodeType === Syntax.SpreadElement ||\n            nodeType === Syntax.RestElement ||\n            nodeType === Syntax.AssignmentPattern\n        );\n    }\n\n    constructor(options, rootPattern, callback) {\n        super(null, options);\n        this.rootPattern = rootPattern;\n        this.callback = callback;\n        this.assignments = [];\n        this.rightHandNodes = [];\n        this.restElements = [];\n    }\n\n    Identifier(pattern) {\n        const lastRestElement = getLast(this.restElements);\n\n        this.callback(pattern, {\n            topLevel: pattern === this.rootPattern,\n            rest: lastRestElement !== null && lastRestElement !== undefined && lastRestElement.argument === pattern,\n            assignments: this.assignments\n        });\n    }\n\n    Property(property) {\n\n        // Computed property's key is a right hand node.\n        if (property.computed) {\n            this.rightHandNodes.push(property.key);\n        }\n\n        // If it's shorthand, its key is same as its value.\n        // If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).\n        // If it's not shorthand, the name of new variable is its value's.\n        this.visit(property.value);\n    }\n\n    ArrayPattern(pattern) {\n        for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {\n            const element = pattern.elements[i];\n\n            this.visit(element);\n        }\n    }\n\n    AssignmentPattern(pattern) {\n        this.assignments.push(pattern);\n        this.visit(pattern.left);\n        this.rightHandNodes.push(pattern.right);\n        this.assignments.pop();\n    }\n\n    RestElement(pattern) {\n        this.restElements.push(pattern);\n        this.visit(pattern.argument);\n        this.restElements.pop();\n    }\n\n    MemberExpression(node) {\n\n        // Computed property's key is a right hand node.\n        if (node.computed) {\n            this.rightHandNodes.push(node.property);\n        }\n\n        // the object is only read, write to its property.\n        this.rightHandNodes.push(node.object);\n    }\n\n    //\n    // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.\n    // By spec, LeftHandSideExpression is Pattern or MemberExpression.\n    //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)\n    // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...\n    //\n\n    SpreadElement(node) {\n        this.visit(node.argument);\n    }\n\n    ArrayExpression(node) {\n        node.elements.forEach(this.visit, this);\n    }\n\n    AssignmentExpression(node) {\n        this.assignments.push(node);\n        this.visit(node.left);\n        this.rightHandNodes.push(node.right);\n        this.assignments.pop();\n    }\n\n    CallExpression(node) {\n\n        // arguments are right hand nodes.\n        node.arguments.forEach(a => {\n            this.rightHandNodes.push(a);\n        });\n        this.visit(node.callee);\n    }\n}\n\nmodule.exports = PatternVisitor;\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","module.exports = {\n  \"_args\": [\n    [\n      \"eslint-scope@4.0.3\",\n      \"C:\\\\Users\\\\87002\\\\Desktop\\\\friendshipclub2022\"\n    ]\n  ],\n  \"_from\": \"eslint-scope@4.0.3\",\n  \"_id\": \"eslint-scope@4.0.3\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha512-p7VutNr1O/QrxysMo3E45FjYDTeXBy0iTltPFNSqKAIfjDSXC+4dj+qfyuD8bfAXrW/y6lW3O76VaYNPKfpKrg==\",\n  \"_location\": \"/eslint-scope\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"version\",\n    \"registry\": true,\n    \"raw\": \"eslint-scope@4.0.3\",\n    \"name\": \"eslint-scope\",\n    \"escapedName\": \"eslint-scope\",\n    \"rawSpec\": \"4.0.3\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"4.0.3\"\n  },\n  \"_requiredBy\": [\n    \"/webpack\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/eslint-scope/-/eslint-scope-4.0.3.tgz\",\n  \"_spec\": \"4.0.3\",\n  \"_where\": \"C:\\\\Users\\\\87002\\\\Desktop\\\\friendshipclub2022\",\n  \"bugs\": {\n    \"url\": \"https://github.com/eslint/eslint-scope/issues\"\n  },\n  \"dependencies\": {\n    \"esrecurse\": \"^4.1.0\",\n    \"estraverse\": \"^4.1.1\"\n  },\n  \"description\": \"ECMAScript scope analyzer for ESLint\",\n  \"devDependencies\": {\n    \"chai\": \"^3.4.1\",\n    \"eslint\": \"^3.15.0\",\n    \"eslint-config-eslint\": \"^4.0.0\",\n    \"eslint-release\": \"^1.0.0\",\n    \"espree\": \"^3.1.1\",\n    \"istanbul\": \"^0.4.5\",\n    \"mocha\": \"^3.2.0\",\n    \"npm-license\": \"^0.3.3\",\n    \"shelljs\": \"^0.7.6\",\n    \"typescript\": \"~2.0.10\",\n    \"typescript-eslint-parser\": \"^1.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=4.0.0\"\n  },\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"lib\"\n  ],\n  \"homepage\": \"http://github.com/eslint/eslint-scope\",\n  \"license\": \"BSD-2-Clause\",\n  \"main\": \"lib/index.js\",\n  \"name\": \"eslint-scope\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/eslint/eslint-scope.git\"\n  },\n  \"scripts\": {\n    \"generate-alpharelease\": \"eslint-generate-prerelease alpha\",\n    \"generate-betarelease\": \"eslint-generate-prerelease beta\",\n    \"generate-rcrelease\": \"eslint-generate-prerelease rc\",\n    \"generate-release\": \"eslint-generate-release\",\n    \"lint\": \"node Makefile.js lint\",\n    \"publish-release\": \"eslint-publish-release\",\n    \"test\": \"node Makefile.js test\"\n  },\n  \"version\": \"4.0.3\"\n}\n"]}