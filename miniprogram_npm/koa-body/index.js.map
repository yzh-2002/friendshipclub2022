{"version":3,"sources":["index.js","unparsed.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * koa-body - index.js\n * Copyright(c) 2014\n * MIT Licensed\n *\n * @author  Daryl Lau (@dlau)\n * @author  Charlike Mike Reagent (@tunnckoCore)\n * @api private\n */\n\n\n\n/**\n * Module dependencies.\n */\n\nconst buddy = require('co-body');\nconst forms = require('formidable');\nconst symbolUnparsed = require('./unparsed.js');\n\n/**\n * Expose `requestbody()`.\n */\n\nmodule.exports = requestbody;\n\nconst jsonTypes = [\n  'application/json',\n  'application/json-patch+json',\n  'application/vnd.api+json',\n  'application/csp-report'\n];\n\n/**\n *\n * @param {Object} options\n * @see https://github.com/dlau/koa-body\n * @api public\n */\nfunction requestbody(opts) {\n  opts = opts || {};\n  opts.onError = 'onError' in opts ? opts.onError : false;\n  opts.patchNode = 'patchNode' in opts ? opts.patchNode : false;\n  opts.patchKoa = 'patchKoa' in opts ? opts.patchKoa : true;\n  opts.multipart = 'multipart' in opts ? opts.multipart : false;\n  opts.urlencoded = 'urlencoded' in opts ? opts.urlencoded : true;\n  opts.json = 'json' in opts ? opts.json : true;\n  opts.text = 'text' in opts ? opts.text : true;\n  opts.encoding = 'encoding' in opts ? opts.encoding : 'utf-8';\n  opts.jsonLimit = 'jsonLimit' in opts ? opts.jsonLimit : '1mb';\n  opts.jsonStrict = 'jsonStrict' in opts ? opts.jsonStrict : true;\n  opts.formLimit = 'formLimit' in opts ? opts.formLimit : '56kb';\n  opts.queryString = 'queryString' in opts ? opts.queryString : null;\n  opts.formidable = 'formidable' in opts ? opts.formidable : {};\n  opts.includeUnparsed = 'includeUnparsed' in opts ? opts.includeUnparsed : false\n  opts.textLimit = 'textLimit' in opts ? opts.textLimit : '56kb';\n\n  // @todo: next major version, opts.strict support should be removed\n  if (opts.strict && opts.parsedMethods) {\n    throw new Error('Cannot use strict and parsedMethods options at the same time.')\n  }\n\n  if ('strict' in opts) {\n    console.warn('DEPRECATED: opts.strict has been deprecated in favor of opts.parsedMethods.')\n    if (opts.strict) {\n      opts.parsedMethods = ['POST', 'PUT', 'PATCH']\n    } else {\n      opts.parsedMethods = ['POST', 'PUT', 'PATCH', 'GET', 'HEAD', 'DELETE']\n    }\n  }\n\n  opts.parsedMethods = 'parsedMethods' in opts ? opts.parsedMethods : ['POST', 'PUT', 'PATCH']\n  opts.parsedMethods = opts.parsedMethods.map(function (method) { return method.toUpperCase() })\n\n  return function (ctx, next) {\n    var bodyPromise;\n    // only parse the body on specifically chosen methods\n    if (opts.parsedMethods.includes(ctx.method.toUpperCase())) {\n      try {\n        if (opts.json && ctx.is(jsonTypes)) {\n          bodyPromise = buddy.json(ctx, {\n            encoding: opts.encoding,\n            limit: opts.jsonLimit,\n            strict: opts.jsonStrict,\n            returnRawBody: opts.includeUnparsed\n          });\n        } else if (opts.urlencoded && ctx.is('urlencoded')) {\n          bodyPromise = buddy.form(ctx, {\n            encoding: opts.encoding,\n            limit: opts.formLimit,\n            queryString: opts.queryString,\n            returnRawBody: opts.includeUnparsed\n          });\n        } else if (opts.text && ctx.is('text/*')) {\n          bodyPromise = buddy.text(ctx, {\n            encoding: opts.encoding,\n            limit: opts.textLimit,\n            returnRawBody: opts.includeUnparsed\n          });\n        } else if (opts.multipart && ctx.is('multipart')) {\n          bodyPromise = formy(ctx, opts.formidable);\n        }\n      } catch (parsingError) {\n        if (typeof opts.onError === 'function') {\n          opts.onError(parsingError, ctx);\n        } else {\n          throw parsingError;\n        }\n      }\n    }\n\n    bodyPromise = bodyPromise || Promise.resolve({});\n    return bodyPromise.catch(function(parsingError) {\n      if (typeof opts.onError === 'function') {\n        opts.onError(parsingError, ctx);\n      } else {\n        throw parsingError;\n      }\n      return next();\n    })\n    .then(function(body) {\n      if (opts.patchNode) {\n        if (isMultiPart(ctx, opts)) {\n          ctx.req.body = body.fields;\n          ctx.req.files = body.files;\n        } else if (opts.includeUnparsed) {\n          ctx.req.body = body.parsed || {};\n          if (! ctx.is('text/*')) {\n            ctx.req.body[symbolUnparsed] = body.raw;\n          }\n        } else {\n          ctx.req.body = body;\n        }\n      }\n      if (opts.patchKoa) {\n        if (isMultiPart(ctx, opts)) {\n          ctx.request.body = body.fields;\n          ctx.request.files = body.files;\n        } else if (opts.includeUnparsed) {\n          ctx.request.body = body.parsed || {};\n          if (! ctx.is('text/*')) {\n            ctx.request.body[symbolUnparsed] = body.raw;\n          }\n        } else {\n          ctx.request.body = body;\n        }\n      }\n      return next();\n    })\n  };\n}\n\n/**\n * Check if multipart handling is enabled and that this is a multipart request\n *\n * @param  {Object} ctx\n * @param  {Object} opts\n * @return {Boolean} true if request is multipart and being treated as so\n * @api private\n */\nfunction isMultiPart(ctx, opts) {\n  return opts.multipart && ctx.is('multipart');\n}\n\n/**\n * Donable formidable\n *\n * @param  {Stream} ctx\n * @param  {Object} opts\n * @return {Promise}\n * @api private\n */\nfunction formy(ctx, opts) {\n  return new Promise(function (resolve, reject) {\n    var fields = {};\n    var files = {};\n    var form = new forms.IncomingForm(opts);\n    form.on('end', function () {\n      return resolve({\n        fields: fields,\n        files: files\n      });\n    }).on('error', function (err) {\n      return reject(err);\n    }).on('field', function (field, value) {\n      if (fields[field]) {\n        if (Array.isArray(fields[field])) {\n          fields[field].push(value);\n        } else {\n          fields[field] = [fields[field], value];\n        }\n      } else {\n        fields[field] = value;\n      }\n    }).on('file', function (field, file) {\n      if (files[field]) {\n        if (Array.isArray(files[field])) {\n          files[field].push(file);\n        } else {\n          files[field] = [files[field], file];\n        }\n      } else {\n        files[field] = file;\n      }\n    });\n    if (opts.onFileBegin) {\n      form.on('fileBegin', opts.onFileBegin);\n    }\n    form.parse(ctx.req);\n  });\n}\n","/**\r\n * koa-body - index.js\r\n * Copyright(c) 2014\r\n * MIT Licensed\r\n *\r\n * @author  Daryl Lau (@dlau)\r\n * @author  Charlike Mike Reagent (@tunnckoCore)\r\n * @author  Zev Isert (@zevisert)\r\n * @api private\r\n */\r\n\r\n\r\n\r\nmodule.exports = Symbol.for('unparsedBody');\r\n"]}