{"version":3,"sources":["async.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function(global, factory) {\n  /*jshint -W030 */\n  \n  typeof exports === 'object' && typeof module !== 'undefined'\n    ? factory(exports)\n    : typeof define === 'function' && define.amd\n    ? define(['exports'], factory)\n    : global.async\n    ? factory((global.neo_async = global.neo_async || {}))\n    : factory((global.async = global.async || {}));\n})(this, function(exports) {\n  \n\n  var noop = function noop() {};\n  var throwError = function throwError() {\n    throw new Error('Callback was already called.');\n  };\n\n  var DEFAULT_TIMES = 5;\n  var DEFAULT_INTERVAL = 0;\n\n  var obj = 'object';\n  var func = 'function';\n  var isArray = Array.isArray;\n  var nativeKeys = Object.keys;\n  var nativePush = Array.prototype.push;\n  var iteratorSymbol = typeof Symbol === func && Symbol.iterator;\n\n  var nextTick, asyncNextTick, asyncSetImmediate;\n  createImmediate();\n\n  /**\n   * @memberof async\n   * @namespace each\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.each(array, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.each(array, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [[1, 0], [2, 2], [3, 1]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.each(object, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.each(object, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b']]\n   * });\n   *\n   * @example\n   *\n   * // break\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num !== 2);\n   *   }, num * 10);\n   * };\n   * async.each(array, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 2]\n   * });\n   *\n   */\n  var each = createEach(arrayEach, baseEach, symbolEach);\n\n  /**\n   * @memberof async\n   * @namespace map\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.map(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2];\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.map(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [[1, 0], [2, 2], [3, 1]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.map(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.map(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b']]\n   * });\n   *\n   */\n  var map = createMap(arrayEachIndex, baseEachIndex, symbolEachIndex, true);\n\n  /**\n   * @memberof async\n   * @namespace mapValues\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValues(array, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3, '2': 2 }\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValues(array, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3, '2': 2 }\n   *   console.log(order); // [[1, 0], [2, 2], [3, 1]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValues(object, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 3, c: 2 }\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValues(object, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 3, c: 2 }\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b']]\n   * });\n   *\n   */\n  var mapValues = createMap(arrayEachIndex, baseEachKey, symbolEachKey, false);\n\n  /**\n   * @memberof async\n   * @namespace filter\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filter(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3];\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filter(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3];\n   *   console.log(order); // [[1, 0], [2, 2], [3, 1]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filter(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3];\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filter(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3];\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b']]\n   * });\n   *\n   */\n  var filter = createFilter(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue, true);\n\n  /**\n   * @memberof async\n   * @namespace filterSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filterSeries(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3];\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filterSeries(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3]\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filterSeries(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3]\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filterSeries(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3]\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'c']]\n   * });\n   *\n   */\n  var filterSeries = createFilterSeries(true);\n\n  /**\n   * @memberof async\n   * @namespace filterLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filterLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 5, 3]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filterLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 5, 3]\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filterLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 5, 3]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.filterLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 5, 3]\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  var filterLimit = createFilterLimit(true);\n\n  /**\n   * @memberof async\n   * @namespace reject\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.reject(array, iterator, function(err, res) {\n   *   console.log(res); // [2];\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.reject(array, iterator, function(err, res) {\n   *   console.log(res); // [2];\n   *   console.log(order); // [[1, 0], [2, 2], [3, 1]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.reject(object, iterator, function(err, res) {\n   *   console.log(res); // [2];\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.reject(object, iterator, function(err, res) {\n   *   console.log(res); // [2];\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b']]\n   * });\n   *\n   */\n  var reject = createFilter(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue, false);\n\n  /**\n   * @memberof async\n   * @namespace rejectSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.rejectSeries(array, iterator, function(err, res) {\n   *   console.log(res); // [2];\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.rejectSeries(object, iterator, function(err, res) {\n   *   console.log(res); // [2];\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.rejectSeries(object, iterator, function(err, res) {\n   *   console.log(res); // [2];\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'c']]\n   * });\n   *\n   */\n  var rejectSeries = createFilterSeries(false);\n\n  /**\n   * @memberof async\n   * @namespace rejectLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.rejectLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [4, 2]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.rejectLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [4, 2]\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.rejectLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [4, 2]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.rejectLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [4, 2]\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  var rejectLimit = createFilterLimit(false);\n\n  /**\n   * @memberof async\n   * @namespace detect\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detect(array, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detect(array, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [[1, 0]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detect(object, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detect(object, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [[1, 'a']]\n   * });\n   *\n   */\n  var detect = createDetect(arrayEachValue, baseEachValue, symbolEachValue, true);\n\n  /**\n   * @memberof async\n   * @namespace detectSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detectSeries(array, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detectSeries(array, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [[1, 0]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detectSeries(object, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detectSeries(object, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [[1, 'a']]\n   * });\n   *\n   */\n  var detectSeries = createDetectSeries(true);\n\n  /**\n   * @memberof async\n   * @namespace detectLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detectLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detectLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [[1, 0]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detectLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.detectLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // 1\n   *   console.log(order); // [[1, 'a']]\n   * });\n   *\n   */\n  var detectLimit = createDetectLimit(true);\n\n  /**\n   * @memberof async\n   * @namespace every\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.every(array, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [1, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.every(array, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [[1, 0], [2, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.every(object, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [1, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.every(object, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [[1, 'a'], [2, 'c']]\n   * });\n   *\n   */\n  var every = createEvery(arrayEachValue, baseEachValue, symbolEachValue);\n\n  /**\n   * @memberof async\n   * @namespace everySeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.everySeries(array, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.everySeries(array, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.everySeries(object, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.everySeries(object, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [[1, 'a'], [3, 'b'] [2, 'c']]\n   * });\n   *\n   */\n  var everySeries = createEverySeries();\n\n  /**\n   * @memberof async\n   * @namespace everyLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.everyLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [1, 3, 5, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.everyLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.everyLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [1, 3, 5, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.everyLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // false\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e']]\n   * });\n   *\n   */\n  var everyLimit = createEveryLimit();\n\n  /**\n   * @memberof async\n   * @namespace pick\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2, 4];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pick(array, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3 }\n   *   console.log(order); // [1, 2, 3, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2, 4];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pick(array, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3 }\n   *   console.log(order); // [[0, 1], [2, 2], [3, 1], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pick(object, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 3 }\n   *   console.log(order); // [1, 2, 3, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pick(object, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 3 }\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b'], [4, 'd']]\n   * });\n   *\n   */\n  var pick = createPick(arrayEachIndexValue, baseEachKeyValue, symbolEachKeyValue, true);\n\n  /**\n   * @memberof async\n   * @namespace pickSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2, 4];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pickSeries(array, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3 }\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2, 4];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pickSeries(array, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3 }\n   *   console.log(order); // [[0, 1], [3, 1], [2, 2], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pickSeries(object, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 3 }\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pickSeries(object, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 3 }\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'c'], [4, 'd']]\n   * });\n   *\n   */\n  var pickSeries = createPickSeries(true);\n\n  /**\n   * @memberof async\n   * @namespace pickLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pickLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 5, '2': 3 }\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pickLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 5, '2': 3 }\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pickLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 5, c: 3 }\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.pickLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 5, c: 3 }\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  var pickLimit = createPickLimit(true);\n\n  /**\n   * @memberof async\n   * @namespace omit\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2, 4];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omit(array, iterator, function(err, res) {\n   *   console.log(res); // { '2': 2, '3': 4 }\n   *   console.log(order); // [1, 2, 3, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2, 4];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omit(array, iterator, function(err, res) {\n   *   console.log(res); // { '2': 2, '3': 4 }\n   *   console.log(order); // [[0, 1], [2, 2], [3, 1], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omit(object, iterator, function(err, res) {\n   *   console.log(res); // { c: 2, d: 4 }\n   *   console.log(order); // [1, 2, 3, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omit(object, iterator, function(err, res) {\n   *   console.log(res); // { c: 2, d: 4 }\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b'], [4, 'd']]\n   * });\n   *\n   */\n  var omit = createPick(arrayEachIndexValue, baseEachKeyValue, symbolEachKeyValue, false);\n\n  /**\n   * @memberof async\n   * @namespace omitSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2, 4];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omitSeries(array, iterator, function(err, res) {\n   *   console.log(res); // { '2': 2, '3': 4 }\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2, 4];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omitSeries(array, iterator, function(err, res) {\n   *   console.log(res); // { '2': 2, '3': 4 }\n   *   console.log(order); // [[0, 1], [3, 1], [2, 2], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omitSeries(object, iterator, function(err, res) {\n   *   console.log(res); // { c: 2, d: 4 }\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omitSeries(object, iterator, function(err, res) {\n   *   console.log(res); // { c: 2, d: 4 }\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'c'], [4, 'd']]\n   * });\n   *\n   */\n  var omitSeries = createPickSeries(false);\n\n  /**\n   * @memberof async\n   * @namespace omitLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omitLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // { '3': 4, '4': 2 }\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omitLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // { '3': 4, '4': 2 }\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omitLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { d: 4, e: 2 }\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.omitLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { d: 4, e: 2 }\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  var omitLimit = createPickLimit(false);\n\n  /**\n   * @memberof async\n   * @namespace transform\n   * @param {Array|Object} collection\n   * @param {Array|Object|Function} [accumulator]\n   * @param {Function} [iterator]\n   * @param {Function} [callback]\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var collection = [1, 3, 2, 4];\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     result.push(num)\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transform(collection, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4]\n   *   console.log(order); // [1, 2, 3, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index and accumulator\n   * var order = [];\n   * var collection = [1, 3, 2, 4];\n   * var iterator = function(result, num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     result[index] = num;\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transform(collection, {}, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3, '2': 2, '3': 4 }\n   *   console.log(order); // [[1, 0], [2, 2], [3, 1], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object with accumulator\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     result.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transform(collection, [], iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4]\n   *   console.log(order); // [1, 2, 3, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(result, num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     result[key] = num;\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transform(collection, iterator, function(err, res) {\n   *   console.log(res); //  { a: 1, b: 3, c: 2, d: 4 }\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b'], [4, 'd']]\n   * });\n   *\n   */\n  var transform = createTransform(arrayEachResult, baseEachResult, symbolEachResult);\n\n  /**\n   * @memberof async\n   * @namespace sortBy\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortBy(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3];\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortBy(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [[1, 0], [2, 2], [3, 1]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortBy(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortBy(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b']]\n   * });\n   *\n   */\n  var sortBy = createSortBy(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue);\n\n  /**\n   * @memberof async\n   * @namespace concat\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concat(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3];\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concat(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [[1, 0], [2, 2], [3, 1]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concat(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [1, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concat(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [[1, 'a'], [2, 'c'], [3, 'b']]\n   * });\n   *\n   */\n  var concat = createConcat(arrayEachIndex, baseEachIndex, symbolEachIndex);\n\n  /**\n   * @memberof async\n   * @namespace groupBy\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [4.2, 6.4, 6.1];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupBy(array, iterator, function(err, res) {\n   *   console.log(res); // { '4': [4.2], '6': [6.1, 6.4] }\n   *   console.log(order); // [4.2, 6.1, 6.4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [4.2, 6.4, 6.1];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupBy(array, iterator, function(err, res) {\n   *   console.log(res); // { '4': [4.2], '6': [6.1, 6.4] }\n   *   console.log(order); // [[4.2, 0], [6.1, 2], [6.4, 1]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 4.2, b: 6.4, c: 6.1 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupBy(object, iterator, function(err, res) {\n   *   console.log(res); // { '4': [4.2], '6': [6.1, 6.4] }\n   *   console.log(order); // [4.2, 6.1, 6.4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 4.2, b: 6.4, c: 6.1 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupBy(object, iterator, function(err, res) {\n   *   console.log(res); // { '4': [4.2], '6': [6.1, 6.4] }\n   *   console.log(order); // [[4.2, 'a'], [6.1, 'c'], [6.4, 'b']]\n   * });\n   *\n   */\n  var groupBy = createGroupBy(arrayEachValue, baseEachValue, symbolEachValue);\n\n  /**\n   * @memberof async\n   * @namespace parallel\n   * @param {Array|Object} tasks - functions\n   * @param {Function} callback\n   * @example\n   *\n   * var order = [];\n   * var tasks = [\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(1);\n   *      done(null, 1);\n   *    }, 10);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(2);\n   *      done(null, 2);\n   *    }, 30);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(3);\n   *      done(null, 3);\n   *    }, 40);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(4);\n   *      done(null, 4);\n   *    }, 20);\n   *  }\n   * ];\n   * async.parallel(tasks, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4];\n   *   console.log(order); // [1, 4, 2, 3]\n   * });\n   *\n   * @example\n   *\n   * var order = [];\n   * var tasks = {\n   *   'a': function(done) {\n   *     setTimeout(function() {\n   *       order.push(1);\n   *       done(null, 1);\n   *     }, 10);\n   *   },\n   *   'b': function(done) {\n   *     setTimeout(function() {\n   *       order.push(2);\n   *       done(null, 2);\n   *     }, 30);\n   *   },\n   *   'c': function(done) {\n   *     setTimeout(function() {\n   *       order.push(3);\n   *       done(null, 3);\n   *     }, 40);\n   *   },\n   *   'd': function(done) {\n   *     setTimeout(function() {\n   *       order.push(4);\n   *       done(null, 4);\n   *     }, 20);\n   *   }\n   * };\n   * async.parallel(tasks, function(err, res) {\n   *   console.log(res); // { a: 1, b: 2, c: 3, d:4 }\n   *   console.log(order); // [1, 4, 2, 3]\n   * });\n   *\n   */\n  var parallel = createParallel(arrayEachFunc, baseEachFunc);\n\n  /**\n   * @memberof async\n   * @namespace applyEach\n   */\n  var applyEach = createApplyEach(map);\n\n  /**\n   * @memberof async\n   * @namespace applyEachSeries\n   */\n  var applyEachSeries = createApplyEach(mapSeries);\n\n  /**\n   * @memberof async\n   * @namespace log\n   */\n  var log = createLogger('log');\n\n  /**\n   * @memberof async\n   * @namespace dir\n   */\n  var dir = createLogger('dir');\n\n  /**\n   * @version 2.6.2\n   * @namespace async\n   */\n  var index = {\n    VERSION: '2.6.2',\n\n    // Collections\n    each: each,\n    eachSeries: eachSeries,\n    eachLimit: eachLimit,\n    forEach: each,\n    forEachSeries: eachSeries,\n    forEachLimit: eachLimit,\n    eachOf: each,\n    eachOfSeries: eachSeries,\n    eachOfLimit: eachLimit,\n    forEachOf: each,\n    forEachOfSeries: eachSeries,\n    forEachOfLimit: eachLimit,\n    map: map,\n    mapSeries: mapSeries,\n    mapLimit: mapLimit,\n    mapValues: mapValues,\n    mapValuesSeries: mapValuesSeries,\n    mapValuesLimit: mapValuesLimit,\n    filter: filter,\n    filterSeries: filterSeries,\n    filterLimit: filterLimit,\n    select: filter,\n    selectSeries: filterSeries,\n    selectLimit: filterLimit,\n    reject: reject,\n    rejectSeries: rejectSeries,\n    rejectLimit: rejectLimit,\n    detect: detect,\n    detectSeries: detectSeries,\n    detectLimit: detectLimit,\n    find: detect,\n    findSeries: detectSeries,\n    findLimit: detectLimit,\n    pick: pick,\n    pickSeries: pickSeries,\n    pickLimit: pickLimit,\n    omit: omit,\n    omitSeries: omitSeries,\n    omitLimit: omitLimit,\n    reduce: reduce,\n    inject: reduce,\n    foldl: reduce,\n    reduceRight: reduceRight,\n    foldr: reduceRight,\n    transform: transform,\n    transformSeries: transformSeries,\n    transformLimit: transformLimit,\n    sortBy: sortBy,\n    sortBySeries: sortBySeries,\n    sortByLimit: sortByLimit,\n    some: some,\n    someSeries: someSeries,\n    someLimit: someLimit,\n    any: some,\n    anySeries: someSeries,\n    anyLimit: someLimit,\n    every: every,\n    everySeries: everySeries,\n    everyLimit: everyLimit,\n    all: every,\n    allSeries: everySeries,\n    allLimit: everyLimit,\n    concat: concat,\n    concatSeries: concatSeries,\n    concatLimit: concatLimit,\n    groupBy: groupBy,\n    groupBySeries: groupBySeries,\n    groupByLimit: groupByLimit,\n\n    // Control Flow\n    parallel: parallel,\n    series: series,\n    parallelLimit: parallelLimit,\n    tryEach: tryEach,\n    waterfall: waterfall,\n    angelFall: angelFall,\n    angelfall: angelFall,\n    whilst: whilst,\n    doWhilst: doWhilst,\n    until: until,\n    doUntil: doUntil,\n    during: during,\n    doDuring: doDuring,\n    forever: forever,\n    compose: compose,\n    seq: seq,\n    applyEach: applyEach,\n    applyEachSeries: applyEachSeries,\n    queue: queue,\n    priorityQueue: priorityQueue,\n    cargo: cargo,\n    auto: auto,\n    autoInject: autoInject,\n    retry: retry,\n    retryable: retryable,\n    iterator: iterator,\n    times: times,\n    timesSeries: timesSeries,\n    timesLimit: timesLimit,\n    race: race,\n\n    // Utils\n    apply: apply,\n    nextTick: asyncNextTick,\n    setImmediate: asyncSetImmediate,\n    memoize: memoize,\n    unmemoize: unmemoize,\n    ensureAsync: ensureAsync,\n    constant: constant,\n    asyncify: asyncify,\n    wrapSync: asyncify,\n    log: log,\n    dir: dir,\n    reflect: reflect,\n    reflectAll: reflectAll,\n    timeout: timeout,\n    createLogger: createLogger,\n\n    // Mode\n    safe: safe,\n    fast: fast\n  };\n\n  exports['default'] = index;\n  baseEachSync(\n    index,\n    function(func, key) {\n      exports[key] = func;\n    },\n    nativeKeys(index)\n  );\n\n  /**\n   * @private\n   */\n  function createImmediate(safeMode) {\n    var delay = function delay(fn) {\n      var args = slice(arguments, 1);\n      setTimeout(function() {\n        fn.apply(null, args);\n      });\n    };\n    asyncSetImmediate = typeof setImmediate === func ? setImmediate : delay;\n    if (typeof process === obj && typeof process.nextTick === func) {\n      nextTick = /^v0.10/.test(process.version) ? asyncSetImmediate : process.nextTick;\n      asyncNextTick = /^v0/.test(process.version) ? asyncSetImmediate : process.nextTick;\n    } else {\n      asyncNextTick = nextTick = asyncSetImmediate;\n    }\n    if (safeMode === false) {\n      nextTick = function(cb) {\n        cb();\n      };\n    }\n  }\n\n  /* sync functions based on lodash */\n\n  /**\n   * Converts `arguments` to an array.\n   *\n   * @private\n   * @param {Array} array = The array to slice.\n   */\n  function createArray(array) {\n    var index = -1;\n    var size = array.length;\n    var result = Array(size);\n\n    while (++index < size) {\n      result[index] = array[index];\n    }\n    return result;\n  }\n\n  /**\n   * Create an array from `start`\n   *\n   * @private\n   * @param {Array} array - The array to slice.\n   * @param {number} start - The start position.\n   */\n  function slice(array, start) {\n    var end = array.length;\n    var index = -1;\n    var size = end - start;\n    if (size <= 0) {\n      return [];\n    }\n    var result = Array(size);\n\n    while (++index < size) {\n      result[index] = array[index + start];\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * @param {Object} object\n   */\n  function objectClone(object) {\n    var keys = nativeKeys(object);\n    var size = keys.length;\n    var index = -1;\n    var result = {};\n\n    while (++index < size) {\n      var key = keys[index];\n      result[key] = object[key];\n    }\n    return result;\n  }\n\n  /**\n   * Create an array with all falsey values removed.\n   *\n   * @private\n   * @param {Array} array - The array to compact.\n   */\n  function compact(array) {\n    var index = -1;\n    var size = array.length;\n    var result = [];\n\n    while (++index < size) {\n      var value = array[index];\n      if (value) {\n        result[result.length] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Create an array of reverse sequence.\n   *\n   * @private\n   * @param {Array} array - The array to reverse.\n   */\n  function reverse(array) {\n    var index = -1;\n    var size = array.length;\n    var result = Array(size);\n    var resIndex = size;\n\n    while (++index < size) {\n      result[--resIndex] = array[index];\n    }\n    return result;\n  }\n\n  /**\n   * Checks if key exists in object property.\n   *\n   * @private\n   * @param {Object} object - The object to inspect.\n   * @param {string} key - The key to check.\n   */\n  function has(object, key) {\n    return object.hasOwnProperty(key);\n  }\n\n  /**\n   * Check if target exists in array.\n   * @private\n   * @param {Array} array\n   * @param {*} target\n   */\n  function notInclude(array, target) {\n    var index = -1;\n    var size = array.length;\n\n    while (++index < size) {\n      if (array[index] === target) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * @param {Array} array - The array to iterate over.\n   * @param {Function} iterator - The function invoked per iteration.\n   */\n  function arrayEachSync(array, iterator) {\n    var index = -1;\n    var size = array.length;\n\n    while (++index < size) {\n      iterator(array[index], index);\n    }\n    return array;\n  }\n\n  /**\n   * @private\n   * @param {Object} object - The object to iterate over.\n   * @param {Function} iterator - The function invoked per iteration.\n   * @param {Array} keys\n   */\n  function baseEachSync(object, iterator, keys) {\n    var index = -1;\n    var size = keys.length;\n\n    while (++index < size) {\n      var key = keys[index];\n      iterator(object[key], key);\n    }\n    return object;\n  }\n\n  /**\n   * @private\n   * @param {number} n\n   * @param {Function} iterator\n   */\n  function timesSync(n, iterator) {\n    var index = -1;\n    while (++index < n) {\n      iterator(index);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Array} array\n   * @param {number[]} criteria\n   */\n  function sortByCriteria(array, criteria) {\n    var l = array.length;\n    var indices = Array(l);\n    var i;\n    for (i = 0; i < l; i++) {\n      indices[i] = i;\n    }\n    quickSort(criteria, 0, l - 1, indices);\n    var result = Array(l);\n    for (var n = 0; n < l; n++) {\n      i = indices[n];\n      result[n] = i === undefined ? array[n] : array[i];\n    }\n    return result;\n  }\n\n  function partition(array, i, j, mid, indices) {\n    var l = i;\n    var r = j;\n    while (l <= r) {\n      i = l;\n      while (l < r && array[l] < mid) {\n        l++;\n      }\n      while (r >= i && array[r] >= mid) {\n        r--;\n      }\n      if (l > r) {\n        break;\n      }\n      swap(array, indices, l++, r--);\n    }\n    return l;\n  }\n\n  function swap(array, indices, l, r) {\n    var n = array[l];\n    array[l] = array[r];\n    array[r] = n;\n    var i = indices[l];\n    indices[l] = indices[r];\n    indices[r] = i;\n  }\n\n  function quickSort(array, i, j, indices) {\n    if (i === j) {\n      return;\n    }\n    var k = i;\n    while (++k <= j && array[i] === array[k]) {\n      var l = k - 1;\n      if (indices[l] > indices[k]) {\n        var index = indices[l];\n        indices[l] = indices[k];\n        indices[k] = index;\n      }\n    }\n    if (k > j) {\n      return;\n    }\n    var p = array[i] > array[k] ? i : k;\n    k = partition(array, i, j, array[p], indices);\n    quickSort(array, i, k - 1, indices);\n    quickSort(array, k, j, indices);\n  }\n\n  /**\n   * @Private\n   */\n  function makeConcatResult(array) {\n    var result = [];\n    arrayEachSync(array, function(value) {\n      if (value === noop) {\n        return;\n      }\n      if (isArray(value)) {\n        nativePush.apply(result, value);\n      } else {\n        result.push(value);\n      }\n    });\n    return result;\n  }\n\n  /* async functions */\n\n  /**\n   * @private\n   */\n  function arrayEach(array, iterator, callback) {\n    var index = -1;\n    var size = array.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        iterator(array[index], index, onlyOnce(callback));\n      }\n    } else {\n      while (++index < size) {\n        iterator(array[index], onlyOnce(callback));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function baseEach(object, iterator, callback, keys) {\n    var key;\n    var index = -1;\n    var size = keys.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        key = keys[index];\n        iterator(object[key], key, onlyOnce(callback));\n      }\n    } else {\n      while (++index < size) {\n        iterator(object[keys[index]], onlyOnce(callback));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function symbolEach(collection, iterator, callback) {\n    var iter = collection[iteratorSymbol]();\n    var index = 0;\n    var item;\n    if (iterator.length === 3) {\n      while ((item = iter.next()).done === false) {\n        iterator(item.value, index++, onlyOnce(callback));\n      }\n    } else {\n      while ((item = iter.next()).done === false) {\n        index++;\n        iterator(item.value, onlyOnce(callback));\n      }\n    }\n    return index;\n  }\n\n  /**\n   * @private\n   */\n  function arrayEachResult(array, result, iterator, callback) {\n    var index = -1;\n    var size = array.length;\n\n    if (iterator.length === 4) {\n      while (++index < size) {\n        iterator(result, array[index], index, onlyOnce(callback));\n      }\n    } else {\n      while (++index < size) {\n        iterator(result, array[index], onlyOnce(callback));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function baseEachResult(object, result, iterator, callback, keys) {\n    var key;\n    var index = -1;\n    var size = keys.length;\n\n    if (iterator.length === 4) {\n      while (++index < size) {\n        key = keys[index];\n        iterator(result, object[key], key, onlyOnce(callback));\n      }\n    } else {\n      while (++index < size) {\n        iterator(result, object[keys[index]], onlyOnce(callback));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function symbolEachResult(collection, result, iterator, callback) {\n    var item;\n    var index = 0;\n    var iter = collection[iteratorSymbol]();\n\n    if (iterator.length === 4) {\n      while ((item = iter.next()).done === false) {\n        iterator(result, item.value, index++, onlyOnce(callback));\n      }\n    } else {\n      while ((item = iter.next()).done === false) {\n        index++;\n        iterator(result, item.value, onlyOnce(callback));\n      }\n    }\n    return index;\n  }\n\n  /**\n   * @private\n   */\n  function arrayEachFunc(array, createCallback) {\n    var index = -1;\n    var size = array.length;\n\n    while (++index < size) {\n      array[index](createCallback(index));\n    }\n  }\n\n  /**\n   * @private\n   */\n  function baseEachFunc(object, createCallback, keys) {\n    var key;\n    var index = -1;\n    var size = keys.length;\n\n    while (++index < size) {\n      key = keys[index];\n      object[key](createCallback(key));\n    }\n  }\n\n  /**\n   * @private\n   */\n  function arrayEachIndex(array, iterator, createCallback) {\n    var index = -1;\n    var size = array.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        iterator(array[index], index, createCallback(index));\n      }\n    } else {\n      while (++index < size) {\n        iterator(array[index], createCallback(index));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function baseEachIndex(object, iterator, createCallback, keys) {\n    var key;\n    var index = -1;\n    var size = keys.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        key = keys[index];\n        iterator(object[key], key, createCallback(index));\n      }\n    } else {\n      while (++index < size) {\n        iterator(object[keys[index]], createCallback(index));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function symbolEachIndex(collection, iterator, createCallback) {\n    var item;\n    var index = 0;\n    var iter = collection[iteratorSymbol]();\n\n    if (iterator.length === 3) {\n      while ((item = iter.next()).done === false) {\n        iterator(item.value, index, createCallback(index++));\n      }\n    } else {\n      while ((item = iter.next()).done === false) {\n        iterator(item.value, createCallback(index++));\n      }\n    }\n    return index;\n  }\n\n  /**\n   * @private\n   */\n  function baseEachKey(object, iterator, createCallback, keys) {\n    var key;\n    var index = -1;\n    var size = keys.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        key = keys[index];\n        iterator(object[key], key, createCallback(key));\n      }\n    } else {\n      while (++index < size) {\n        key = keys[index];\n        iterator(object[key], createCallback(key));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function symbolEachKey(collection, iterator, createCallback) {\n    var item;\n    var index = 0;\n    var iter = collection[iteratorSymbol]();\n\n    if (iterator.length === 3) {\n      while ((item = iter.next()).done === false) {\n        iterator(item.value, index, createCallback(index++));\n      }\n    } else {\n      while ((item = iter.next()).done === false) {\n        iterator(item.value, createCallback(index++));\n      }\n    }\n    return index;\n  }\n\n  /**\n   * @private\n   */\n  function arrayEachValue(array, iterator, createCallback) {\n    var value;\n    var index = -1;\n    var size = array.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        value = array[index];\n        iterator(value, index, createCallback(value));\n      }\n    } else {\n      while (++index < size) {\n        value = array[index];\n        iterator(value, createCallback(value));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function baseEachValue(object, iterator, createCallback, keys) {\n    var key, value;\n    var index = -1;\n    var size = keys.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        key = keys[index];\n        value = object[key];\n        iterator(value, key, createCallback(value));\n      }\n    } else {\n      while (++index < size) {\n        value = object[keys[index]];\n        iterator(value, createCallback(value));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function symbolEachValue(collection, iterator, createCallback) {\n    var value, item;\n    var index = 0;\n    var iter = collection[iteratorSymbol]();\n\n    if (iterator.length === 3) {\n      while ((item = iter.next()).done === false) {\n        value = item.value;\n        iterator(value, index++, createCallback(value));\n      }\n    } else {\n      while ((item = iter.next()).done === false) {\n        index++;\n        value = item.value;\n        iterator(value, createCallback(value));\n      }\n    }\n    return index;\n  }\n\n  /**\n   * @private\n   */\n  function arrayEachIndexValue(array, iterator, createCallback) {\n    var value;\n    var index = -1;\n    var size = array.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        value = array[index];\n        iterator(value, index, createCallback(index, value));\n      }\n    } else {\n      while (++index < size) {\n        value = array[index];\n        iterator(value, createCallback(index, value));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function baseEachIndexValue(object, iterator, createCallback, keys) {\n    var key, value;\n    var index = -1;\n    var size = keys.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        key = keys[index];\n        value = object[key];\n        iterator(value, key, createCallback(index, value));\n      }\n    } else {\n      while (++index < size) {\n        value = object[keys[index]];\n        iterator(value, createCallback(index, value));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function symbolEachIndexValue(collection, iterator, createCallback) {\n    var value, item;\n    var index = 0;\n    var iter = collection[iteratorSymbol]();\n\n    if (iterator.length === 3) {\n      while ((item = iter.next()).done === false) {\n        value = item.value;\n        iterator(value, index, createCallback(index++, value));\n      }\n    } else {\n      while ((item = iter.next()).done === false) {\n        value = item.value;\n        iterator(value, createCallback(index++, value));\n      }\n    }\n    return index;\n  }\n\n  /**\n   * @private\n   */\n  function baseEachKeyValue(object, iterator, createCallback, keys) {\n    var key, value;\n    var index = -1;\n    var size = keys.length;\n\n    if (iterator.length === 3) {\n      while (++index < size) {\n        key = keys[index];\n        value = object[key];\n        iterator(value, key, createCallback(key, value));\n      }\n    } else {\n      while (++index < size) {\n        key = keys[index];\n        value = object[key];\n        iterator(value, createCallback(key, value));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  function symbolEachKeyValue(collection, iterator, createCallback) {\n    var value, item;\n    var index = 0;\n    var iter = collection[iteratorSymbol]();\n\n    if (iterator.length === 3) {\n      while ((item = iter.next()).done === false) {\n        value = item.value;\n        iterator(value, index, createCallback(index++, value));\n      }\n    } else {\n      while ((item = iter.next()).done === false) {\n        value = item.value;\n        iterator(value, createCallback(index++, value));\n      }\n    }\n    return index;\n  }\n\n  /**\n   * @private\n   * @param {Function} func\n   */\n  function onlyOnce(func) {\n    return function(err, res) {\n      var fn = func;\n      func = throwError;\n      fn(err, res);\n    };\n  }\n\n  /**\n   * @private\n   * @param {Function} func\n   */\n  function once(func) {\n    return function(err, res) {\n      var fn = func;\n      func = noop;\n      fn(err, res);\n    };\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   */\n  function createEach(arrayEach, baseEach, symbolEach) {\n    return function each(collection, iterator, callback) {\n      callback = once(callback || noop);\n      var size, keys;\n      var completed = 0;\n      if (isArray(collection)) {\n        size = collection.length;\n        arrayEach(collection, iterator, done);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = symbolEach(collection, iterator, done);\n        size && size === completed && callback(null);\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        baseEach(collection, iterator, done, keys);\n      }\n      if (!size) {\n        callback(null);\n      }\n\n      function done(err, bool) {\n        if (err) {\n          callback = once(callback);\n          callback(err);\n        } else if (++completed === size) {\n          callback(null);\n        } else if (bool === false) {\n          callback = once(callback);\n          callback(null);\n        }\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   * @param {Function} symbolEach\n   */\n  function createMap(arrayEach, baseEach, symbolEach, useArray) {\n    var init, clone;\n    if (useArray) {\n      init = Array;\n      clone = createArray;\n    } else {\n      init = function() {\n        return {};\n      };\n      clone = objectClone;\n    }\n\n    return function(collection, iterator, callback) {\n      callback = callback || noop;\n      var size, keys, result;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        result = init(size);\n        arrayEach(collection, iterator, createCallback);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        // TODO: size could be changed\n        result = init(0);\n        size = symbolEach(collection, iterator, createCallback);\n        size && size === completed && callback(null, result);\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        result = init(size);\n        baseEach(collection, iterator, createCallback, keys);\n      }\n      if (!size) {\n        callback(null, init());\n      }\n\n      function createCallback(key) {\n        return function done(err, res) {\n          if (key === null) {\n            throwError();\n          }\n          if (err) {\n            key = null;\n            callback = once(callback);\n            callback(err, clone(result));\n            return;\n          }\n          result[key] = res;\n          key = null;\n          if (++completed === size) {\n            callback(null, result);\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   * @param {Function} symbolEach\n   * @param {boolean} bool\n   */\n  function createFilter(arrayEach, baseEach, symbolEach, bool) {\n    return function(collection, iterator, callback) {\n      callback = callback || noop;\n      var size, keys, result;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        result = Array(size);\n        arrayEach(collection, iterator, createCallback);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        result = [];\n        size = symbolEach(collection, iterator, createCallback);\n        size && size === completed && callback(null, compact(result));\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        result = Array(size);\n        baseEach(collection, iterator, createCallback, keys);\n      }\n      if (!size) {\n        return callback(null, []);\n      }\n\n      function createCallback(index, value) {\n        return function done(err, res) {\n          if (index === null) {\n            throwError();\n          }\n          if (err) {\n            index = null;\n            callback = once(callback);\n            callback(err);\n            return;\n          }\n          if (!!res === bool) {\n            result[index] = value;\n          }\n          index = null;\n          if (++completed === size) {\n            callback(null, compact(result));\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {boolean} bool\n   */\n  function createFilterSeries(bool) {\n    return function(collection, iterator, callback) {\n      callback = onlyOnce(callback || noop);\n      var size, key, value, keys, iter, item, iterate;\n      var sync = false;\n      var completed = 0;\n      var result = [];\n\n      if (isArray(collection)) {\n        size = collection.length;\n        iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = Infinity;\n        iter = collection[iteratorSymbol]();\n        iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n      }\n      if (!size) {\n        return callback(null, []);\n      }\n      iterate();\n\n      function arrayIterator() {\n        value = collection[completed];\n        iterator(value, done);\n      }\n\n      function arrayIteratorWithIndex() {\n        value = collection[completed];\n        iterator(value, completed, done);\n      }\n\n      function symbolIterator() {\n        item = iter.next();\n        value = item.value;\n        item.done ? callback(null, result) : iterator(value, done);\n      }\n\n      function symbolIteratorWithKey() {\n        item = iter.next();\n        value = item.value;\n        item.done ? callback(null, result) : iterator(value, completed, done);\n      }\n\n      function objectIterator() {\n        key = keys[completed];\n        value = collection[key];\n        iterator(value, done);\n      }\n\n      function objectIteratorWithKey() {\n        key = keys[completed];\n        value = collection[key];\n        iterator(value, key, done);\n      }\n\n      function done(err, res) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (!!res === bool) {\n          result[result.length] = value;\n        }\n        if (++completed === size) {\n          iterate = throwError;\n          callback(null, result);\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {boolean} bool\n   */\n  function createFilterLimit(bool) {\n    return function(collection, limit, iterator, callback) {\n      callback = callback || noop;\n      var size, index, key, value, keys, iter, item, iterate, result;\n      var sync = false;\n      var started = 0;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = Infinity;\n        result = [];\n        iter = collection[iteratorSymbol]();\n        iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n      }\n      if (!size || isNaN(limit) || limit < 1) {\n        return callback(null, []);\n      }\n      result = result || Array(size);\n      timesSync(limit > size ? size : limit, iterate);\n\n      function arrayIterator() {\n        index = started++;\n        if (index < size) {\n          value = collection[index];\n          iterator(value, createCallback(value, index));\n        }\n      }\n\n      function arrayIteratorWithIndex() {\n        index = started++;\n        if (index < size) {\n          value = collection[index];\n          iterator(value, index, createCallback(value, index));\n        }\n      }\n\n      function symbolIterator() {\n        item = iter.next();\n        if (item.done === false) {\n          value = item.value;\n          iterator(value, createCallback(value, started++));\n        } else if (completed === started && iterator !== noop) {\n          iterator = noop;\n          callback(null, compact(result));\n        }\n      }\n\n      function symbolIteratorWithKey() {\n        item = iter.next();\n        if (item.done === false) {\n          value = item.value;\n          iterator(value, started, createCallback(value, started++));\n        } else if (completed === started && iterator !== noop) {\n          iterator = noop;\n          callback(null, compact(result));\n        }\n      }\n\n      function objectIterator() {\n        index = started++;\n        if (index < size) {\n          value = collection[keys[index]];\n          iterator(value, createCallback(value, index));\n        }\n      }\n\n      function objectIteratorWithKey() {\n        index = started++;\n        if (index < size) {\n          key = keys[index];\n          value = collection[key];\n          iterator(value, key, createCallback(value, index));\n        }\n      }\n\n      function createCallback(value, index) {\n        return function(err, res) {\n          if (index === null) {\n            throwError();\n          }\n          if (err) {\n            index = null;\n            iterate = noop;\n            callback = once(callback);\n            callback(err);\n            return;\n          }\n          if (!!res === bool) {\n            result[index] = value;\n          }\n          index = null;\n          if (++completed === size) {\n            callback = onlyOnce(callback);\n            callback(null, compact(result));\n          } else if (sync) {\n            nextTick(iterate);\n          } else {\n            sync = true;\n            iterate();\n          }\n          sync = false;\n        };\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace eachSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.eachSeries(array, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.eachSeries(array, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.eachSeries(object, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.eachSeries(object, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'b']]\n   * });\n   *\n   * @example\n   *\n   * // break\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num !== 3);\n   *   }, num * 10);\n   * };\n   * async.eachSeries(array, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 3]\n   * });\n   */\n  function eachSeries(collection, iterator, callback) {\n    callback = onlyOnce(callback || noop);\n    var size, key, keys, iter, item, iterate;\n    var sync = false;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size) {\n      return callback(null);\n    }\n    iterate();\n\n    function arrayIterator() {\n      iterator(collection[completed], done);\n    }\n\n    function arrayIteratorWithIndex() {\n      iterator(collection[completed], completed, done);\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      item.done ? callback(null) : iterator(item.value, done);\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      item.done ? callback(null) : iterator(item.value, completed, done);\n    }\n\n    function objectIterator() {\n      iterator(collection[keys[completed]], done);\n    }\n\n    function objectIteratorWithKey() {\n      key = keys[completed];\n      iterator(collection[key], key, done);\n    }\n\n    function done(err, bool) {\n      if (err) {\n        callback(err);\n      } else if (++completed === size || bool === false) {\n        iterate = throwError;\n        callback(null);\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace eachLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.eachLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.eachLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.eachLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.eachLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   * @example\n   *\n   * // break\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num !== 5);\n   *   }, num * 10);\n   * };\n   * async.eachLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // undefined\n   *   console.log(order); // [1, 3, 5]\n   * });\n   *\n   */\n  function eachLimit(collection, limit, iterator, callback) {\n    callback = callback || noop;\n    var size, index, key, keys, iter, item, iterate;\n    var sync = false;\n    var started = 0;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    } else {\n      return callback(null);\n    }\n    if (!size || isNaN(limit) || limit < 1) {\n      return callback(null);\n    }\n    timesSync(limit > size ? size : limit, iterate);\n\n    function arrayIterator() {\n      if (started < size) {\n        iterator(collection[started++], done);\n      }\n    }\n\n    function arrayIteratorWithIndex() {\n      index = started++;\n      if (index < size) {\n        iterator(collection[index], index, done);\n      }\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      if (item.done === false) {\n        started++;\n        iterator(item.value, done);\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null);\n      }\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      if (item.done === false) {\n        iterator(item.value, started++, done);\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null);\n      }\n    }\n\n    function objectIterator() {\n      if (started < size) {\n        iterator(collection[keys[started++]], done);\n      }\n    }\n\n    function objectIteratorWithKey() {\n      index = started++;\n      if (index < size) {\n        key = keys[index];\n        iterator(collection[key], key, done);\n      }\n    }\n\n    function done(err, bool) {\n      if (err || bool === false) {\n        iterate = noop;\n        callback = once(callback);\n        callback(err);\n      } else if (++completed === size) {\n        iterator = noop;\n        iterate = throwError;\n        callback = onlyOnce(callback);\n        callback(null);\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace mapSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapSeries(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2];\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapSeries(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapSeries(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapSeries(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'c']]\n   * });\n   *\n   */\n  function mapSeries(collection, iterator, callback) {\n    callback = callback || noop;\n    var size, key, keys, iter, item, result, iterate;\n    var sync = false;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      result = [];\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size) {\n      return callback(null, []);\n    }\n    result = result || Array(size);\n    iterate();\n\n    function arrayIterator() {\n      iterator(collection[completed], done);\n    }\n\n    function arrayIteratorWithIndex() {\n      iterator(collection[completed], completed, done);\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(item.value, done);\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(item.value, completed, done);\n    }\n\n    function objectIterator() {\n      iterator(collection[keys[completed]], done);\n    }\n\n    function objectIteratorWithKey() {\n      key = keys[completed];\n      iterator(collection[key], key, done);\n    }\n\n    function done(err, res) {\n      if (err) {\n        iterate = throwError;\n        callback = onlyOnce(callback);\n        callback(err, createArray(result));\n        return;\n      }\n      result[completed] = res;\n      if (++completed === size) {\n        iterate = throwError;\n        callback(null, result);\n        callback = throwError;\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace mapLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 5, 3, 4, 2]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 5, 3, 4, 2]\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 5, 3, 4, 2]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 5, 3, 4, 2]\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  function mapLimit(collection, limit, iterator, callback) {\n    callback = callback || noop;\n    var size, index, key, keys, iter, item, result, iterate;\n    var sync = false;\n    var started = 0;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      result = [];\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size || isNaN(limit) || limit < 1) {\n      return callback(null, []);\n    }\n    result = result || Array(size);\n    timesSync(limit > size ? size : limit, iterate);\n\n    function arrayIterator() {\n      index = started++;\n      if (index < size) {\n        iterator(collection[index], createCallback(index));\n      }\n    }\n\n    function arrayIteratorWithIndex() {\n      index = started++;\n      if (index < size) {\n        iterator(collection[index], index, createCallback(index));\n      }\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      if (item.done === false) {\n        iterator(item.value, createCallback(started++));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, result);\n      }\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      if (item.done === false) {\n        iterator(item.value, started, createCallback(started++));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, result);\n      }\n    }\n\n    function objectIterator() {\n      index = started++;\n      if (index < size) {\n        iterator(collection[keys[index]], createCallback(index));\n      }\n    }\n\n    function objectIteratorWithKey() {\n      index = started++;\n      if (index < size) {\n        key = keys[index];\n        iterator(collection[key], key, createCallback(index));\n      }\n    }\n\n    function createCallback(index) {\n      return function(err, res) {\n        if (index === null) {\n          throwError();\n        }\n        if (err) {\n          index = null;\n          iterate = noop;\n          callback = once(callback);\n          callback(err, createArray(result));\n          return;\n        }\n        result[index] = res;\n        index = null;\n        if (++completed === size) {\n          iterate = throwError;\n          callback(null, result);\n          callback = throwError;\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      };\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace mapValuesSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValuesSeries(array, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3, '2': 2 }\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValuesSeries(array, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3, '2': 2 }\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValuesSeries(object, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 3, c: 2 }\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValuesSeries(object, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 3, c: 2 }\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'c']]\n   * });\n   *\n   */\n  function mapValuesSeries(collection, iterator, callback) {\n    callback = callback || noop;\n    var size, key, keys, iter, item, iterate;\n    var sync = false;\n    var result = {};\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size) {\n      return callback(null, result);\n    }\n    iterate();\n\n    function arrayIterator() {\n      key = completed;\n      iterator(collection[completed], done);\n    }\n\n    function arrayIteratorWithIndex() {\n      key = completed;\n      iterator(collection[completed], completed, done);\n    }\n\n    function symbolIterator() {\n      key = completed;\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(item.value, done);\n    }\n\n    function symbolIteratorWithKey() {\n      key = completed;\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(item.value, completed, done);\n    }\n\n    function objectIterator() {\n      key = keys[completed];\n      iterator(collection[key], done);\n    }\n\n    function objectIteratorWithKey() {\n      key = keys[completed];\n      iterator(collection[key], key, done);\n    }\n\n    function done(err, res) {\n      if (err) {\n        iterate = throwError;\n        callback = onlyOnce(callback);\n        callback(err, objectClone(result));\n        return;\n      }\n      result[key] = res;\n      if (++completed === size) {\n        iterate = throwError;\n        callback(null, result);\n        callback = throwError;\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace mapValuesLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValuesLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 5, '2': 3, '3': 4, '4': 2 }\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValuesLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 5, '2': 3, '3': 4, '4': 2 }\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValuesLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 5, c: 3, d: 4, e: 2 }\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.mapValuesLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 5, c: 3, d: 4, e: 2 }\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  function mapValuesLimit(collection, limit, iterator, callback) {\n    callback = callback || noop;\n    var size, index, key, keys, iter, item, iterate;\n    var sync = false;\n    var result = {};\n    var started = 0;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size || isNaN(limit) || limit < 1) {\n      return callback(null, result);\n    }\n    timesSync(limit > size ? size : limit, iterate);\n\n    function arrayIterator() {\n      index = started++;\n      if (index < size) {\n        iterator(collection[index], createCallback(index));\n      }\n    }\n\n    function arrayIteratorWithIndex() {\n      index = started++;\n      if (index < size) {\n        iterator(collection[index], index, createCallback(index));\n      }\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      if (item.done === false) {\n        iterator(item.value, createCallback(started++));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, result);\n      }\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      if (item.done === false) {\n        iterator(item.value, started, createCallback(started++));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, result);\n      }\n    }\n\n    function objectIterator() {\n      index = started++;\n      if (index < size) {\n        key = keys[index];\n        iterator(collection[key], createCallback(key));\n      }\n    }\n\n    function objectIteratorWithKey() {\n      index = started++;\n      if (index < size) {\n        key = keys[index];\n        iterator(collection[key], key, createCallback(key));\n      }\n    }\n\n    function createCallback(key) {\n      return function(err, res) {\n        if (key === null) {\n          throwError();\n        }\n        if (err) {\n          key = null;\n          iterate = noop;\n          callback = once(callback);\n          callback(err, objectClone(result));\n          return;\n        }\n        result[key] = res;\n        key = null;\n        if (++completed === size) {\n          callback(null, result);\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      };\n    }\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   * @param {Function} symbolEach\n   * @param {boolean} bool\n   */\n  function createDetect(arrayEach, baseEach, symbolEach, bool) {\n    return function(collection, iterator, callback) {\n      callback = callback || noop;\n      var size, keys;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        arrayEach(collection, iterator, createCallback);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = symbolEach(collection, iterator, createCallback);\n        size && size === completed && callback(null);\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        baseEach(collection, iterator, createCallback, keys);\n      }\n      if (!size) {\n        callback(null);\n      }\n\n      function createCallback(value) {\n        var called = false;\n        return function done(err, res) {\n          if (called) {\n            throwError();\n          }\n          called = true;\n          if (err) {\n            callback = once(callback);\n            callback(err);\n          } else if (!!res === bool) {\n            callback = once(callback);\n            callback(null, value);\n          } else if (++completed === size) {\n            callback(null);\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {boolean} bool\n   */\n  function createDetectSeries(bool) {\n    return function(collection, iterator, callback) {\n      callback = onlyOnce(callback || noop);\n      var size, key, value, keys, iter, item, iterate;\n      var sync = false;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = Infinity;\n        iter = collection[iteratorSymbol]();\n        iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n      }\n      if (!size) {\n        return callback(null);\n      }\n      iterate();\n\n      function arrayIterator() {\n        value = collection[completed];\n        iterator(value, done);\n      }\n\n      function arrayIteratorWithIndex() {\n        value = collection[completed];\n        iterator(value, completed, done);\n      }\n\n      function symbolIterator() {\n        item = iter.next();\n        value = item.value;\n        item.done ? callback(null) : iterator(value, done);\n      }\n\n      function symbolIteratorWithKey() {\n        item = iter.next();\n        value = item.value;\n        item.done ? callback(null) : iterator(value, completed, done);\n      }\n\n      function objectIterator() {\n        value = collection[keys[completed]];\n        iterator(value, done);\n      }\n\n      function objectIteratorWithKey() {\n        key = keys[completed];\n        value = collection[key];\n        iterator(value, key, done);\n      }\n\n      function done(err, res) {\n        if (err) {\n          callback(err);\n        } else if (!!res === bool) {\n          iterate = throwError;\n          callback(null, value);\n        } else if (++completed === size) {\n          iterate = throwError;\n          callback(null);\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {boolean} bool\n   */\n  function createDetectLimit(bool) {\n    return function(collection, limit, iterator, callback) {\n      callback = callback || noop;\n      var size, index, key, value, keys, iter, item, iterate;\n      var sync = false;\n      var started = 0;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = Infinity;\n        iter = collection[iteratorSymbol]();\n        iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n      }\n      if (!size || isNaN(limit) || limit < 1) {\n        return callback(null);\n      }\n      timesSync(limit > size ? size : limit, iterate);\n\n      function arrayIterator() {\n        index = started++;\n        if (index < size) {\n          value = collection[index];\n          iterator(value, createCallback(value));\n        }\n      }\n\n      function arrayIteratorWithIndex() {\n        index = started++;\n        if (index < size) {\n          value = collection[index];\n          iterator(value, index, createCallback(value));\n        }\n      }\n\n      function symbolIterator() {\n        item = iter.next();\n        if (item.done === false) {\n          started++;\n          value = item.value;\n          iterator(value, createCallback(value));\n        } else if (completed === started && iterator !== noop) {\n          iterator = noop;\n          callback(null);\n        }\n      }\n\n      function symbolIteratorWithKey() {\n        item = iter.next();\n        if (item.done === false) {\n          value = item.value;\n          iterator(value, started++, createCallback(value));\n        } else if (completed === started && iterator !== noop) {\n          iterator = noop;\n          callback(null);\n        }\n      }\n\n      function objectIterator() {\n        index = started++;\n        if (index < size) {\n          value = collection[keys[index]];\n          iterator(value, createCallback(value));\n        }\n      }\n\n      function objectIteratorWithKey() {\n        if (started < size) {\n          key = keys[started++];\n          value = collection[key];\n          iterator(value, key, createCallback(value));\n        }\n      }\n\n      function createCallback(value) {\n        var called = false;\n        return function(err, res) {\n          if (called) {\n            throwError();\n          }\n          called = true;\n          if (err) {\n            iterate = noop;\n            callback = once(callback);\n            callback(err);\n          } else if (!!res === bool) {\n            iterate = noop;\n            callback = once(callback);\n            callback(null, value);\n          } else if (++completed === size) {\n            callback(null);\n          } else if (sync) {\n            nextTick(iterate);\n          } else {\n            sync = true;\n            iterate();\n          }\n          sync = false;\n        };\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   * @param {Function} symbolEach\n   * @param {boolean} bool\n   */\n  function createPick(arrayEach, baseEach, symbolEach, bool) {\n    return function(collection, iterator, callback) {\n      callback = callback || noop;\n      var size, keys;\n      var completed = 0;\n      var result = {};\n\n      if (isArray(collection)) {\n        size = collection.length;\n        arrayEach(collection, iterator, createCallback);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = symbolEach(collection, iterator, createCallback);\n        size && size === completed && callback(null, result);\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        baseEach(collection, iterator, createCallback, keys);\n      }\n      if (!size) {\n        return callback(null, {});\n      }\n\n      function createCallback(key, value) {\n        return function done(err, res) {\n          if (key === null) {\n            throwError();\n          }\n          if (err) {\n            key = null;\n            callback = once(callback);\n            callback(err, objectClone(result));\n            return;\n          }\n          if (!!res === bool) {\n            result[key] = value;\n          }\n          key = null;\n          if (++completed === size) {\n            callback(null, result);\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {boolean} bool\n   */\n  function createPickSeries(bool) {\n    return function(collection, iterator, callback) {\n      callback = onlyOnce(callback || noop);\n      var size, key, value, keys, iter, item, iterate;\n      var sync = false;\n      var result = {};\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = Infinity;\n        iter = collection[iteratorSymbol]();\n        iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n      }\n      if (!size) {\n        return callback(null, {});\n      }\n      iterate();\n\n      function arrayIterator() {\n        key = completed;\n        value = collection[completed];\n        iterator(value, done);\n      }\n\n      function arrayIteratorWithIndex() {\n        key = completed;\n        value = collection[completed];\n        iterator(value, completed, done);\n      }\n\n      function symbolIterator() {\n        key = completed;\n        item = iter.next();\n        value = item.value;\n        item.done ? callback(null, result) : iterator(value, done);\n      }\n\n      function symbolIteratorWithKey() {\n        key = completed;\n        item = iter.next();\n        value = item.value;\n        item.done ? callback(null, result) : iterator(value, key, done);\n      }\n\n      function objectIterator() {\n        key = keys[completed];\n        value = collection[key];\n        iterator(value, done);\n      }\n\n      function objectIteratorWithKey() {\n        key = keys[completed];\n        value = collection[key];\n        iterator(value, key, done);\n      }\n\n      function done(err, res) {\n        if (err) {\n          callback(err, result);\n          return;\n        }\n        if (!!res === bool) {\n          result[key] = value;\n        }\n        if (++completed === size) {\n          iterate = throwError;\n          callback(null, result);\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {boolean} bool\n   */\n  function createPickLimit(bool) {\n    return function(collection, limit, iterator, callback) {\n      callback = callback || noop;\n      var size, index, key, value, keys, iter, item, iterate;\n      var sync = false;\n      var result = {};\n      var started = 0;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = Infinity;\n        iter = collection[iteratorSymbol]();\n        iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n      }\n      if (!size || isNaN(limit) || limit < 1) {\n        return callback(null, {});\n      }\n      timesSync(limit > size ? size : limit, iterate);\n\n      function arrayIterator() {\n        index = started++;\n        if (index < size) {\n          value = collection[index];\n          iterator(value, createCallback(value, index));\n        }\n      }\n\n      function arrayIteratorWithIndex() {\n        index = started++;\n        if (index < size) {\n          value = collection[index];\n          iterator(value, index, createCallback(value, index));\n        }\n      }\n\n      function symbolIterator() {\n        item = iter.next();\n        if (item.done === false) {\n          value = item.value;\n          iterator(value, createCallback(value, started++));\n        } else if (completed === started && iterator !== noop) {\n          iterator = noop;\n          callback(null, result);\n        }\n      }\n\n      function symbolIteratorWithKey() {\n        item = iter.next();\n        if (item.done === false) {\n          value = item.value;\n          iterator(value, started, createCallback(value, started++));\n        } else if (completed === started && iterator !== noop) {\n          iterator = noop;\n          callback(null, result);\n        }\n      }\n\n      function objectIterator() {\n        if (started < size) {\n          key = keys[started++];\n          value = collection[key];\n          iterator(value, createCallback(value, key));\n        }\n      }\n\n      function objectIteratorWithKey() {\n        if (started < size) {\n          key = keys[started++];\n          value = collection[key];\n          iterator(value, key, createCallback(value, key));\n        }\n      }\n\n      function createCallback(value, key) {\n        return function(err, res) {\n          if (key === null) {\n            throwError();\n          }\n          if (err) {\n            key = null;\n            iterate = noop;\n            callback = once(callback);\n            callback(err, objectClone(result));\n            return;\n          }\n          if (!!res === bool) {\n            result[key] = value;\n          }\n          key = null;\n          if (++completed === size) {\n            iterate = throwError;\n            callback = onlyOnce(callback);\n            callback(null, result);\n          } else if (sync) {\n            nextTick(iterate);\n          } else {\n            sync = true;\n            iterate();\n          }\n          sync = false;\n        };\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace reduce\n   * @param {Array|Object} collection\n   * @param {*} result\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var collection = [1, 3, 2, 4];\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, result + num);\n   *   }, num * 10);\n   * };\n   * async.reduce(collection, 0, iterator, function(err, res) {\n   *   console.log(res); // 10\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var collection = [1, 3, 2, 4];\n   * var iterator = function(result, num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, result + num);\n   *   }, num * 10);\n   * };\n   * async.reduce(collection, '', iterator, function(err, res) {\n   *   console.log(res); // '1324'\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, result + num);\n   *   }, num * 10);\n   * };\n   * async.reduce(collection, '', iterator, function(err, res) {\n   *   console.log(res); // '1324'\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(result, num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, result + num);\n   *   }, num * 10);\n   * };\n   * async.reduce(collection, 0, iterator, function(err, res) {\n   *   console.log(res); // 10\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'b'], [4, 'd']]\n   * });\n   *\n   */\n  function reduce(collection, result, iterator, callback) {\n    callback = onlyOnce(callback || noop);\n    var size, key, keys, iter, item, iterate;\n    var sync = false;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size) {\n      return callback(null, result);\n    }\n    iterate(result);\n\n    function arrayIterator(result) {\n      iterator(result, collection[completed], done);\n    }\n\n    function arrayIteratorWithIndex(result) {\n      iterator(result, collection[completed], completed, done);\n    }\n\n    function symbolIterator(result) {\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(result, item.value, done);\n    }\n\n    function symbolIteratorWithKey(result) {\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(result, item.value, completed, done);\n    }\n\n    function objectIterator(result) {\n      iterator(result, collection[keys[completed]], done);\n    }\n\n    function objectIteratorWithKey(result) {\n      key = keys[completed];\n      iterator(result, collection[key], key, done);\n    }\n\n    function done(err, result) {\n      if (err) {\n        callback(err, result);\n      } else if (++completed === size) {\n        iterator = throwError;\n        callback(null, result);\n      } else if (sync) {\n        nextTick(function() {\n          iterate(result);\n        });\n      } else {\n        sync = true;\n        iterate(result);\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace reduceRight\n   * @param {Array|Object} collection\n   * @param {*} result\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var collection = [1, 3, 2, 4];\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, result + num);\n   *   }, num * 10);\n   * };\n   * async.reduceRight(collection, 0, iterator, function(err, res) {\n   *   console.log(res); // 10\n   *   console.log(order); // [4, 2, 3, 1]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var collection = [1, 3, 2, 4];\n   * var iterator = function(result, num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, result + num);\n   *   }, num * 10);\n   * };\n   * async.reduceRight(collection, '', iterator, function(err, res) {\n   *   console.log(res); // '4231'\n   *   console.log(order); // [[4, 3], [2, 2], [3, 1], [1, 0]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, result + num);\n   *   }, num * 10);\n   * };\n   * async.reduceRight(collection, '', iterator, function(err, res) {\n   *   console.log(res); // '4231'\n   *   console.log(order); // [4, 2, 3, 1]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(result, num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, result + num);\n   *   }, num * 10);\n   * };\n   * async.reduceRight(collection, 0, iterator, function(err, res) {\n   *   console.log(res); // 10\n   *   console.log(order); // [[4, 3], [2, 2], [3, 1], [1, 0]]\n   * });\n   *\n   */\n  function reduceRight(collection, result, iterator, callback) {\n    callback = onlyOnce(callback || noop);\n    var resIndex, index, key, keys, iter, item, col, iterate;\n    var sync = false;\n\n    if (isArray(collection)) {\n      resIndex = collection.length;\n      iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      col = [];\n      iter = collection[iteratorSymbol]();\n      index = -1;\n      while ((item = iter.next()).done === false) {\n        col[++index] = item.value;\n      }\n      collection = col;\n      resIndex = col.length;\n      iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      resIndex = keys.length;\n      iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!resIndex) {\n      return callback(null, result);\n    }\n    iterate(result);\n\n    function arrayIterator(result) {\n      iterator(result, collection[--resIndex], done);\n    }\n\n    function arrayIteratorWithIndex(result) {\n      iterator(result, collection[--resIndex], resIndex, done);\n    }\n\n    function objectIterator(result) {\n      iterator(result, collection[keys[--resIndex]], done);\n    }\n\n    function objectIteratorWithKey(result) {\n      key = keys[--resIndex];\n      iterator(result, collection[key], key, done);\n    }\n\n    function done(err, result) {\n      if (err) {\n        callback(err, result);\n      } else if (resIndex === 0) {\n        iterate = throwError;\n        callback(null, result);\n      } else if (sync) {\n        nextTick(function() {\n          iterate(result);\n        });\n      } else {\n        sync = true;\n        iterate(result);\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   * @param {Function} symbolEach\n   */\n  function createTransform(arrayEach, baseEach, symbolEach) {\n    return function transform(collection, accumulator, iterator, callback) {\n      if (arguments.length === 3) {\n        callback = iterator;\n        iterator = accumulator;\n        accumulator = undefined;\n      }\n      callback = callback || noop;\n      var size, keys, result;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        result = accumulator !== undefined ? accumulator : [];\n        arrayEach(collection, result, iterator, done);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        result = accumulator !== undefined ? accumulator : {};\n        size = symbolEach(collection, result, iterator, done);\n        size && size === completed && callback(null, result);\n      } else if (typeof collection === obj) {\n        keys = nativeKeys(collection);\n        size = keys.length;\n        result = accumulator !== undefined ? accumulator : {};\n        baseEach(collection, result, iterator, done, keys);\n      }\n      if (!size) {\n        callback(null, accumulator !== undefined ? accumulator : result || {});\n      }\n\n      function done(err, bool) {\n        if (err) {\n          callback = once(callback);\n          callback(err, isArray(result) ? createArray(result) : objectClone(result));\n        } else if (++completed === size) {\n          callback(null, result);\n        } else if (bool === false) {\n          callback = once(callback);\n          callback(null, isArray(result) ? createArray(result) : objectClone(result));\n        }\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace transformSeries\n   * @param {Array|Object} collection\n   * @param {Array|Object|Function} [accumulator]\n   * @param {Function} [iterator]\n   * @param {Function} [callback]\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var collection = [1, 3, 2, 4];\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     result.push(num)\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transformSeries(collection, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2, 4]\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index and accumulator\n   * var order = [];\n   * var collection = [1, 3, 2, 4];\n   * var iterator = function(result, num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     result[index] = num;\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transformSeries(collection, {}, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 3, '2': 2, '3': 4 }\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object with accumulator\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     result.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transformSeries(collection, [], iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2, 4]\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2, d: 4 };\n   * var iterator = function(result, num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     result[key] = num;\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transformSeries(collection, iterator, function(err, res) {\n   *   console.log(res); //  { a: 1, b: 3, c: 2, d: 4 }\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'b'], [4, 'd']]\n   * });\n   *\n   */\n  function transformSeries(collection, accumulator, iterator, callback) {\n    if (arguments.length === 3) {\n      callback = iterator;\n      iterator = accumulator;\n      accumulator = undefined;\n    }\n    callback = onlyOnce(callback || noop);\n    var size, key, keys, iter, item, iterate, result;\n    var sync = false;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      result = accumulator !== undefined ? accumulator : [];\n      iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      result = accumulator !== undefined ? accumulator : {};\n      iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      result = accumulator !== undefined ? accumulator : {};\n      iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size) {\n      return callback(null, accumulator !== undefined ? accumulator : result || {});\n    }\n    iterate();\n\n    function arrayIterator() {\n      iterator(result, collection[completed], done);\n    }\n\n    function arrayIteratorWithIndex() {\n      iterator(result, collection[completed], completed, done);\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(result, item.value, done);\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(result, item.value, completed, done);\n    }\n\n    function objectIterator() {\n      iterator(result, collection[keys[completed]], done);\n    }\n\n    function objectIteratorWithKey() {\n      key = keys[completed];\n      iterator(result, collection[key], key, done);\n    }\n\n    function done(err, bool) {\n      if (err) {\n        callback(err, result);\n      } else if (++completed === size || bool === false) {\n        iterate = throwError;\n        callback(null, result);\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace transformLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Array|Object|Function} [accumulator]\n   * @param {Function} [iterator]\n   * @param {Function} [callback]\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     result.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transformLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 5, 2, 4]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index and accumulator\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(result, num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     result[index] = key;\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transformLimit(array, 2, {}, iterator, function(err, res) {\n   *   console.log(res); // { '0': 1, '1': 5, '2': 3, '3': 4, '4': 2 }\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object with accumulator\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(result, num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     result.push(num);\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transformLimit(object, 2, [], iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 5, 2, 4]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(result, num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     result[key] = num;\n   *     done();\n   *   }, num * 10);\n   * };\n   * async.transformLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  function transformLimit(collection, limit, accumulator, iterator, callback) {\n    if (arguments.length === 4) {\n      callback = iterator;\n      iterator = accumulator;\n      accumulator = undefined;\n    }\n    callback = callback || noop;\n    var size, index, key, keys, iter, item, iterate, result;\n    var sync = false;\n    var started = 0;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      result = accumulator !== undefined ? accumulator : [];\n      iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      result = accumulator !== undefined ? accumulator : {};\n      iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      result = accumulator !== undefined ? accumulator : {};\n      iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size || isNaN(limit) || limit < 1) {\n      return callback(null, accumulator !== undefined ? accumulator : result || {});\n    }\n    timesSync(limit > size ? size : limit, iterate);\n\n    function arrayIterator() {\n      index = started++;\n      if (index < size) {\n        iterator(result, collection[index], onlyOnce(done));\n      }\n    }\n\n    function arrayIteratorWithIndex() {\n      index = started++;\n      if (index < size) {\n        iterator(result, collection[index], index, onlyOnce(done));\n      }\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      if (item.done === false) {\n        started++;\n        iterator(result, item.value, onlyOnce(done));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, result);\n      }\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      if (item.done === false) {\n        iterator(result, item.value, started++, onlyOnce(done));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, result);\n      }\n    }\n\n    function objectIterator() {\n      index = started++;\n      if (index < size) {\n        iterator(result, collection[keys[index]], onlyOnce(done));\n      }\n    }\n\n    function objectIteratorWithKey() {\n      index = started++;\n      if (index < size) {\n        key = keys[index];\n        iterator(result, collection[key], key, onlyOnce(done));\n      }\n    }\n\n    function done(err, bool) {\n      if (err || bool === false) {\n        iterate = noop;\n        callback(err || null, isArray(result) ? createArray(result) : objectClone(result));\n        callback = noop;\n      } else if (++completed === size) {\n        iterator = noop;\n        callback(null, result);\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @private\n   * @param {function} arrayEach\n   * @param {function} baseEach\n   * @param {function} symbolEach\n   */\n  function createSortBy(arrayEach, baseEach, symbolEach) {\n    return function sortBy(collection, iterator, callback) {\n      callback = callback || noop;\n      var size, array, criteria;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        array = Array(size);\n        criteria = Array(size);\n        arrayEach(collection, iterator, createCallback);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        array = [];\n        criteria = [];\n        size = symbolEach(collection, iterator, createCallback);\n        size && size === completed && callback(null, sortByCriteria(array, criteria));\n      } else if (typeof collection === obj) {\n        var keys = nativeKeys(collection);\n        size = keys.length;\n        array = Array(size);\n        criteria = Array(size);\n        baseEach(collection, iterator, createCallback, keys);\n      }\n      if (!size) {\n        callback(null, []);\n      }\n\n      function createCallback(index, value) {\n        var called = false;\n        array[index] = value;\n        return function done(err, criterion) {\n          if (called) {\n            throwError();\n          }\n          called = true;\n          criteria[index] = criterion;\n          if (err) {\n            callback = once(callback);\n            callback(err);\n          } else if (++completed === size) {\n            callback(null, sortByCriteria(array, criteria));\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace sortBySeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortBySeries(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3];\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortBySeries(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortBySeries(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortBySeries(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3]\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'c']]\n   * });\n   *\n   */\n  function sortBySeries(collection, iterator, callback) {\n    callback = onlyOnce(callback || noop);\n    var size, key, value, keys, iter, item, array, criteria, iterate;\n    var sync = false;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      array = collection;\n      criteria = Array(size);\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      array = [];\n      criteria = [];\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      array = Array(size);\n      criteria = Array(size);\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size) {\n      return callback(null, []);\n    }\n    iterate();\n\n    function arrayIterator() {\n      value = collection[completed];\n      iterator(value, done);\n    }\n\n    function arrayIteratorWithIndex() {\n      value = collection[completed];\n      iterator(value, completed, done);\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      if (item.done) {\n        return callback(null, sortByCriteria(array, criteria));\n      }\n      value = item.value;\n      array[completed] = value;\n      iterator(value, done);\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      if (item.done) {\n        return callback(null, sortByCriteria(array, criteria));\n      }\n      value = item.value;\n      array[completed] = value;\n      iterator(value, completed, done);\n    }\n\n    function objectIterator() {\n      value = collection[keys[completed]];\n      array[completed] = value;\n      iterator(value, done);\n    }\n\n    function objectIteratorWithKey() {\n      key = keys[completed];\n      value = collection[key];\n      array[completed] = value;\n      iterator(value, key, done);\n    }\n\n    function done(err, criterion) {\n      criteria[completed] = criterion;\n      if (err) {\n        callback(err);\n      } else if (++completed === size) {\n        iterate = throwError;\n        callback(null, sortByCriteria(array, criteria));\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace sortByLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortByLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4, 5]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortByLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4, 5]\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortByLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4, 5]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.sortByLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4, 5]\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  function sortByLimit(collection, limit, iterator, callback) {\n    callback = callback || noop;\n    var size, index, key, value, array, keys, iter, item, criteria, iterate;\n    var sync = false;\n    var started = 0;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      array = collection;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      array = [];\n      criteria = [];\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      array = Array(size);\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size || isNaN(limit) || limit < 1) {\n      return callback(null, []);\n    }\n    criteria = criteria || Array(size);\n    timesSync(limit > size ? size : limit, iterate);\n\n    function arrayIterator() {\n      if (started < size) {\n        value = collection[started];\n        iterator(value, createCallback(value, started++));\n      }\n    }\n\n    function arrayIteratorWithIndex() {\n      index = started++;\n      if (index < size) {\n        value = collection[index];\n        iterator(value, index, createCallback(value, index));\n      }\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      if (item.done === false) {\n        value = item.value;\n        array[started] = value;\n        iterator(value, createCallback(value, started++));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, sortByCriteria(array, criteria));\n      }\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      if (item.done === false) {\n        value = item.value;\n        array[started] = value;\n        iterator(value, started, createCallback(value, started++));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, sortByCriteria(array, criteria));\n      }\n    }\n\n    function objectIterator() {\n      if (started < size) {\n        value = collection[keys[started]];\n        array[started] = value;\n        iterator(value, createCallback(value, started++));\n      }\n    }\n\n    function objectIteratorWithKey() {\n      if (started < size) {\n        key = keys[started];\n        value = collection[key];\n        array[started] = value;\n        iterator(value, key, createCallback(value, started++));\n      }\n    }\n\n    function createCallback(value, index) {\n      var called = false;\n      return function(err, criterion) {\n        if (called) {\n          throwError();\n        }\n        called = true;\n        criteria[index] = criterion;\n        if (err) {\n          iterate = noop;\n          callback(err);\n          callback = noop;\n        } else if (++completed === size) {\n          callback(null, sortByCriteria(array, criteria));\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      };\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace some\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.some(array, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.some(array, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [[1, 0]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.some(object, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.some(object, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [[1, 'a']]\n   * });\n   *\n   */\n  function some(collection, iterator, callback) {\n    callback = callback || noop;\n    detect(collection, iterator, done);\n\n    function done(err, res) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, !!res);\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace someSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.someSeries(array, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.someSeries(array, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [[1, 0]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.someSeries(object, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.someSeries(object, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [[1, 'a']]\n   * });\n   *\n   */\n  function someSeries(collection, iterator, callback) {\n    callback = callback || noop;\n    detectSeries(collection, iterator, done);\n\n    function done(err, res) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, !!res);\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace someLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.someLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.someLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [[1, 0]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.someLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [1]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num % 2);\n   *   }, num * 10);\n   * };\n   * async.someLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // true\n   *   console.log(order); // [[1, 'a']]\n   * });\n   *\n   */\n  function someLimit(collection, limit, iterator, callback) {\n    callback = callback || noop;\n    detectLimit(collection, limit, iterator, done);\n\n    function done(err, res) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, !!res);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   * @param {Function} symbolEach\n   */\n  function createEvery(arrayEach, baseEach, symbolEach) {\n    var deny = createDetect(arrayEach, baseEach, symbolEach, false);\n\n    return function every(collection, iterator, callback) {\n      callback = callback || noop;\n      deny(collection, iterator, done);\n\n      function done(err, res) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, !res);\n      }\n    };\n  }\n\n  /**\n   * @private\n   */\n  function createEverySeries() {\n    var denySeries = createDetectSeries(false);\n\n    return function everySeries(collection, iterator, callback) {\n      callback = callback || noop;\n      denySeries(collection, iterator, done);\n\n      function done(err, res) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, !res);\n      }\n    };\n  }\n\n  /**\n   * @private\n   */\n  function createEveryLimit() {\n    var denyLimit = createDetectLimit(false);\n\n    return function everyLimit(collection, limit, iterator, callback) {\n      callback = callback || noop;\n      denyLimit(collection, limit, iterator, done);\n\n      function done(err, res) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, !res);\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   * @param {Function} symbolEach\n   */\n  function createConcat(arrayEach, baseEach, symbolEach) {\n    return function concat(collection, iterator, callback) {\n      callback = callback || noop;\n      var size, result;\n      var completed = 0;\n\n      if (isArray(collection)) {\n        size = collection.length;\n        result = Array(size);\n        arrayEach(collection, iterator, createCallback);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        result = [];\n        size = symbolEach(collection, iterator, createCallback);\n        size && size === completed && callback(null, result);\n      } else if (typeof collection === obj) {\n        var keys = nativeKeys(collection);\n        size = keys.length;\n        result = Array(size);\n        baseEach(collection, iterator, createCallback, keys);\n      }\n      if (!size) {\n        callback(null, []);\n      }\n\n      function createCallback(index) {\n        return function done(err, res) {\n          if (index === null) {\n            throwError();\n          }\n          if (err) {\n            index = null;\n            callback = once(callback);\n            arrayEachSync(result, function(array, index) {\n              if (array === undefined) {\n                result[index] = noop;\n              }\n            });\n            callback(err, makeConcatResult(result));\n            return;\n          }\n          switch (arguments.length) {\n            case 0:\n            case 1:\n              result[index] = noop;\n              break;\n            case 2:\n              result[index] = res;\n              break;\n            default:\n              result[index] = slice(arguments, 1);\n              break;\n          }\n          index = null;\n          if (++completed === size) {\n            callback(null, makeConcatResult(result));\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace concatSeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concatSeries(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2];\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 3, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concatSeries(array, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [[1, 0], [3, 1], [2, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concatSeries(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [1, 3, 2]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 3, c: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concatSeries(object, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 2]\n   *   console.log(order); // [[1, 'a'], [3, 'b'], [2, 'c']]\n   * });\n   *\n   */\n  function concatSeries(collection, iterator, callback) {\n    callback = onlyOnce(callback || noop);\n    var size, key, keys, iter, item, iterate;\n    var sync = false;\n    var result = [];\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size) {\n      return callback(null, result);\n    }\n    iterate();\n\n    function arrayIterator() {\n      iterator(collection[completed], done);\n    }\n\n    function arrayIteratorWithIndex() {\n      iterator(collection[completed], completed, done);\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(item.value, done);\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      item.done ? callback(null, result) : iterator(item.value, completed, done);\n    }\n\n    function objectIterator() {\n      iterator(collection[keys[completed]], done);\n    }\n\n    function objectIteratorWithKey() {\n      key = keys[completed];\n      iterator(collection[key], key, done);\n    }\n\n    function done(err, array) {\n      if (isArray(array)) {\n        nativePush.apply(result, array);\n      } else if (arguments.length >= 2) {\n        nativePush.apply(result, slice(arguments, 1));\n      }\n      if (err) {\n        callback(err, result);\n      } else if (++completed === size) {\n        iterate = throwError;\n        callback(null, result);\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace concatLimit\n   * @param {Array|Object} collection\n   * @param {number} limit - limit >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concatLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 5, 2, 4]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1, 5, 3, 4, 2];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.cocnatLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 5, 2, 4]\n   *   console.log(order); // [[1, 0], [3, 2], [5, 1], [2, 4], [4, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, [num]);\n   *   }, num * 10);\n   * };\n   * async.concatLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 5, 2, 4]\n   *   console.log(order); // [1, 3, 5, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1, b: 5, c: 3, d: 4, e: 2 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, num);\n   *   }, num * 10);\n   * };\n   * async.cocnatLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // [1, 3, 5, 2, 4]\n   *   console.log(order); // [[1, 'a'], [3, 'c'], [5, 'b'], [2, 'e'], [4, 'd']]\n   * });\n   *\n   */\n  function concatLimit(collection, limit, iterator, callback) {\n    callback = callback || noop;\n    var size, key, iter, item, iterate, result;\n    var sync = false;\n    var started = 0;\n    var completed = 0;\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      result = [];\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      var keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size || isNaN(limit) || limit < 1) {\n      return callback(null, []);\n    }\n    result = result || Array(size);\n    timesSync(limit > size ? size : limit, iterate);\n\n    function arrayIterator() {\n      if (started < size) {\n        iterator(collection[started], createCallback(started++));\n      }\n    }\n\n    function arrayIteratorWithIndex() {\n      if (started < size) {\n        iterator(collection[started], started, createCallback(started++));\n      }\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      if (item.done === false) {\n        iterator(item.value, createCallback(started++));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, makeConcatResult(result));\n      }\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      if (item.done === false) {\n        iterator(item.value, started, createCallback(started++));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, makeConcatResult(result));\n      }\n    }\n\n    function objectIterator() {\n      if (started < size) {\n        iterator(collection[keys[started]], createCallback(started++));\n      }\n    }\n\n    function objectIteratorWithKey() {\n      if (started < size) {\n        key = keys[started];\n        iterator(collection[key], key, createCallback(started++));\n      }\n    }\n\n    function createCallback(index) {\n      return function(err, res) {\n        if (index === null) {\n          throwError();\n        }\n        if (err) {\n          index = null;\n          iterate = noop;\n          callback = once(callback);\n          arrayEachSync(result, function(array, index) {\n            if (array === undefined) {\n              result[index] = noop;\n            }\n          });\n          callback(err, makeConcatResult(result));\n          return;\n        }\n        switch (arguments.length) {\n          case 0:\n          case 1:\n            result[index] = noop;\n            break;\n          case 2:\n            result[index] = res;\n            break;\n          default:\n            result[index] = slice(arguments, 1);\n            break;\n        }\n        index = null;\n        if (++completed === size) {\n          iterate = throwError;\n          callback(null, makeConcatResult(result));\n          callback = throwError;\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      };\n    }\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   * @param {Function} symbolEach\n   */\n  function createGroupBy(arrayEach, baseEach, symbolEach) {\n    return function groupBy(collection, iterator, callback) {\n      callback = callback || noop;\n      var size;\n      var completed = 0;\n      var result = {};\n\n      if (isArray(collection)) {\n        size = collection.length;\n        arrayEach(collection, iterator, createCallback);\n      } else if (!collection) {\n      } else if (iteratorSymbol && collection[iteratorSymbol]) {\n        size = symbolEach(collection, iterator, createCallback);\n        size && size === completed && callback(null, result);\n      } else if (typeof collection === obj) {\n        var keys = nativeKeys(collection);\n        size = keys.length;\n        baseEach(collection, iterator, createCallback, keys);\n      }\n      if (!size) {\n        callback(null, {});\n      }\n\n      function createCallback(value) {\n        var called = false;\n        return function done(err, key) {\n          if (called) {\n            throwError();\n          }\n          called = true;\n          if (err) {\n            callback = once(callback);\n            callback(err, objectClone(result));\n            return;\n          }\n          var array = result[key];\n          if (!array) {\n            result[key] = [value];\n          } else {\n            array.push(value);\n          }\n          if (++completed === size) {\n            callback(null, result);\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace groupBySeries\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [4.2, 6.4, 6.1];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupBySeries(array, iterator, function(err, res) {\n   *   console.log(res); // { '4': [4.2], '6': [6.4, 6.1] }\n   *   console.log(order); // [4.2, 6.4, 6.1]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [4.2, 6.4, 6.1];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupBySeries(array, iterator, function(err, res) {\n   *   console.log(res); // { '4': [4.2], '6': [6.4, 6.1] }\n   *   console.log(order); // [[4.2, 0], [6.4, 1], [6.1, 2]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 4.2, b: 6.4, c: 6.1 };\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupBySeries(object, iterator, function(err, res) {\n   *   console.log(res); // { '4': [4.2], '6': [6.4, 6.1] }\n   *   console.log(order); // [4.2, 6.4, 6.1]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 4.2, b: 6.4, c: 6.1 };\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupBySeries(object, iterator, function(err, res) {\n   *   console.log(res); // { '4': [4.2], '6': [6.4, 6.1] }\n   *   console.log(order); // [[4.2, 'a'], [6.4, 'b'], [6.1, 'c']]\n   * });\n   *\n   */\n  function groupBySeries(collection, iterator, callback) {\n    callback = onlyOnce(callback || noop);\n    var size, key, value, keys, iter, item, iterate;\n    var sync = false;\n    var completed = 0;\n    var result = {};\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size) {\n      return callback(null, result);\n    }\n    iterate();\n\n    function arrayIterator() {\n      value = collection[completed];\n      iterator(value, done);\n    }\n\n    function arrayIteratorWithIndex() {\n      value = collection[completed];\n      iterator(value, completed, done);\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      value = item.value;\n      item.done ? callback(null, result) : iterator(value, done);\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      value = item.value;\n      item.done ? callback(null, result) : iterator(value, completed, done);\n    }\n\n    function objectIterator() {\n      value = collection[keys[completed]];\n      iterator(value, done);\n    }\n\n    function objectIteratorWithKey() {\n      key = keys[completed];\n      value = collection[key];\n      iterator(value, key, done);\n    }\n\n    function done(err, key) {\n      if (err) {\n        iterate = throwError;\n        callback = onlyOnce(callback);\n        callback(err, objectClone(result));\n        return;\n      }\n      var array = result[key];\n      if (!array) {\n        result[key] = [value];\n      } else {\n        array.push(value);\n      }\n      if (++completed === size) {\n        iterate = throwError;\n        callback(null, result);\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace groupByLimit\n   * @param {Array|Object} collection\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var order = [];\n   * var array = [1.1, 5.9, 3.2, 3.9, 2.1];\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupByLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // { '1': [1.1], '3': [3.2, 3.9], '5': [5.9], '2': [2.1] }\n   *   console.log(order); // [1.1, 3.2, 5.9, 2.1, 3.9]\n   * });\n   *\n   * @example\n   *\n   * // array with index\n   * var order = [];\n   * var array = [1.1, 5.9, 3.2, 3.9, 2.1];\n   * var iterator = function(num, index, done) {\n   *   setTimeout(function() {\n   *     order.push([num, index]);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupByLimit(array, 2, iterator, function(err, res) {\n   *   console.log(res); // { '1': [1.1], '3': [3.2, 3.9], '5': [5.9], '2': [2.1] }\n   *   console.log(order); // [[1.1, 0], [3.2, 2], [5.9, 1], [2.1, 4], [3.9, 3]]\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var order = [];\n   * var object = { a: 1.1, b: 5.9, c: 3.2, d: 3.9, e: 2.1 }\n   * var iterator = function(num, done) {\n   *   setTimeout(function() {\n   *     order.push(num);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupByLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { '1': [1.1], '3': [3.2, 3.9], '5': [5.9], '2': [2.1] }\n   *   console.log(order); // [1.1, 3.2, 5.9, 2.1, 3.9]\n   * });\n   *\n   * @example\n   *\n   * // object with key\n   * var order = [];\n   * var object = { a: 1.1, b: 5.9, c: 3.2, d: 3.9, e: 2.1 }\n   * var iterator = function(num, key, done) {\n   *   setTimeout(function() {\n   *     order.push([num, key]);\n   *     done(null, Math.floor(num));\n   *   }, num * 10);\n   * };\n   * async.groupByLimit(object, 2, iterator, function(err, res) {\n   *   console.log(res); // { '1': [1.1], '3': [3.2, 3.9], '5': [5.9], '2': [2.1] }\n   *   console.log(order); // [[1.1, 'a'], [3.2, 'c'], [5.9, 'b'], [2.1, 'e'], [3.9, 'd']]\n   * });\n   *\n   */\n  function groupByLimit(collection, limit, iterator, callback) {\n    callback = callback || noop;\n    var size, index, key, value, keys, iter, item, iterate;\n    var sync = false;\n    var started = 0;\n    var completed = 0;\n    var result = {};\n\n    if (isArray(collection)) {\n      size = collection.length;\n      iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;\n    } else if (!collection) {\n    } else if (iteratorSymbol && collection[iteratorSymbol]) {\n      size = Infinity;\n      iter = collection[iteratorSymbol]();\n      iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;\n    } else if (typeof collection === obj) {\n      keys = nativeKeys(collection);\n      size = keys.length;\n      iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;\n    }\n    if (!size || isNaN(limit) || limit < 1) {\n      return callback(null, result);\n    }\n    timesSync(limit > size ? size : limit, iterate);\n\n    function arrayIterator() {\n      if (started < size) {\n        value = collection[started++];\n        iterator(value, createCallback(value));\n      }\n    }\n\n    function arrayIteratorWithIndex() {\n      index = started++;\n      if (index < size) {\n        value = collection[index];\n        iterator(value, index, createCallback(value));\n      }\n    }\n\n    function symbolIterator() {\n      item = iter.next();\n      if (item.done === false) {\n        started++;\n        value = item.value;\n        iterator(value, createCallback(value));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, result);\n      }\n    }\n\n    function symbolIteratorWithKey() {\n      item = iter.next();\n      if (item.done === false) {\n        value = item.value;\n        iterator(value, started++, createCallback(value));\n      } else if (completed === started && iterator !== noop) {\n        iterator = noop;\n        callback(null, result);\n      }\n    }\n\n    function objectIterator() {\n      if (started < size) {\n        value = collection[keys[started++]];\n        iterator(value, createCallback(value));\n      }\n    }\n\n    function objectIteratorWithKey() {\n      if (started < size) {\n        key = keys[started++];\n        value = collection[key];\n        iterator(value, key, createCallback(value));\n      }\n    }\n\n    function createCallback(value) {\n      var called = false;\n      return function(err, key) {\n        if (called) {\n          throwError();\n        }\n        called = true;\n        if (err) {\n          iterate = noop;\n          callback = once(callback);\n          callback(err, objectClone(result));\n          return;\n        }\n        var array = result[key];\n        if (!array) {\n          result[key] = [value];\n        } else {\n          array.push(value);\n        }\n        if (++completed === size) {\n          callback(null, result);\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      };\n    }\n  }\n\n  /**\n   * @private\n   * @param {Function} arrayEach\n   * @param {Function} baseEach\n   */\n  function createParallel(arrayEach, baseEach) {\n    return function parallel(tasks, callback) {\n      callback = callback || noop;\n      var size, keys, result;\n      var completed = 0;\n\n      if (isArray(tasks)) {\n        size = tasks.length;\n        result = Array(size);\n        arrayEach(tasks, createCallback);\n      } else if (tasks && typeof tasks === obj) {\n        keys = nativeKeys(tasks);\n        size = keys.length;\n        result = {};\n        baseEach(tasks, createCallback, keys);\n      }\n      if (!size) {\n        callback(null, result);\n      }\n\n      function createCallback(key) {\n        return function(err, res) {\n          if (key === null) {\n            throwError();\n          }\n          if (err) {\n            key = null;\n            callback = once(callback);\n            callback(err, result);\n            return;\n          }\n          result[key] = arguments.length <= 2 ? res : slice(arguments, 1);\n          key = null;\n          if (++completed === size) {\n            callback(null, result);\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace series\n   * @param {Array|Object} tasks - functions\n   * @param {Function} callback\n   * @example\n   *\n   * var order = [];\n   * var tasks = [\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(1);\n   *      done(null, 1);\n   *    }, 10);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(2);\n   *      done(null, 2);\n   *    }, 30);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(3);\n   *      done(null, 3);\n   *    }, 40);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(4);\n   *      done(null, 4);\n   *    }, 20);\n   *  }\n   * ];\n   * async.series(tasks, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4];\n   *   console.log(order); // [1, 2, 3, 4]\n   * });\n   *\n   * @example\n   *\n   * var order = [];\n   * var tasks = {\n   *   'a': function(done) {\n   *     setTimeout(function() {\n   *       order.push(1);\n   *       done(null, 1);\n   *     }, 10);\n   *   },\n   *   'b': function(done) {\n   *     setTimeout(function() {\n   *       order.push(2);\n   *       done(null, 2);\n   *     }, 30);\n   *   },\n   *   'c': function(done) {\n   *     setTimeout(function() {\n   *       order.push(3);\n   *       done(null, 3);\n   *     }, 40);\n   *   },\n   *   'd': function(done) {\n   *     setTimeout(function() {\n   *       order.push(4);\n   *       done(null, 4);\n   *     }, 20);\n   *   }\n   * };\n   * async.series(tasks, function(err, res) {\n   *   console.log(res); // { a: 1, b: 2, c: 3, d:4 }\n   *   console.log(order); // [1, 4, 2, 3]\n   * });\n   *\n   */\n  function series(tasks, callback) {\n    callback = callback || noop;\n    var size, key, keys, result, iterate;\n    var sync = false;\n    var completed = 0;\n\n    if (isArray(tasks)) {\n      size = tasks.length;\n      result = Array(size);\n      iterate = arrayIterator;\n    } else if (tasks && typeof tasks === obj) {\n      keys = nativeKeys(tasks);\n      size = keys.length;\n      result = {};\n      iterate = objectIterator;\n    } else {\n      return callback(null);\n    }\n    if (!size) {\n      return callback(null, result);\n    }\n    iterate();\n\n    function arrayIterator() {\n      key = completed;\n      tasks[completed](done);\n    }\n\n    function objectIterator() {\n      key = keys[completed];\n      tasks[key](done);\n    }\n\n    function done(err, res) {\n      if (err) {\n        iterate = throwError;\n        callback = onlyOnce(callback);\n        callback(err, result);\n        return;\n      }\n      result[key] = arguments.length <= 2 ? res : slice(arguments, 1);\n      if (++completed === size) {\n        iterate = throwError;\n        callback(null, result);\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace parallelLimit\n   * @param {Array|Object} tasks - functions\n   * @param {number} limit - limit >= 1\n   * @param {Function} callback\n   * @example\n   *\n   * var order = [];\n   * var tasks = [\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(1);\n   *      done(null, 1);\n   *    }, 10);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(2);\n   *      done(null, 2);\n   *    }, 50);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(3);\n   *      done(null, 3);\n   *    }, 30);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      order.push(4);\n   *      done(null, 4);\n   *    }, 40);\n   *  }\n   * ];\n   * async.parallelLimit(tasks, 2, function(err, res) {\n   *   console.log(res); // [1, 2, 3, 4];\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   * @example\n   *\n   * var order = [];\n   * var tasks = {\n   *   'a': function(done) {\n   *     setTimeout(function() {\n   *       order.push(1);\n   *       done(null, 1);\n   *     }, 10);\n   *   },\n   *   'b': function(done) {\n   *     setTimeout(function() {\n   *       order.push(2);\n   *       done(null, 2);\n   *     }, 50);\n   *   },\n   *   'c': function(done) {\n   *     setTimeout(function() {\n   *       order.push(3);\n   *       done(null, 3);\n   *     }, 20);\n   *   },\n   *   'd': function(done) {\n   *     setTimeout(function() {\n   *       order.push(4);\n   *       done(null, 4);\n   *     }, 40);\n   *   }\n   * };\n   * async.parallelLimit(tasks, 2, function(err, res) {\n   *   console.log(res); // { a: 1, b: 2, c: 3, d:4 }\n   *   console.log(order); // [1, 3, 2, 4]\n   * });\n   *\n   */\n  function parallelLimit(tasks, limit, callback) {\n    callback = callback || noop;\n    var size, index, key, keys, result, iterate;\n    var sync = false;\n    var started = 0;\n    var completed = 0;\n\n    if (isArray(tasks)) {\n      size = tasks.length;\n      result = Array(size);\n      iterate = arrayIterator;\n    } else if (tasks && typeof tasks === obj) {\n      keys = nativeKeys(tasks);\n      size = keys.length;\n      result = {};\n      iterate = objectIterator;\n    }\n    if (!size || isNaN(limit) || limit < 1) {\n      return callback(null, result);\n    }\n    timesSync(limit > size ? size : limit, iterate);\n\n    function arrayIterator() {\n      index = started++;\n      if (index < size) {\n        tasks[index](createCallback(index));\n      }\n    }\n\n    function objectIterator() {\n      if (started < size) {\n        key = keys[started++];\n        tasks[key](createCallback(key));\n      }\n    }\n\n    function createCallback(key) {\n      return function(err, res) {\n        if (key === null) {\n          throwError();\n        }\n        if (err) {\n          key = null;\n          iterate = noop;\n          callback = once(callback);\n          callback(err, result);\n          return;\n        }\n        result[key] = arguments.length <= 2 ? res : slice(arguments, 1);\n        key = null;\n        if (++completed === size) {\n          callback(null, result);\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      };\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace tryEach\n   * @param {Array|Object} tasks - functions\n   * @param {Function} callback\n   * @example\n   *\n   * var tasks = [\n   *  function(done) {\n   *    setTimeout(function() {\n   *      done(new Error('error'));\n   *    }, 10);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      done(null, 2);\n   *    }, 10);\n   *  }\n   * ];\n   * async.tryEach(tasks, function(err, res) {\n   *   console.log(res); // 2\n   * });\n   *\n   * @example\n   *\n   * var tasks = [\n   *  function(done) {\n   *    setTimeout(function() {\n   *      done(new Error('error1'));\n   *    }, 10);\n   *  },\n   *  function(done) {\n   *    setTimeout(function() {\n   *      done(new Error('error2');\n   *    }, 10);\n   *  }\n   * ];\n   * async.tryEach(tasks, function(err, res) {\n   *   console.log(err); // error2\n   *   console.log(res); // undefined\n   * });\n   *\n   */\n  function tryEach(tasks, callback) {\n    callback = callback || noop;\n    var size, keys, iterate;\n    var sync = false;\n    var completed = 0;\n\n    if (isArray(tasks)) {\n      size = tasks.length;\n      iterate = arrayIterator;\n    } else if (tasks && typeof tasks === obj) {\n      keys = nativeKeys(tasks);\n      size = keys.length;\n      iterate = objectIterator;\n    }\n    if (!size) {\n      return callback(null);\n    }\n    iterate();\n\n    function arrayIterator() {\n      tasks[completed](done);\n    }\n\n    function objectIterator() {\n      tasks[keys[completed]](done);\n    }\n\n    function done(err, res) {\n      if (!err) {\n        if (arguments.length <= 2) {\n          callback(null, res);\n        } else {\n          callback(null, slice(arguments, 1));\n        }\n      } else if (++completed === size) {\n        callback(err);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * check for waterfall tasks\n   * @private\n   * @param {Array} tasks\n   * @param {Function} callback\n   * @return {boolean}\n   */\n  function checkWaterfallTasks(tasks, callback) {\n    if (!isArray(tasks)) {\n      callback(new Error('First argument to waterfall must be an array of functions'));\n      return false;\n    }\n    if (tasks.length === 0) {\n      callback(null);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * check for waterfall tasks\n   * @private\n   * @param {function} func\n   * @param {Array|Object} args - arguments\n   * @return {function} next\n   */\n  function waterfallIterator(func, args, next) {\n    switch (args.length) {\n      case 0:\n      case 1:\n        return func(next);\n      case 2:\n        return func(args[1], next);\n      case 3:\n        return func(args[1], args[2], next);\n      case 4:\n        return func(args[1], args[2], args[3], next);\n      case 5:\n        return func(args[1], args[2], args[3], args[4], next);\n      case 6:\n        return func(args[1], args[2], args[3], args[4], args[5], next);\n      default:\n        args = slice(args, 1);\n        args.push(next);\n        return func.apply(null, args);\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace waterfall\n   * @param {Array} tasks - functions\n   * @param {Function} callback\n   * @example\n   *\n   * var order = [];\n   * var tasks = [\n   *   function(next) {\n   *     setTimeout(function() {\n   *       order.push(1);\n   *       next(null, 1);\n   *     }, 10);\n   *   },\n   *   function(arg1, next) {\n   *     setTimeout(function() {\n   *       order.push(2);\n   *       next(null, 1, 2);\n   *     }, 30);\n   *   },\n   *   function(arg1, arg2, next) {\n   *     setTimeout(function() {\n   *       order.push(3);\n   *       next(null, 3);\n   *     }, 20);\n   *   },\n   *   function(arg1, next) {\n   *     setTimeout(function() {\n   *       order.push(4);\n   *       next(null, 1, 2, 3, 4);\n   *     }, 40);\n   *   }\n   * ];\n   * async.waterfall(tasks, function(err, arg1, arg2, arg3, arg4) {\n   *   console.log(arg1, arg2, arg3, arg4); // 1 2 3 4\n   * });\n   *\n   */\n  function waterfall(tasks, callback) {\n    callback = callback || noop;\n    if (!checkWaterfallTasks(tasks, callback)) {\n      return;\n    }\n    var func, args, done, sync;\n    var completed = 0;\n    var size = tasks.length;\n    waterfallIterator(tasks[0], [], createCallback(0));\n\n    function iterate() {\n      waterfallIterator(func, args, createCallback(func));\n    }\n\n    function createCallback(index) {\n      return function next(err, res) {\n        if (index === undefined) {\n          callback = noop;\n          throwError();\n        }\n        index = undefined;\n        if (err) {\n          done = callback;\n          callback = throwError;\n          done(err);\n          return;\n        }\n        if (++completed === size) {\n          done = callback;\n          callback = throwError;\n          if (arguments.length <= 2) {\n            done(err, res);\n          } else {\n            done.apply(null, createArray(arguments));\n          }\n          return;\n        }\n        if (sync) {\n          args = arguments;\n          func = tasks[completed] || throwError;\n          nextTick(iterate);\n        } else {\n          sync = true;\n          waterfallIterator(tasks[completed] || throwError, arguments, createCallback(completed));\n        }\n        sync = false;\n      };\n    }\n  }\n\n  /**\n   * `angelFall` is like `waterfall` and inject callback to last argument of next task.\n   *\n   * @memberof async\n   * @namespace angelFall\n   * @param {Array} tasks - functions\n   * @param {Function} callback\n   * @example\n   *\n   * var order = [];\n   * var tasks = [\n   *   function(next) {\n   *     setTimeout(function() {\n   *       order.push(1);\n   *       next(null, 1);\n   *     }, 10);\n   *   },\n   *   function(arg1, empty, next) {\n   *     setTimeout(function() {\n   *       order.push(2);\n   *       next(null, 1, 2);\n   *     }, 30);\n   *   },\n   *   function(next) {\n   *     setTimeout(function() {\n   *       order.push(3);\n   *       next(null, 3);\n   *     }, 20);\n   *   },\n   *   function(arg1, empty1, empty2, empty3, next) {\n   *     setTimeout(function() {\n   *       order.push(4);\n   *       next(null, 1, 2, 3, 4);\n   *     }, 40);\n   *   }\n   * ];\n   * async.angelFall(tasks, function(err, arg1, arg2, arg3, arg4) {\n   *   console.log(arg1, arg2, arg3, arg4); // 1 2 3 4\n   * });\n   *\n   */\n  function angelFall(tasks, callback) {\n    callback = callback || noop;\n    if (!checkWaterfallTasks(tasks, callback)) {\n      return;\n    }\n    var completed = 0;\n    var sync = false;\n    var size = tasks.length;\n    var func = tasks[completed];\n    var args = [];\n    var iterate = function() {\n      switch (func.length) {\n        case 0:\n          try {\n            next(null, func());\n          } catch (e) {\n            next(e);\n          }\n          return;\n        case 1:\n          return func(next);\n        case 2:\n          return func(args[1], next);\n        case 3:\n          return func(args[1], args[2], next);\n        case 4:\n          return func(args[1], args[2], args[3], next);\n        case 5:\n          return func(args[1], args[2], args[3], args[4], next);\n        default:\n          args = slice(args, 1);\n          args[func.length - 1] = next;\n          return func.apply(null, args);\n      }\n    };\n    iterate();\n\n    function next(err, res) {\n      if (err) {\n        iterate = throwError;\n        callback = onlyOnce(callback);\n        callback(err);\n        return;\n      }\n      if (++completed === size) {\n        iterate = throwError;\n        var done = callback;\n        callback = throwError;\n        if (arguments.length === 2) {\n          done(err, res);\n        } else {\n          done.apply(null, createArray(arguments));\n        }\n        return;\n      }\n      func = tasks[completed];\n      args = arguments;\n      if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace whilst\n   * @param {Function} test\n   * @param {Function} iterator\n   * @param {Function} callback\n   */\n  function whilst(test, iterator, callback) {\n    callback = callback || noop;\n    var sync = false;\n    if (test()) {\n      iterate();\n    } else {\n      callback(null);\n    }\n\n    function iterate() {\n      if (sync) {\n        nextTick(next);\n      } else {\n        sync = true;\n        iterator(done);\n      }\n      sync = false;\n    }\n\n    function next() {\n      iterator(done);\n    }\n\n    function done(err, arg) {\n      if (err) {\n        return callback(err);\n      }\n      if (arguments.length <= 2) {\n        if (test(arg)) {\n          iterate();\n        } else {\n          callback(null, arg);\n        }\n        return;\n      }\n      arg = slice(arguments, 1);\n      if (test.apply(null, arg)) {\n        iterate();\n      } else {\n        callback.apply(null, [null].concat(arg));\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace doWhilst\n   * @param {Function} iterator\n   * @param {Function} test\n   * @param {Function} callback\n   */\n  function doWhilst(iterator, test, callback) {\n    callback = callback || noop;\n    var sync = false;\n    next();\n\n    function iterate() {\n      if (sync) {\n        nextTick(next);\n      } else {\n        sync = true;\n        iterator(done);\n      }\n      sync = false;\n    }\n\n    function next() {\n      iterator(done);\n    }\n\n    function done(err, arg) {\n      if (err) {\n        return callback(err);\n      }\n      if (arguments.length <= 2) {\n        if (test(arg)) {\n          iterate();\n        } else {\n          callback(null, arg);\n        }\n        return;\n      }\n      arg = slice(arguments, 1);\n      if (test.apply(null, arg)) {\n        iterate();\n      } else {\n        callback.apply(null, [null].concat(arg));\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace until\n   * @param {Function} test\n   * @param {Function} iterator\n   * @param {Function} callback\n   */\n  function until(test, iterator, callback) {\n    callback = callback || noop;\n    var sync = false;\n    if (!test()) {\n      iterate();\n    } else {\n      callback(null);\n    }\n\n    function iterate() {\n      if (sync) {\n        nextTick(next);\n      } else {\n        sync = true;\n        iterator(done);\n      }\n      sync = false;\n    }\n\n    function next() {\n      iterator(done);\n    }\n\n    function done(err, arg) {\n      if (err) {\n        return callback(err);\n      }\n      if (arguments.length <= 2) {\n        if (!test(arg)) {\n          iterate();\n        } else {\n          callback(null, arg);\n        }\n        return;\n      }\n      arg = slice(arguments, 1);\n      if (!test.apply(null, arg)) {\n        iterate();\n      } else {\n        callback.apply(null, [null].concat(arg));\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace doUntil\n   * @param {Function} iterator\n   * @param {Function} test\n   * @param {Function} callback\n   */\n  function doUntil(iterator, test, callback) {\n    callback = callback || noop;\n    var sync = false;\n    next();\n\n    function iterate() {\n      if (sync) {\n        nextTick(next);\n      } else {\n        sync = true;\n        iterator(done);\n      }\n      sync = false;\n    }\n\n    function next() {\n      iterator(done);\n    }\n\n    function done(err, arg) {\n      if (err) {\n        return callback(err);\n      }\n      if (arguments.length <= 2) {\n        if (!test(arg)) {\n          iterate();\n        } else {\n          callback(null, arg);\n        }\n        return;\n      }\n      arg = slice(arguments, 1);\n      if (!test.apply(null, arg)) {\n        iterate();\n      } else {\n        callback.apply(null, [null].concat(arg));\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace during\n   * @param {Function} test\n   * @param {Function} iterator\n   * @param {Function} callback\n   */\n  function during(test, iterator, callback) {\n    callback = callback || noop;\n    _test();\n\n    function _test() {\n      test(iterate);\n    }\n\n    function iterate(err, truth) {\n      if (err) {\n        return callback(err);\n      }\n      if (truth) {\n        iterator(done);\n      } else {\n        callback(null);\n      }\n    }\n\n    function done(err) {\n      if (err) {\n        return callback(err);\n      }\n      _test();\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace doDuring\n   * @param {Function} test\n   * @param {Function} iterator\n   * @param {Function} callback\n   */\n  function doDuring(iterator, test, callback) {\n    callback = callback || noop;\n    iterate(null, true);\n\n    function iterate(err, truth) {\n      if (err) {\n        return callback(err);\n      }\n      if (truth) {\n        iterator(done);\n      } else {\n        callback(null);\n      }\n    }\n\n    function done(err, res) {\n      if (err) {\n        return callback(err);\n      }\n      switch (arguments.length) {\n        case 0:\n        case 1:\n          test(iterate);\n          break;\n        case 2:\n          test(res, iterate);\n          break;\n        default:\n          var args = slice(arguments, 1);\n          args.push(iterate);\n          test.apply(null, args);\n          break;\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace forever\n   */\n  function forever(iterator, callback) {\n    var sync = false;\n    iterate();\n\n    function iterate() {\n      iterator(next);\n    }\n\n    function next(err) {\n      if (err) {\n        if (callback) {\n          return callback(err);\n        }\n        throw err;\n      }\n      if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace compose\n   */\n  function compose() {\n    return seq.apply(null, reverse(arguments));\n  }\n\n  /**\n   * @memberof async\n   * @namespace seq\n   */\n  function seq(/* functions... */) {\n    var fns = createArray(arguments);\n\n    return function() {\n      var self = this;\n      var args = createArray(arguments);\n      var callback = args[args.length - 1];\n      if (typeof callback === func) {\n        args.pop();\n      } else {\n        callback = noop;\n      }\n      reduce(fns, args, iterator, done);\n\n      function iterator(newargs, fn, callback) {\n        var func = function(err) {\n          var nextargs = slice(arguments, 1);\n          callback(err, nextargs);\n        };\n        newargs.push(func);\n        fn.apply(self, newargs);\n      }\n\n      function done(err, res) {\n        res = isArray(res) ? res : [res];\n        res.unshift(err);\n        callback.apply(self, res);\n      }\n    };\n  }\n\n  function createApplyEach(func) {\n    return function applyEach(fns /* arguments */) {\n      var go = function() {\n        var self = this;\n        var args = createArray(arguments);\n        var callback = args.pop() || noop;\n        return func(fns, iterator, callback);\n\n        function iterator(fn, done) {\n          fn.apply(self, args.concat([done]));\n        }\n      };\n      if (arguments.length > 1) {\n        var args = slice(arguments, 1);\n        return go.apply(this, args);\n      } else {\n        return go;\n      }\n    };\n  }\n\n  /**\n   * @see https://github.com/caolan/async/blob/master/lib/internal/DoublyLinkedList.js\n   */\n  function DLL() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  DLL.prototype._removeLink = function(node) {\n    var prev = node.prev;\n    var next = node.next;\n    if (prev) {\n      prev.next = next;\n    } else {\n      this.head = next;\n    }\n    if (next) {\n      next.prev = prev;\n    } else {\n      this.tail = prev;\n    }\n    node.prev = null;\n    node.next = null;\n    this.length--;\n    return node;\n  };\n\n  DLL.prototype.empty = DLL;\n\n  DLL.prototype._setInitial = function(node) {\n    this.length = 1;\n    this.head = this.tail = node;\n  };\n\n  DLL.prototype.insertBefore = function(node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) {\n      node.prev.next = newNode;\n    } else {\n      this.head = newNode;\n    }\n    node.prev = newNode;\n    this.length++;\n  };\n\n  DLL.prototype.unshift = function(node) {\n    if (this.head) {\n      this.insertBefore(this.head, node);\n    } else {\n      this._setInitial(node);\n    }\n  };\n\n  DLL.prototype.push = function(node) {\n    var tail = this.tail;\n    if (tail) {\n      node.prev = tail;\n      node.next = tail.next;\n      this.tail = node;\n      tail.next = node;\n      this.length++;\n    } else {\n      this._setInitial(node);\n    }\n  };\n\n  DLL.prototype.shift = function() {\n    return this.head && this._removeLink(this.head);\n  };\n\n  DLL.prototype.splice = function(end) {\n    var task;\n    var tasks = [];\n    while (end-- && (task = this.shift())) {\n      tasks.push(task);\n    }\n    return tasks;\n  };\n\n  DLL.prototype.remove = function(test) {\n    var node = this.head;\n    while (node) {\n      if (test(node)) {\n        this._removeLink(node);\n      }\n      node = node.next;\n    }\n    return this;\n  };\n\n  /**\n   * @private\n   */\n  function baseQueue(isQueue, worker, concurrency, payload) {\n    if (concurrency === undefined) {\n      concurrency = 1;\n    } else if (isNaN(concurrency) || concurrency < 1) {\n      throw new Error('Concurrency must not be zero');\n    }\n\n    var workers = 0;\n    var workersList = [];\n    var _callback, _unshift;\n\n    var q = {\n      _tasks: new DLL(),\n      concurrency: concurrency,\n      payload: payload,\n      saturated: noop,\n      unsaturated: noop,\n      buffer: concurrency / 4,\n      empty: noop,\n      drain: noop,\n      error: noop,\n      started: false,\n      paused: false,\n      push: push,\n      kill: kill,\n      unshift: unshift,\n      remove: remove,\n      process: isQueue ? runQueue : runCargo,\n      length: getLength,\n      running: running,\n      workersList: getWorkersList,\n      idle: idle,\n      pause: pause,\n      resume: resume,\n      _worker: worker\n    };\n    return q;\n\n    function push(tasks, callback) {\n      _insert(tasks, callback);\n    }\n\n    function unshift(tasks, callback) {\n      _insert(tasks, callback, true);\n    }\n\n    function _exec(task) {\n      var item = {\n        data: task,\n        callback: _callback\n      };\n      if (_unshift) {\n        q._tasks.unshift(item);\n      } else {\n        q._tasks.push(item);\n      }\n      nextTick(q.process);\n    }\n\n    function _insert(tasks, callback, unshift) {\n      if (callback == null) {\n        callback = noop;\n      } else if (typeof callback !== 'function') {\n        throw new Error('task callback must be a function');\n      }\n      q.started = true;\n      var _tasks = isArray(tasks) ? tasks : [tasks];\n\n      if (tasks === undefined || !_tasks.length) {\n        if (q.idle()) {\n          nextTick(q.drain);\n        }\n        return;\n      }\n\n      _unshift = unshift;\n      _callback = callback;\n      arrayEachSync(_tasks, _exec);\n      // Avoid leaking the callback\n      _callback = undefined;\n    }\n\n    function kill() {\n      q.drain = noop;\n      q._tasks.empty();\n    }\n\n    function _next(q, tasks) {\n      var called = false;\n      return function done(err, res) {\n        if (called) {\n          throwError();\n        }\n        called = true;\n\n        workers--;\n        var task;\n        var index = -1;\n        var size = workersList.length;\n        var taskIndex = -1;\n        var taskSize = tasks.length;\n        var useApply = arguments.length > 2;\n        var args = useApply && createArray(arguments);\n        while (++taskIndex < taskSize) {\n          task = tasks[taskIndex];\n          while (++index < size) {\n            if (workersList[index] === task) {\n              if (index === 0) {\n                workersList.shift();\n              } else {\n                workersList.splice(index, 1);\n              }\n              index = size;\n              size--;\n            }\n          }\n          index = -1;\n          if (useApply) {\n            task.callback.apply(task, args);\n          } else {\n            task.callback(err, res);\n          }\n          if (err) {\n            q.error(err, task.data);\n          }\n        }\n\n        if (workers <= q.concurrency - q.buffer) {\n          q.unsaturated();\n        }\n\n        if (q._tasks.length + workers === 0) {\n          q.drain();\n        }\n        q.process();\n      };\n    }\n\n    function runQueue() {\n      while (!q.paused && workers < q.concurrency && q._tasks.length) {\n        var task = q._tasks.shift();\n        workers++;\n        workersList.push(task);\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n        if (workers === q.concurrency) {\n          q.saturated();\n        }\n        var done = _next(q, [task]);\n        worker(task.data, done);\n      }\n    }\n\n    function runCargo() {\n      while (!q.paused && workers < q.concurrency && q._tasks.length) {\n        var tasks = q._tasks.splice(q.payload || q._tasks.length);\n        var index = -1;\n        var size = tasks.length;\n        var data = Array(size);\n        while (++index < size) {\n          data[index] = tasks[index].data;\n        }\n        workers++;\n        nativePush.apply(workersList, tasks);\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n        if (workers === q.concurrency) {\n          q.saturated();\n        }\n        var done = _next(q, tasks);\n        worker(data, done);\n      }\n    }\n\n    function getLength() {\n      return q._tasks.length;\n    }\n\n    function running() {\n      return workers;\n    }\n\n    function getWorkersList() {\n      return workersList;\n    }\n\n    function idle() {\n      return q.length() + workers === 0;\n    }\n\n    function pause() {\n      q.paused = true;\n    }\n\n    function _resume() {\n      nextTick(q.process);\n    }\n\n    function resume() {\n      if (q.paused === false) {\n        return;\n      }\n      q.paused = false;\n      var count = q.concurrency < q._tasks.length ? q.concurrency : q._tasks.length;\n      timesSync(count, _resume);\n    }\n\n    /**\n     * @param {Function} test\n     */\n    function remove(test) {\n      q._tasks.remove(test);\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace queue\n   */\n  function queue(worker, concurrency) {\n    return baseQueue(true, worker, concurrency);\n  }\n\n  /**\n   * @memberof async\n   * @namespace priorityQueue\n   */\n  function priorityQueue(worker, concurrency) {\n    var q = baseQueue(true, worker, concurrency);\n    q.push = push;\n    delete q.unshift;\n    return q;\n\n    function push(tasks, priority, callback) {\n      q.started = true;\n      priority = priority || 0;\n      var _tasks = isArray(tasks) ? tasks : [tasks];\n      var taskSize = _tasks.length;\n\n      if (tasks === undefined || taskSize === 0) {\n        if (q.idle()) {\n          nextTick(q.drain);\n        }\n        return;\n      }\n\n      callback = typeof callback === func ? callback : noop;\n      var nextNode = q._tasks.head;\n      while (nextNode && priority >= nextNode.priority) {\n        nextNode = nextNode.next;\n      }\n      while (taskSize--) {\n        var item = {\n          data: _tasks[taskSize],\n          priority: priority,\n          callback: callback\n        };\n        if (nextNode) {\n          q._tasks.insertBefore(nextNode, item);\n        } else {\n          q._tasks.push(item);\n        }\n        nextTick(q.process);\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace cargo\n   */\n  function cargo(worker, payload) {\n    return baseQueue(false, worker, 1, payload);\n  }\n\n  /**\n   * @memberof async\n   * @namespace auto\n   * @param {Object} tasks\n   * @param {number} [concurrency]\n   * @param {Function} [callback]\n   */\n  function auto(tasks, concurrency, callback) {\n    if (typeof concurrency === func) {\n      callback = concurrency;\n      concurrency = null;\n    }\n    var keys = nativeKeys(tasks);\n    var rest = keys.length;\n    var results = {};\n    if (rest === 0) {\n      return callback(null, results);\n    }\n    var runningTasks = 0;\n    var readyTasks = new DLL();\n    var listeners = Object.create(null);\n    callback = onlyOnce(callback || noop);\n    concurrency = concurrency || rest;\n\n    baseEachSync(tasks, iterator, keys);\n    proceedQueue();\n\n    function iterator(task, key) {\n      // no dependencies\n      var _task, _taskSize;\n      if (!isArray(task)) {\n        _task = task;\n        _taskSize = 0;\n        readyTasks.push([_task, _taskSize, done]);\n        return;\n      }\n      var dependencySize = task.length - 1;\n      _task = task[dependencySize];\n      _taskSize = dependencySize;\n      if (dependencySize === 0) {\n        readyTasks.push([_task, _taskSize, done]);\n        return;\n      }\n      // dependencies\n      var index = -1;\n      while (++index < dependencySize) {\n        var dependencyName = task[index];\n        if (notInclude(keys, dependencyName)) {\n          var msg =\n            'async.auto task `' +\n            key +\n            '` has non-existent dependency `' +\n            dependencyName +\n            '` in ' +\n            task.join(', ');\n          throw new Error(msg);\n        }\n        var taskListeners = listeners[dependencyName];\n        if (!taskListeners) {\n          taskListeners = listeners[dependencyName] = [];\n        }\n        taskListeners.push(taskListener);\n      }\n\n      function done(err, arg) {\n        if (key === null) {\n          throwError();\n        }\n        arg = arguments.length <= 2 ? arg : slice(arguments, 1);\n        if (err) {\n          rest = 0;\n          runningTasks = 0;\n          readyTasks.length = 0;\n          var safeResults = objectClone(results);\n          safeResults[key] = arg;\n          key = null;\n          var _callback = callback;\n          callback = noop;\n          _callback(err, safeResults);\n          return;\n        }\n        runningTasks--;\n        rest--;\n        results[key] = arg;\n        taskComplete(key);\n        key = null;\n      }\n\n      function taskListener() {\n        if (--dependencySize === 0) {\n          readyTasks.push([_task, _taskSize, done]);\n        }\n      }\n    }\n\n    function proceedQueue() {\n      if (readyTasks.length === 0 && runningTasks === 0) {\n        if (rest !== 0) {\n          throw new Error('async.auto task has cyclic dependencies');\n        }\n        return callback(null, results);\n      }\n      while (readyTasks.length && runningTasks < concurrency && callback !== noop) {\n        runningTasks++;\n        var array = readyTasks.shift();\n        if (array[1] === 0) {\n          array[0](array[2]);\n        } else {\n          array[0](results, array[2]);\n        }\n      }\n    }\n\n    function taskComplete(key) {\n      var taskListeners = listeners[key] || [];\n      arrayEachSync(taskListeners, function(task) {\n        task();\n      });\n      proceedQueue();\n    }\n  }\n\n  var FN_ARGS = /^(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n  var FN_ARG_SPLIT = /,/;\n  var FN_ARG = /(=.+)?(\\s*)$/;\n  var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/gm;\n\n  /**\n   * parse function arguments for `autoInject`\n   *\n   * @private\n   */\n  function parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function(arg) {\n      return arg.replace(FN_ARG, '').trim();\n    });\n    return func;\n  }\n\n  /**\n   * @memberof async\n   * @namespace autoInject\n   * @param {Object} tasks\n   * @param {number} [concurrency]\n   * @param {Function} [callback]\n   */\n  function autoInject(tasks, concurrency, callback) {\n    var newTasks = {};\n    baseEachSync(tasks, iterator, nativeKeys(tasks));\n    auto(newTasks, concurrency, callback);\n\n    function iterator(task, key) {\n      var params;\n      var taskLength = task.length;\n\n      if (isArray(task)) {\n        if (taskLength === 0) {\n          throw new Error('autoInject task functions require explicit parameters.');\n        }\n        params = createArray(task);\n        taskLength = params.length - 1;\n        task = params[taskLength];\n        if (taskLength === 0) {\n          newTasks[key] = task;\n          return;\n        }\n      } else if (taskLength === 1) {\n        newTasks[key] = task;\n        return;\n      } else {\n        params = parseParams(task);\n        if (taskLength === 0 && params.length === 0) {\n          throw new Error('autoInject task functions require explicit parameters.');\n        }\n        taskLength = params.length - 1;\n      }\n      params[taskLength] = newTask;\n      newTasks[key] = params;\n\n      function newTask(results, done) {\n        switch (taskLength) {\n          case 1:\n            task(results[params[0]], done);\n            break;\n          case 2:\n            task(results[params[0]], results[params[1]], done);\n            break;\n          case 3:\n            task(results[params[0]], results[params[1]], results[params[2]], done);\n            break;\n          default:\n            var i = -1;\n            while (++i < taskLength) {\n              params[i] = results[params[i]];\n            }\n            params[i] = done;\n            task.apply(null, params);\n            break;\n        }\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace retry\n   * @param {integer|Object|Function} opts\n   * @param {Function} [task]\n   * @param {Function} [callback]\n   */\n  function retry(opts, task, callback) {\n    var times, intervalFunc, errorFilter;\n    var count = 0;\n    if (arguments.length < 3 && typeof opts === func) {\n      callback = task || noop;\n      task = opts;\n      opts = null;\n      times = DEFAULT_TIMES;\n    } else {\n      callback = callback || noop;\n      switch (typeof opts) {\n        case 'object':\n          if (typeof opts.errorFilter === func) {\n            errorFilter = opts.errorFilter;\n          }\n          var interval = opts.interval;\n          switch (typeof interval) {\n            case func:\n              intervalFunc = interval;\n              break;\n            case 'string':\n            case 'number':\n              interval = +interval;\n              intervalFunc = interval\n                ? function() {\n                    return interval;\n                  }\n                : function() {\n                    return DEFAULT_INTERVAL;\n                  };\n              break;\n          }\n          times = +opts.times || DEFAULT_TIMES;\n          break;\n        case 'number':\n          times = opts || DEFAULT_TIMES;\n          break;\n        case 'string':\n          times = +opts || DEFAULT_TIMES;\n          break;\n        default:\n          throw new Error('Invalid arguments for async.retry');\n      }\n    }\n    if (typeof task !== 'function') {\n      throw new Error('Invalid arguments for async.retry');\n    }\n\n    if (intervalFunc) {\n      task(intervalCallback);\n    } else {\n      task(simpleCallback);\n    }\n\n    function simpleIterator() {\n      task(simpleCallback);\n    }\n\n    function simpleCallback(err, res) {\n      if (++count === times || !err || (errorFilter && !errorFilter(err))) {\n        if (arguments.length <= 2) {\n          return callback(err, res);\n        }\n        var args = createArray(arguments);\n        return callback.apply(null, args);\n      }\n      simpleIterator();\n    }\n\n    function intervalIterator() {\n      task(intervalCallback);\n    }\n\n    function intervalCallback(err, res) {\n      if (++count === times || !err || (errorFilter && !errorFilter(err))) {\n        if (arguments.length <= 2) {\n          return callback(err, res);\n        }\n        var args = createArray(arguments);\n        return callback.apply(null, args);\n      }\n      setTimeout(intervalIterator, intervalFunc(count));\n    }\n  }\n\n  function retryable(opts, task) {\n    if (!task) {\n      task = opts;\n      opts = null;\n    }\n    return done;\n\n    function done() {\n      var taskFn;\n      var args = createArray(arguments);\n      var lastIndex = args.length - 1;\n      var callback = args[lastIndex];\n      switch (task.length) {\n        case 1:\n          taskFn = task1;\n          break;\n        case 2:\n          taskFn = task2;\n          break;\n        case 3:\n          taskFn = task3;\n          break;\n        default:\n          taskFn = task4;\n      }\n      if (opts) {\n        retry(opts, taskFn, callback);\n      } else {\n        retry(taskFn, callback);\n      }\n\n      function task1(done) {\n        task(done);\n      }\n\n      function task2(done) {\n        task(args[0], done);\n      }\n\n      function task3(done) {\n        task(args[0], args[1], done);\n      }\n\n      function task4(callback) {\n        args[lastIndex] = callback;\n        task.apply(null, args);\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace iterator\n   */\n  function iterator(tasks) {\n    var size = 0;\n    var keys = [];\n    if (isArray(tasks)) {\n      size = tasks.length;\n    } else {\n      keys = nativeKeys(tasks);\n      size = keys.length;\n    }\n    return makeCallback(0);\n\n    function makeCallback(index) {\n      var fn = function() {\n        if (size) {\n          var key = keys[index] || index;\n          tasks[key].apply(null, createArray(arguments));\n        }\n        return fn.next();\n      };\n      fn.next = function() {\n        return index < size - 1 ? makeCallback(index + 1) : null;\n      };\n      return fn;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace apply\n   */\n  function apply(func) {\n    switch (arguments.length) {\n      case 0:\n      case 1:\n        return func;\n      case 2:\n        return func.bind(null, arguments[1]);\n      case 3:\n        return func.bind(null, arguments[1], arguments[2]);\n      case 4:\n        return func.bind(null, arguments[1], arguments[2], arguments[3]);\n      case 5:\n        return func.bind(null, arguments[1], arguments[2], arguments[3], arguments[4]);\n      default:\n        var size = arguments.length;\n        var index = 0;\n        var args = Array(size);\n        args[index] = null;\n        while (++index < size) {\n          args[index] = arguments[index];\n        }\n        return func.bind.apply(func, args);\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace timeout\n   * @param {Function} func\n   * @param {number} millisec\n   * @param {*} info\n   */\n  function timeout(func, millisec, info) {\n    var callback, timer;\n    return wrappedFunc;\n\n    function wrappedFunc() {\n      timer = setTimeout(timeoutCallback, millisec);\n      var args = createArray(arguments);\n      var lastIndex = args.length - 1;\n      callback = args[lastIndex];\n      args[lastIndex] = injectedCallback;\n      simpleApply(func, args);\n    }\n\n    function timeoutCallback() {\n      var name = func.name || 'anonymous';\n      var err = new Error('Callback function \"' + name + '\" timed out.');\n      err.code = 'ETIMEDOUT';\n      if (info) {\n        err.info = info;\n      }\n      timer = null;\n      callback(err);\n    }\n\n    function injectedCallback() {\n      if (timer !== null) {\n        simpleApply(callback, createArray(arguments));\n        clearTimeout(timer);\n      }\n    }\n\n    function simpleApply(func, args) {\n      switch (args.length) {\n        case 0:\n          func();\n          break;\n        case 1:\n          func(args[0]);\n          break;\n        case 2:\n          func(args[0], args[1]);\n          break;\n        default:\n          func.apply(null, args);\n          break;\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace times\n   * @param {number} n - n >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * var iterator = function(n, done) {\n   *   done(null, n);\n   * };\n   * async.times(4, iterator, function(err, res) {\n   *   console.log(res); // [0, 1, 2, 3];\n   * });\n   *\n   */\n  function times(n, iterator, callback) {\n    callback = callback || noop;\n    n = +n;\n    if (isNaN(n) || n < 1) {\n      return callback(null, []);\n    }\n    var result = Array(n);\n    timesSync(n, iterate);\n\n    function iterate(num) {\n      iterator(num, createCallback(num));\n    }\n\n    function createCallback(index) {\n      return function(err, res) {\n        if (index === null) {\n          throwError();\n        }\n        result[index] = res;\n        index = null;\n        if (err) {\n          callback(err);\n          callback = noop;\n        } else if (--n === 0) {\n          callback(null, result);\n        }\n      };\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace timesSeries\n   * @param {number} n - n >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * var iterator = function(n, done) {\n   *   done(null, n);\n   * };\n   * async.timesSeries(4, iterator, function(err, res) {\n   *   console.log(res); // [0, 1, 2, 3];\n   * });\n   *\n   */\n  function timesSeries(n, iterator, callback) {\n    callback = callback || noop;\n    n = +n;\n    if (isNaN(n) || n < 1) {\n      return callback(null, []);\n    }\n    var result = Array(n);\n    var sync = false;\n    var completed = 0;\n    iterate();\n\n    function iterate() {\n      iterator(completed, done);\n    }\n\n    function done(err, res) {\n      result[completed] = res;\n      if (err) {\n        callback(err);\n        callback = throwError;\n      } else if (++completed >= n) {\n        callback(null, result);\n        callback = throwError;\n      } else if (sync) {\n        nextTick(iterate);\n      } else {\n        sync = true;\n        iterate();\n      }\n      sync = false;\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace timesLimit\n   * @param {number} n - n >= 1\n   * @param {number} limit - n >= 1\n   * @param {Function} iterator\n   * @param {Function} callback\n   * @example\n   *\n   * var iterator = function(n, done) {\n   *   done(null, n);\n   * };\n   * async.timesLimit(4, 2, iterator, function(err, res) {\n   *   console.log(res); // [0, 1, 2, 3];\n   * });\n   *\n   */\n  function timesLimit(n, limit, iterator, callback) {\n    callback = callback || noop;\n    n = +n;\n    if (isNaN(n) || n < 1 || isNaN(limit) || limit < 1) {\n      return callback(null, []);\n    }\n    var result = Array(n);\n    var sync = false;\n    var started = 0;\n    var completed = 0;\n    timesSync(limit > n ? n : limit, iterate);\n\n    function iterate() {\n      var index = started++;\n      if (index < n) {\n        iterator(index, createCallback(index));\n      }\n    }\n\n    function createCallback(index) {\n      return function(err, res) {\n        if (index === null) {\n          throwError();\n        }\n        result[index] = res;\n        index = null;\n        if (err) {\n          callback(err);\n          callback = noop;\n        } else if (++completed >= n) {\n          callback(null, result);\n          callback = throwError;\n        } else if (sync) {\n          nextTick(iterate);\n        } else {\n          sync = true;\n          iterate();\n        }\n        sync = false;\n      };\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace race\n   * @param {Array|Object} tasks - functions\n   * @param {Function} callback\n   * @example\n   *\n   * // array\n   * var called = 0;\n   * var tasks = [\n   *   function(done) {\n   *     setTimeout(function() {\n   *       called++;\n   *       done(null, '1');\n   *     }, 30);\n   *   },\n   *   function(done) {\n   *     setTimeout(function() {\n   *       called++;\n   *       done(null, '2');\n   *     }, 20);\n   *   },\n   *   function(done) {\n   *     setTimeout(function() {\n   *       called++;\n   *       done(null, '3');\n   *     }, 10);\n   *   }\n   * ];\n   * async.race(tasks, function(err, res) {\n   *   console.log(res); // '3'\n   *   console.log(called); // 1\n   *   setTimeout(function() {\n   *     console.log(called); // 3\n   *   }, 50);\n   * });\n   *\n   * @example\n   *\n   * // object\n   * var called = 0;\n   * var tasks = {\n   *   'test1': function(done) {\n   *     setTimeout(function() {\n   *       called++;\n   *       done(null, '1');\n   *     }, 30);\n   *   },\n   *   'test2': function(done) {\n   *     setTimeout(function() {\n   *       called++;\n   *       done(null, '2');\n   *     }, 20);\n   *   },\n   *   'test3': function(done) {\n   *     setTimeout(function() {\n   *       called++;\n   *       done(null, '3');\n   *     }, 10);\n   *   }\n   * };\n   * async.race(tasks, function(err, res) {\n   *   console.log(res); // '3'\n   *   console.log(called); // 1\n   *   setTimeout(function() {\n   *     console.log(called); // 3\n   *     done();\n   *   }, 50);\n   * });\n   *\n   */\n  function race(tasks, callback) {\n    callback = once(callback || noop);\n    var size, keys;\n    var index = -1;\n    if (isArray(tasks)) {\n      size = tasks.length;\n      while (++index < size) {\n        tasks[index](callback);\n      }\n    } else if (tasks && typeof tasks === obj) {\n      keys = nativeKeys(tasks);\n      size = keys.length;\n      while (++index < size) {\n        tasks[keys[index]](callback);\n      }\n    } else {\n      return callback(new TypeError('First argument to race must be a collection of functions'));\n    }\n    if (!size) {\n      callback(null);\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace memoize\n   */\n  function memoize(fn, hasher) {\n    hasher =\n      hasher ||\n      function(hash) {\n        return hash;\n      };\n\n    var memo = {};\n    var queues = {};\n    var memoized = function() {\n      var args = createArray(arguments);\n      var callback = args.pop();\n      var key = hasher.apply(null, args);\n      if (has(memo, key)) {\n        nextTick(function() {\n          callback.apply(null, memo[key]);\n        });\n        return;\n      }\n      if (has(queues, key)) {\n        return queues[key].push(callback);\n      }\n\n      queues[key] = [callback];\n      args.push(done);\n      fn.apply(null, args);\n\n      function done(err) {\n        var args = createArray(arguments);\n        if (!err) {\n          memo[key] = args;\n        }\n        var q = queues[key];\n        delete queues[key];\n\n        var i = -1;\n        var size = q.length;\n        while (++i < size) {\n          q[i].apply(null, args);\n        }\n      }\n    };\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n  }\n\n  /**\n   * @memberof async\n   * @namespace unmemoize\n   */\n  function unmemoize(fn) {\n    return function() {\n      return (fn.unmemoized || fn).apply(null, arguments);\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace ensureAsync\n   */\n  function ensureAsync(fn) {\n    return function(/* ...args, callback */) {\n      var args = createArray(arguments);\n      var lastIndex = args.length - 1;\n      var callback = args[lastIndex];\n      var sync = true;\n      args[lastIndex] = done;\n      fn.apply(this, args);\n      sync = false;\n\n      function done() {\n        var innerArgs = createArray(arguments);\n        if (sync) {\n          nextTick(function() {\n            callback.apply(null, innerArgs);\n          });\n        } else {\n          callback.apply(null, innerArgs);\n        }\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace constant\n   */\n  function constant(/* values... */) {\n    var args = [null].concat(createArray(arguments));\n    return function(callback) {\n      callback = arguments[arguments.length - 1];\n      callback.apply(this, args);\n    };\n  }\n\n  function asyncify(fn) {\n    return function(/* args..., callback */) {\n      var args = createArray(arguments);\n      var callback = args.pop();\n      var result;\n      try {\n        result = fn.apply(this, args);\n      } catch (e) {\n        return callback(e);\n      }\n      if (result && typeof result.then === func) {\n        result.then(\n          function(value) {\n            invokeCallback(callback, null, value);\n          },\n          function(err) {\n            invokeCallback(callback, err && err.message ? err : new Error(err));\n          }\n        );\n      } else {\n        callback(null, result);\n      }\n    };\n  }\n\n  function invokeCallback(callback, err, value) {\n    try {\n      callback(err, value);\n    } catch (e) {\n      nextTick(rethrow, e);\n    }\n  }\n\n  function rethrow(error) {\n    throw error;\n  }\n\n  /**\n   * @memberof async\n   * @namespace reflect\n   * @param {Function} func\n   * @return {Function}\n   */\n  function reflect(func) {\n    return function(/* args..., callback */) {\n      var callback;\n      switch (arguments.length) {\n        case 1:\n          callback = arguments[0];\n          return func(done);\n        case 2:\n          callback = arguments[1];\n          return func(arguments[0], done);\n        default:\n          var args = createArray(arguments);\n          var lastIndex = args.length - 1;\n          callback = args[lastIndex];\n          args[lastIndex] = done;\n          func.apply(this, args);\n      }\n\n      function done(err, res) {\n        if (err) {\n          return callback(null, {\n            error: err\n          });\n        }\n        if (arguments.length > 2) {\n          res = slice(arguments, 1);\n        }\n        callback(null, {\n          value: res\n        });\n      }\n    };\n  }\n\n  /**\n   * @memberof async\n   * @namespace reflectAll\n   * @param {Array[]|Object} tasks\n   * @return {Function}\n   */\n  function reflectAll(tasks) {\n    var newTasks, keys;\n    if (isArray(tasks)) {\n      newTasks = Array(tasks.length);\n      arrayEachSync(tasks, iterate);\n    } else if (tasks && typeof tasks === obj) {\n      keys = nativeKeys(tasks);\n      newTasks = {};\n      baseEachSync(tasks, iterate, keys);\n    }\n    return newTasks;\n\n    function iterate(func, key) {\n      newTasks[key] = reflect(func);\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace createLogger\n   */\n  function createLogger(name) {\n    return function(fn) {\n      var args = slice(arguments, 1);\n      args.push(done);\n      fn.apply(null, args);\n    };\n\n    function done(err) {\n      if (typeof console === obj) {\n        if (err) {\n          if (console.error) {\n            console.error(err);\n          }\n          return;\n        }\n        if (console[name]) {\n          var args = slice(arguments, 1);\n          arrayEachSync(args, function(arg) {\n            console[name](arg);\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * @memberof async\n   * @namespace safe\n   */\n  function safe() {\n    createImmediate();\n    return exports;\n  }\n\n  /**\n   * @memberof async\n   * @namespace fast\n   */\n  function fast() {\n    createImmediate(false);\n    return exports;\n  }\n});\n"]}