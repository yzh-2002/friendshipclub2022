{"version":3,"sources":["remapping.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@jridgewell/trace-mapping')) :\n    typeof define === 'function' && define.amd ? define(['@jridgewell/trace-mapping'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.remapping = factory(global.traceMapping));\n})(this, (function (traceMapping) { \n\n    /**\n     * A \"leaf\" node in the sourcemap tree, representing an original, unmodified\n     * source file. Recursive segment tracing ends at the `OriginalSource`.\n     */\n    class OriginalSource {\n        constructor(source, content) {\n            this.source = source;\n            this.content = content;\n        }\n        /**\n         * Tracing a `SourceMapSegment` ends when we get to an `OriginalSource`,\n         * meaning this line/column location originated from this source file.\n         */\n        originalPositionFor(line, column, name) {\n            return { column, line, name, source: this.source, content: this.content };\n        }\n    }\n\n    /**\n     * Puts `key` into the backing array, if it is not already present. Returns\n     * the index of the `key` in the backing array.\n     */\n    let put;\n    /**\n     * FastStringArray acts like a `Set` (allowing only one occurrence of a string\n     * `key`), but provides the index of the `key` in the backing array.\n     *\n     * This is designed to allow synchronizing a second array with the contents of\n     * the backing array, like how `sourcesContent[i]` is the source content\n     * associated with `source[i]`, and there are never duplicates.\n     */\n    class FastStringArray {\n        constructor() {\n            this.indexes = Object.create(null);\n            this.array = [];\n        }\n    }\n    (() => {\n        put = (strarr, key) => {\n            const { array, indexes } = strarr;\n            // The key may or may not be present. If it is present, it's a number.\n            let index = indexes[key];\n            // If it's not yet present, we need to insert it and track the index in the\n            // indexes.\n            if (index === undefined) {\n                index = indexes[key] = array.length;\n                array.push(key);\n            }\n            return index;\n        };\n    })();\n\n    const INVALID_MAPPING = undefined;\n    const SOURCELESS_MAPPING = null;\n    /**\n     * traceMappings is only called on the root level SourceMapTree, and begins the process of\n     * resolving each mapping in terms of the original source files.\n     */\n    let traceMappings;\n    /**\n     * SourceMapTree represents a single sourcemap, with the ability to trace\n     * mappings into its child nodes (which may themselves be SourceMapTrees).\n     */\n    class SourceMapTree {\n        constructor(map, sources) {\n            this.map = map;\n            this.sources = sources;\n        }\n        /**\n         * originalPositionFor is only called on children SourceMapTrees. It recurses down\n         * into its own child SourceMapTrees, until we find the original source map.\n         */\n        originalPositionFor(line, column, name) {\n            const segment = traceMapping.traceSegment(this.map, line, column);\n            // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n            if (segment == null)\n                return INVALID_MAPPING;\n            // 1-length segments only move the current generated column, there's no source information\n            // to gather from it.\n            if (segment.length === 1)\n                return SOURCELESS_MAPPING;\n            const source = this.sources[segment[1]];\n            return source.originalPositionFor(segment[2], segment[3], segment.length === 5 ? this.map.names[segment[4]] : name);\n        }\n    }\n    (() => {\n        traceMappings = (tree) => {\n            const mappings = [];\n            const names = new FastStringArray();\n            const sources = new FastStringArray();\n            const sourcesContent = [];\n            const { sources: rootSources, map } = tree;\n            const rootNames = map.names;\n            const rootMappings = traceMapping.decodedMappings(map);\n            let lastLineWithSegment = -1;\n            for (let i = 0; i < rootMappings.length; i++) {\n                const segments = rootMappings[i];\n                const tracedSegments = [];\n                let lastSourcesIndex = -1;\n                let lastSourceLine = -1;\n                let lastSourceColumn = -1;\n                for (let j = 0; j < segments.length; j++) {\n                    const segment = segments[j];\n                    let traced = SOURCELESS_MAPPING;\n                    // 1-length segments only move the current generated column, there's no source information\n                    // to gather from it.\n                    if (segment.length !== 1) {\n                        const source = rootSources[segment[1]];\n                        traced = source.originalPositionFor(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n                        // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n                        // respective segment into an original source.\n                        if (traced === INVALID_MAPPING)\n                            continue;\n                    }\n                    const genCol = segment[0];\n                    if (traced === SOURCELESS_MAPPING) {\n                        if (lastSourcesIndex === -1) {\n                            // This is a consecutive source-less segment, which doesn't carry any new information.\n                            continue;\n                        }\n                        lastSourcesIndex = lastSourceLine = lastSourceColumn = -1;\n                        tracedSegments.push([genCol]);\n                        continue;\n                    }\n                    // So we traced a segment down into its original source file. Now push a\n                    // new segment pointing to this location.\n                    const { column, line, name, content, source } = traced;\n                    // Store the source location, and ensure we keep sourcesContent up to\n                    // date with the sources array.\n                    const sourcesIndex = put(sources, source);\n                    sourcesContent[sourcesIndex] = content;\n                    if (lastSourcesIndex === sourcesIndex &&\n                        lastSourceLine === line &&\n                        lastSourceColumn === column) {\n                        // This is a duplicate mapping pointing at the exact same starting point in the source\n                        // file. It doesn't carry any new information, and only bloats the sourcemap.\n                        continue;\n                    }\n                    lastLineWithSegment = i;\n                    lastSourcesIndex = sourcesIndex;\n                    lastSourceLine = line;\n                    lastSourceColumn = column;\n                    // This looks like unnecessary duplication, but it noticeably increases performance. If we\n                    // were to push the nameIndex onto length-4 array, v8 would internally allocate 22 slots!\n                    // That's 68 wasted bytes! Array literals have the same capacity as their length, saving\n                    // memory.\n                    tracedSegments.push(name\n                        ? [genCol, sourcesIndex, line, column, put(names, name)]\n                        : [genCol, sourcesIndex, line, column]);\n                }\n                mappings.push(tracedSegments);\n            }\n            if (mappings.length > lastLineWithSegment + 1) {\n                mappings.length = lastLineWithSegment + 1;\n            }\n            return traceMapping.presortedDecodedMap(Object.assign({}, tree.map, {\n                mappings,\n                // TODO: Make all sources relative to the sourceRoot.\n                sourceRoot: undefined,\n                names: names.array,\n                sources: sources.array,\n                sourcesContent,\n            }));\n        };\n    })();\n\n    function asArray(value) {\n        if (Array.isArray(value))\n            return value;\n        return [value];\n    }\n    /**\n     * Recursively builds a tree structure out of sourcemap files, with each node\n     * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n     * `OriginalSource`s and `SourceMapTree`s.\n     *\n     * Every sourcemap is composed of a collection of source files and mappings\n     * into locations of those source files. When we generate a `SourceMapTree` for\n     * the sourcemap, we attempt to load each source file's own sourcemap. If it\n     * does not have an associated sourcemap, it is considered an original,\n     * unmodified source file.\n     */\n    function buildSourceMapTree(input, loader) {\n        const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ''));\n        const map = maps.pop();\n        for (let i = 0; i < maps.length; i++) {\n            if (maps[i].sources.length > 1) {\n                throw new Error(`Transformation map ${i} must have exactly one source file.\\n` +\n                    'Did you specify these with the most recent transformation maps first?');\n            }\n        }\n        let tree = build(map, loader, '', 0);\n        for (let i = maps.length - 1; i >= 0; i--) {\n            tree = new SourceMapTree(maps[i], [tree]);\n        }\n        return tree;\n    }\n    function build(map, loader, importer, importerDepth) {\n        const { resolvedSources, sourcesContent } = map;\n        const depth = importerDepth + 1;\n        const children = resolvedSources.map((sourceFile, i) => {\n            // The loading context gives the loader more information about why this file is being loaded\n            // (eg, from which importer). It also allows the loader to override the location of the loaded\n            // sourcemap/original source, or to override the content in the sourcesContent field if it's\n            // an unmodified source file.\n            const ctx = {\n                importer,\n                depth,\n                source: sourceFile || '',\n                content: undefined,\n            };\n            // Use the provided loader callback to retrieve the file's sourcemap.\n            // TODO: We should eventually support async loading of sourcemap files.\n            const sourceMap = loader(ctx.source, ctx);\n            const { source, content } = ctx;\n            // If there is no sourcemap, then it is an unmodified source file.\n            if (!sourceMap) {\n                // The contents of this unmodified source file can be overridden via the loader context,\n                // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n                // the importing sourcemap's `sourcesContent` field.\n                const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n                return new OriginalSource(source, sourceContent);\n            }\n            // Else, it's a real sourcemap, and we need to recurse into it to load its\n            // source files.\n            return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth);\n        });\n        return new SourceMapTree(map, children);\n    }\n\n    /**\n     * A SourceMap v3 compatible sourcemap, which only includes fields that were\n     * provided to it.\n     */\n    class SourceMap {\n        constructor(map, options) {\n            this.version = 3; // SourceMap spec says this should be first.\n            this.file = map.file;\n            this.mappings = options.decodedMappings ? traceMapping.decodedMappings(map) : traceMapping.encodedMappings(map);\n            this.names = map.names;\n            this.sourceRoot = map.sourceRoot;\n            this.sources = map.sources;\n            if (!options.excludeContent && 'sourcesContent' in map) {\n                this.sourcesContent = map.sourcesContent;\n            }\n        }\n        toString() {\n            return JSON.stringify(this);\n        }\n    }\n\n    /**\n     * Traces through all the mappings in the root sourcemap, through the sources\n     * (and their sourcemaps), all the way back to the original source location.\n     *\n     * `loader` will be called every time we encounter a source file. If it returns\n     * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n     * it returns a falsey value, that source file is treated as an original,\n     * unmodified source file.\n     *\n     * Pass `excludeContent` to exclude any self-containing source file content\n     * from the output sourcemap.\n     *\n     * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n     * VLQ encoded) mappings.\n     */\n    function remapping(input, loader, options) {\n        const opts = typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };\n        const tree = buildSourceMapTree(input, loader);\n        return new SourceMap(traceMappings(tree), opts);\n    }\n\n    return remapping;\n\n}));\n//# sourceMappingURL=remapping.umd.js.map\n"]}