{"version":3,"sources":["index.js","topologicalSort.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const postcss = require('postcss')\nconst topologicalSort = require('./topologicalSort')\n\nconst declWhitelist = ['composes']\nconst declFilter = new RegExp(`^(${declWhitelist.join('|')})$`)\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/\n\nconst VISITED_MARKER = 1\n\nfunction createParentName(rule, root) {\n  return `__${root.index(rule.parent)}_${rule.selector}`\n}\n\nfunction serializeImports(imports) {\n  return imports.map(importPath => '`' + importPath + '`').join(', ')\n}\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + '_' + 'siblings'\n  const visitedId = parentId + '_' + importId\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) visited[siblingsId] = []\n\n    const siblings = visited[siblingsId]\n\n    if (Array.isArray(graph[importId]))\n      graph[importId] = graph[importId].concat(siblings)\n    else graph[importId] = siblings.slice()\n\n    visited[visitedId] = VISITED_MARKER\n    siblings.push(importId)\n  }\n}\n\nmodule.exports = postcss.plugin('modules-extract-imports', function(\n  options = {}\n) {\n  const failOnWrongOrder = options.failOnWrongOrder\n\n  return css => {\n    const graph = {}\n    const visited = {}\n\n    const existingImports = {}\n    const importDecls = {}\n    const imports = {}\n\n    let importIndex = 0\n\n    const createImportedName = typeof options.createImportedName !== 'function'\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, '_')}_${importIndex++}`\n      : options.createImportedName\n\n    // Check the existing imports order and save refs\n    css.walkRules(rule => {\n      const matches = icssImport.exec(rule.selector)\n\n      if (matches) {\n        const [, /*match*/ doubleQuotePath, singleQuotePath] = matches\n        const importPath = doubleQuotePath || singleQuotePath\n\n        addImportToGraph(importPath, 'root', graph, visited)\n\n        existingImports[importPath] = rule\n      }\n    })\n\n    // Find any declaration that supports imports\n    css.walkDecls(declFilter, decl => {\n      let matches = decl.value.match(matchImports)\n      let tmpSymbols\n\n      if (matches) {\n        let [\n          ,\n          /*match*/ symbols,\n          doubleQuotePath,\n          singleQuotePath,\n          global\n        ] = matches\n\n        if (global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`)\n        } else {\n          const importPath = doubleQuotePath || singleQuotePath\n          const parentRule = createParentName(decl.parent, css)\n\n          addImportToGraph(importPath, parentRule, graph, visited)\n\n          importDecls[importPath] = decl\n          imports[importPath] = imports[importPath] || {}\n\n          tmpSymbols = symbols.split(/\\s+/).map(s => {\n            if (!imports[importPath][s]) {\n              imports[importPath][s] = createImportedName(s, importPath)\n            }\n\n            return imports[importPath][s]\n          })\n        }\n\n        decl.value = tmpSymbols.join(' ')\n      }\n    })\n\n    const importsOrder = topologicalSort(graph, failOnWrongOrder)\n\n    if (importsOrder instanceof Error) {\n      const importPath = importsOrder.nodes.find(importPath =>\n        importDecls.hasOwnProperty(importPath)\n      )\n      const decl = importDecls[importPath]\n\n      const errMsg =\n        'Failed to resolve order of composed modules ' +\n        serializeImports(importsOrder.nodes) +\n        '.'\n\n      throw decl.error(errMsg, {\n        plugin: 'modules-extract-imports',\n        word: 'composes'\n      })\n    }\n\n    let lastImportRule\n    importsOrder.forEach(path => {\n      const importedSymbols = imports[path]\n      let rule = existingImports[path]\n\n      if (!rule && importedSymbols) {\n        rule = postcss.rule({\n          selector: `:import(\"${path}\")`,\n          raws: { after: '\\n' }\n        })\n\n        if (lastImportRule) css.insertAfter(lastImportRule, rule)\n        else css.prepend(rule)\n      }\n\n      lastImportRule = rule\n\n      if (!importedSymbols) return\n\n      Object.keys(importedSymbols).forEach(importedSymbol => {\n        rule.append(\n          postcss.decl({\n            value: importedSymbol,\n            prop: importedSymbols[importedSymbol],\n            raws: { before: '\\n  ' }\n          })\n        )\n      })\n    })\n  }\n})\n","const PERMANENT_MARKER = 2\nconst TEMPORARY_MARKER = 1\n\nfunction createError(node, graph) {\n  const er = new Error(\"Nondeterministic import's order\")\n\n  const related = graph[node]\n  const relatedNode = related.find(\n    relatedNode => graph[relatedNode].indexOf(node) > -1\n  )\n\n  er.nodes = [node, relatedNode]\n\n  return er\n}\n\nfunction walkGraph(node, graph, state, result, strict) {\n  if (state[node] === PERMANENT_MARKER) return\n  if (state[node] === TEMPORARY_MARKER) {\n    if (strict) return createError(node, graph)\n    return\n  }\n\n  state[node] = TEMPORARY_MARKER\n\n  const children = graph[node]\n  const length = children.length\n\n  for (let i = 0; i < length; ++i) {\n    const er = walkGraph(children[i], graph, state, result, strict)\n    if (er instanceof Error) return er\n  }\n\n  state[node] = PERMANENT_MARKER\n\n  result.push(node)\n}\n\nfunction topologicalSort(graph, strict) {\n  const result = []\n  const state = {}\n\n  const nodes = Object.keys(graph)\n  const length = nodes.length\n\n  for (let i = 0; i < length; ++i) {\n    const er = walkGraph(nodes[i], graph, state, result, strict)\n    if (er instanceof Error) return er\n  }\n\n  return result\n}\n\nmodule.exports = topologicalSort\n"]}