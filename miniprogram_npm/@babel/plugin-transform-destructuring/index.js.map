{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar core = require('@babel/core');\n\nfunction hasArrayRest(pattern) {\n  return pattern.elements.some(elem => core.types.isRestElement(elem));\n}\n\nfunction hasObjectRest(pattern) {\n  return pattern.properties.some(prop => core.types.isRestElement(prop));\n}\n\nconst STOP_TRAVERSAL = {};\n\nconst arrayUnpackVisitor = (node, ancestors, state) => {\n  if (!ancestors.length) {\n    return;\n  }\n\n  if (core.types.isIdentifier(node) && core.types.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]) {\n    state.deopt = true;\n    throw STOP_TRAVERSAL;\n  }\n};\n\nclass DestructuringTransformer {\n  constructor(opts) {\n    this.blockHoist = void 0;\n    this.operator = void 0;\n    this.arrayRefSet = void 0;\n    this.nodes = void 0;\n    this.scope = void 0;\n    this.kind = void 0;\n    this.iterableIsArray = void 0;\n    this.arrayLikeIsIterable = void 0;\n    this.objectRestNoSymbols = void 0;\n    this.useBuiltIns = void 0;\n    this.addHelper = void 0;\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n\n  getExtendsHelper() {\n    return this.useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : this.addHelper(\"extends\");\n  }\n\n  buildVariableAssignment(id, init) {\n    let op = this.operator;\n    if (core.types.isMemberExpression(id)) op = \"=\";\n    let node;\n\n    if (op) {\n      node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode()));\n    } else {\n      let nodeInit;\n\n      if (this.kind === \"const\" && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = core.types.cloneNode(init);\n      }\n\n      node = core.types.variableDeclaration(this.kind, [core.types.variableDeclarator(id, nodeInit)]);\n    }\n\n    node._blockHoist = this.blockHoist;\n    return node;\n  }\n\n  buildVariableDeclaration(id, init) {\n    const declar = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init))]);\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n\n  push(id, _init) {\n    const init = core.types.cloneNode(_init);\n\n    if (core.types.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (core.types.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (core.types.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  }\n\n  toArray(node, count) {\n    if (this.iterableIsArray || core.types.isIdentifier(node) && this.arrayRefSet.has(node.name)) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count, this.arrayLikeIsIterable);\n    }\n  }\n\n  pushAssignmentPattern({\n    left,\n    right\n  }, valueRef) {\n    if (valueRef === null) {\n      this.push(left, right);\n      return;\n    }\n\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n    const tempConditional = core.types.conditionalExpression(core.types.binaryExpression(\"===\", core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));\n\n    if (core.types.isPattern(left)) {\n      let patternId;\n      let node;\n\n      if (this.kind === \"const\" || this.kind === \"let\") {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n        node = core.types.expressionStatement(core.types.assignmentExpression(\"=\", core.types.cloneNode(tempId), tempConditional));\n      }\n\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n\n  pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n    const value = buildObjectExcludingKeys(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, name => this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns);\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n\n  pushObjectProperty(prop, propRef) {\n    if (core.types.isLiteral(prop.key)) prop.computed = true;\n    const pattern = prop.value;\n    const objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);\n\n    if (core.types.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n\n  pushObjectPattern(pattern, objRef) {\n    if (!pattern.properties.length || objRef === null) {\n      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), objRef !== null ? [objRef] : [])));\n      return;\n    }\n\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n\n    if (hasObjectRest(pattern)) {\n      let copiedPattern;\n\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n\n        if (core.types.isRestElement(prop)) {\n          break;\n        }\n\n        const key = prop.key;\n\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(this.buildVariableDeclaration(name, key));\n\n          if (!copiedPattern) {\n            copiedPattern = pattern = Object.assign({}, pattern, {\n              properties: pattern.properties.slice()\n            });\n          }\n\n          copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {\n            key: name\n          });\n        }\n      }\n    }\n\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n\n      if (core.types.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n\n  canUnpackArrayPattern(pattern, arr) {\n    if (!core.types.isArrayExpression(arr)) return false;\n    if (pattern.elements.length > arr.elements.length) return;\n\n    if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) {\n      return false;\n    }\n\n    for (const elem of pattern.elements) {\n      if (!elem) return false;\n      if (core.types.isMemberExpression(elem)) return false;\n    }\n\n    for (const elem of arr.elements) {\n      if (core.types.isSpreadElement(elem)) return false;\n      if (core.types.isCallExpression(elem)) return false;\n      if (core.types.isMemberExpression(elem)) return false;\n    }\n\n    const bindings = core.types.getBindingIdentifiers(pattern);\n    const state = {\n      deopt: false,\n      bindings\n    };\n\n    try {\n      core.types.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n\n    return !state.deopt;\n  }\n\n  pushUnpackedArrayPattern(pattern, arr) {\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n\n      if (core.types.isRestElement(elem)) {\n        this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i)));\n      } else {\n        this.push(elem, arr.elements[i]);\n      }\n    }\n  }\n\n  pushArrayPattern(pattern, arrayRef) {\n    if (arrayRef === null) {\n      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), [])));\n      return;\n    }\n\n    if (!pattern.elements) return;\n\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      return this.pushUnpackedArrayPattern(pattern, arrayRef);\n    }\n\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n    const toArray = this.toArray(arrayRef, count);\n\n    if (core.types.isIdentifier(toArray)) {\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (!elem) continue;\n      let elemRef;\n\n      if (core.types.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier(\"slice\")), [core.types.numericLiteral(i)]);\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n\n  init(pattern, ref) {\n    if (!core.types.isArrayExpression(ref) && !core.types.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n\n    this.push(pattern, ref);\n    return this.nodes;\n  }\n\n}\nfunction buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n\n    if (core.types.isIdentifier(key) && !prop.computed) {\n      keys.push(core.types.stringLiteral(key.name));\n    } else if (core.types.isTemplateLiteral(key)) {\n      keys.push(core.types.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (core.types.isLiteral(key)) {\n      keys.push(core.types.stringLiteral(String(key.value)));\n    } else if (core.types.isPrivateName(key)) ; else {\n      keys.push(core.types.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n\n  let value;\n\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : addHelper(\"extends\");\n    value = core.types.callExpression(extendsHelper, [core.types.objectExpression([]), core.types.cloneNode(objRef)]);\n  } else {\n    let keyExpression = core.types.arrayExpression(keys);\n\n    if (!allLiteral) {\n      keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier(\"map\")), [addHelper(\"toPropertyKey\")]);\n    } else if (!hasTemplateLiteral && !core.types.isProgram(scope.block)) {\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\"\n      });\n      keyExpression = core.types.cloneNode(id);\n    }\n\n    value = core.types.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`), [core.types.cloneNode(objRef), keyExpression]);\n  }\n\n  return value;\n}\nfunction convertVariableDeclaration(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {\n  const {\n    node,\n    scope\n  } = path;\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n    const patternId = declar.init;\n    const pattern = declar.id;\n    const destructuring = new DestructuringTransformer({\n      blockHoist: node._blockHoist,\n      nodes: nodes,\n      scope: scope,\n      kind: node.kind,\n      iterableIsArray,\n      arrayLikeIsIterable,\n      useBuiltIns,\n      objectRestNoSymbols,\n      addHelper\n    });\n\n    if (core.types.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n\n      if (+i !== node.declarations.length - 1) {\n        core.types.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));\n    }\n  }\n\n  let tail = null;\n  const nodesOut = [];\n\n  for (const node of nodes) {\n    if (tail !== null && core.types.isVariableDeclaration(node)) {\n      tail.declarations.push(...node.declarations);\n    } else {\n      node.kind = nodeKind;\n\n      if (!node.loc) {\n        node.loc = nodeLoc;\n      }\n\n      nodesOut.push(node);\n      tail = core.types.isVariableDeclaration(node) ? node : null;\n    }\n  }\n\n  for (const nodeOut of nodesOut) {\n    if (!nodeOut.declarations) continue;\n\n    for (const declaration of nodeOut.declarations) {\n      const {\n        name\n      } = declaration.id;\n\n      if (scope.bindings[name]) {\n        scope.bindings[name].kind = nodeOut.kind;\n      }\n    }\n  }\n\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n}\nfunction convertAssignmentExpression(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {\n  const {\n    node,\n    scope\n  } = path;\n  const nodes = [];\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper\n  });\n  let ref;\n\n  if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n    nodes.push(core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(ref, node.right)]));\n\n    if (core.types.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n\n  destructuring.init(node.left, ref || node.right);\n\n  if (ref) {\n    if (path.parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(core.types.blockStatement([]));\n      nodes.push(core.types.returnStatement(core.types.cloneNode(ref)));\n    } else {\n      nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)));\n    }\n  }\n\n  path.replaceWithMultiple(nodes);\n  path.scope.crawl();\n}\n\nfunction variableDeclarationHasPattern(node) {\n  for (const declar of node.declarations) {\n    if (core.types.isPattern(declar.id)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar index = helperPluginUtils.declare((api, options) => {\n  var _api$assumption, _options$allowArrayLi, _api$assumption2;\n\n  api.assertVersion(7);\n  const {\n    useBuiltIns = false\n  } = options;\n  const iterableIsArray = (_api$assumption = api.assumption(\"iterableIsArray\")) != null ? _api$assumption : options.loose;\n  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption(\"arrayLikeIsIterable\");\n  const objectRestNoSymbols = (_api$assumption2 = api.assumption(\"objectRestNoSymbols\")) != null ? _api$assumption2 : options.loose;\n  return {\n    name: \"transform-destructuring\",\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));\n        }\n\n        path.replaceWith(declaration.node);\n        path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));\n      },\n\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const left = node.left;\n\n        if (core.types.isPattern(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n          const statementBody = node.body.body;\n\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            statementBody.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          statementBody.unshift(core.types.expressionStatement(core.types.assignmentExpression(\"=\", left, temp)));\n          return;\n        }\n\n        if (!core.types.isVariableDeclaration(left)) return;\n        const pattern = left.declarations[0].id;\n        if (!core.types.isPattern(pattern)) return;\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, key);\n        path.ensureBlock();\n        const block = node.body;\n        block.body = nodes.concat(block.body);\n      },\n\n      CatchClause({\n        node,\n        scope\n      }) {\n        const pattern = node.param;\n        if (!core.types.isPattern(pattern)) return;\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, ref);\n        node.body.body = nodes.concat(node.body.body);\n      },\n\n      AssignmentExpression(path, state) {\n        if (!core.types.isPattern(path.node.left)) return;\n        convertAssignmentExpression(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);\n      },\n\n      VariableDeclaration(path, state) {\n        const {\n          node,\n          parent\n        } = path;\n        if (core.types.isForXStatement(parent)) return;\n        if (!parent || !path.container) return;\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);\n      }\n\n    }\n  };\n});\n\nexports.default = index;\n//# sourceMappingURL=index.js.map\n"]}