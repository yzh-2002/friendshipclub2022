{"version":3,"sources":["index.js","rewrite-this.js","rewrite-live-references.js","normalize-and-load-metadata.js","get-module-name.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA,ADGA;AGRA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nexports.wrapInterop = wrapInterop;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _rewriteThis = require(\"./rewrite-this\");\n\nvar _rewriteLiveReferences = require(\"./rewrite-live-references\");\n\nvar _normalizeAndLoadMetadata = require(\"./normalize-and-load-metadata\");\n\nvar _getModuleName = require(\"./get-module-name\");\n\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction rewriteModuleStatementsAndPrepareHeader(path, {\n  loose,\n  exportName,\n  strict,\n  allowTopLevelThis,\n  strictMode,\n  noInterop,\n  importInterop = noInterop ? \"none\" : \"babel\",\n  lazy,\n  esNamespaceOnly,\n  constantReexports = loose,\n  enumerableModuleMeta = loose,\n  noIncompleteNsImportDetection\n}) {\n  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);\n\n  _assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly\n  });\n\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n\n  (0, _rewriteLiveReferences.default)(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", directive(directiveLiteral(\"use strict\")));\n    }\n  }\n\n  const headers = [];\n\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));\n  return {\n    meta,\n    headers\n  };\n}\n\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\n\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [expr, booleanLiteral(true)]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\nfunction buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false) {\n  const statements = [];\n  let srcNamespace = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: _template.default.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\n\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\n  const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT = cloneNode(namespace);\n\n    if (importName === \"default\" && metadata.interop === \"node-default\") {} else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));\n    }\n\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\nfunction buildESModuleHeader(metadata, enumerableModuleMeta = false) {\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\n\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\n\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [variableDeclarator(name, valueToNode(exportedVars))])\n  };\n}\n\nfunction buildExportInitializationStatements(programPath, metadata, constantReexports = false, noIncompleteNsImportDetection = false) {\n  const initStatements = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  initStatements.sort(([a], [b]) => {\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n  const results = [];\n\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    const chunkSize = 100;\n\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n            uninitializedExportNames = [];\n          }\n\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n\n      if (uninitializedExportNames.length > 0) {\n        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n      }\n    }\n  }\n\n  return results;\n}\n\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\n\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteThis;\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  numericLiteral,\n  unaryExpression\n} = _t;\n\nfunction rewriteThis(programPath) {\n  (0, _traverse.default)(programPath.node, Object.assign({}, rewriteThisVisitor, {\n    noScope: true\n  }));\n}\n\nconst rewriteThisVisitor = _traverse.default.visitors.merge([_helperEnvironmentVisitor.default, {\n  ThisExpression(path) {\n    path.replaceWith(unaryExpression(\"void\", numericLiteral(0), true));\n  }\n\n}]);","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\n\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction isInType(path) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n\n      case \"ExportSpecifier\":\n        return path.parentPath.parent.exportKind === \"type\";\n\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n\n    }\n  } while (path = path.parentPath);\n}\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]), false);\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = callExpression(identNode, []);\n        return identNode;\n      }\n\n      let namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(`Cannot transform the imported binding \"${localName}\" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);\n      }\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  UpdateExpression(path) {\n    const {\n      scope,\n      seen,\n      imported,\n      exported,\n      requeueInParent,\n      buildImportReference\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const arg = path.get(\"argument\");\n    if (arg.isMemberExpression()) return;\n    const update = path.node;\n\n    if (arg.isIdentifier()) {\n      const localName = arg.node.name;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const exportedNames = exported.get(localName);\n      const importData = imported.get(localName);\n\n      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n        if (importData) {\n          path.replaceWith(assignmentExpression(update.operator[0] + \"=\", buildImportReference(importData, arg.node), buildImportThrow(localName)));\n        } else if (update.prefix) {\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update)));\n        } else {\n          const ref = scope.generateDeclaredUidIdentifier(localName);\n          path.replaceWith(sequenceExpression([assignmentExpression(\"=\", cloneNode(ref), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName)), cloneNode(ref)]));\n        }\n      }\n    }\n\n    requeueInParent(path);\n    path.skip();\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      imported,\n      scope: programScope\n    } = this;\n\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n          importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeModuleAndLoadMetadata;\nexports.hasExports = hasExports;\nexports.isSideEffectImport = isSideEffectImport;\nexports.validateImportInteropOption = validateImportInteropOption;\n\nvar _path = require(\"path\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nfunction hasExports(metadata) {\n  return metadata.hasExports;\n}\n\nfunction isSideEffectImport(source) {\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\n}\n\nfunction validateImportInteropOption(importInterop) {\n  if (typeof importInterop !== \"function\" && importInterop !== \"none\" && importInterop !== \"babel\" && importInterop !== \"node\") {\n    throw new Error(`.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`);\n  }\n\n  return importInterop;\n}\n\nfunction resolveImportInterop(importInterop, source) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source));\n  }\n\n  return importInterop;\n}\n\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, {\n  importInterop,\n  initializeReexports = false,\n  lazy = false,\n  esNamespaceOnly = false\n}) {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n\n  const stringSpecifiers = new Set();\n  nameAnonymousExports(programPath);\n  const {\n    local,\n    source,\n    hasExports\n  } = getModuleMetadata(programPath, {\n    initializeReexports,\n    lazy\n  }, stringSpecifiers);\n  removeModuleDeclarations(programPath);\n\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n\n    const resolvedInterop = resolveImportInterop(importInterop, metadata.source);\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source,\n    stringSpecifiers\n  };\n}\n\nfunction getExportSpecifierName(path, stringSpecifiers) {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);\n  }\n}\n\nfunction assertExportSpecifier(path) {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\");\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\nfunction getModuleMetadata(programPath, {\n  lazy,\n  initializeReexports\n}, stringSpecifiers) {\n  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);\n  const sourceData = new Map();\n\n  const getData = sourceNode => {\n    const source = sourceNode.value;\n    let data = sourceData.get(source);\n\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\n        interop: \"none\",\n        loc: null,\n        imports: new Map(),\n        importsNamespace: new Set(),\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n        lazy: false,\n        source\n      };\n      sourceData.set(source, data);\n    }\n\n    return data;\n  };\n\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, \"default\");\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(spec.get(\"imported\"), stringSpecifiers);\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, importName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      data.reexportAll = {\n        loc: child.node.loc\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(spec.get(\"local\"), stringSpecifiers);\n        const exportName = getExportSpecifierName(spec.get(\"exported\"), stringSpecifiers);\n        data.reexports.set(exportName, importName);\n\n        if (exportName === \"__esModule\") {\n          throw spec.get(\"exported\").buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  for (const [source, metadata] of sourceData) {\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\n      if (lazy === true) {\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData\n  };\n}\n\nfunction getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {\n  const bindingKindLookup = new Map();\n  programPath.get(\"body\").forEach(child => {\n    let kind;\n\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) child = child.get(\"declaration\");\n\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (initializeReexports && child.node.source && child.get(\"source\").isStringLiteral()) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({\n        kind: \"var\"\n      })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n  const localMetadata = new Map();\n\n  const getLocalMetadata = idPath => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\n      }\n\n      metadata = {\n        names: [],\n        kind\n      };\n      localMetadata.set(localName, metadata);\n    }\n\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    }\n  });\n  return localMetadata;\n}\n\nfunction nameAnonymousExports(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    (0, _helperSplitExportDeclaration.default)(child);\n  });\n}\n\nfunction removeModuleDeclarations(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getModuleName;\n{\n  const originalGetModuleName = getModuleName;\n\n  exports.default = getModuleName = function getModuleName(rootOpts, pluginOpts) {\n    var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;\n\n    return originalGetModuleName(rootOpts, {\n      moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,\n      moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,\n      getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,\n      moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot\n    });\n  };\n}\n\nfunction getModuleName(rootOpts, pluginOpts) {\n  const {\n    filename,\n    filenameRelative = filename,\n    sourceRoot = pluginOpts.moduleRoot\n  } = rootOpts;\n  const {\n    moduleId,\n    moduleIds = !!moduleId,\n    getModuleId,\n    moduleRoot = sourceRoot\n  } = pluginOpts;\n  if (!moduleIds) return null;\n\n  if (moduleId != null && !getModuleId) {\n    return moduleId;\n  }\n\n  let moduleName = moduleRoot != null ? moduleRoot + \"/\" : \"\";\n\n  if (filenameRelative) {\n    const sourceRootReplacer = sourceRoot != null ? new RegExp(\"^\" + sourceRoot + \"/?\") : \"\";\n    moduleName += filenameRelative.replace(sourceRootReplacer, \"\").replace(/\\.(\\w*?)$/, \"\");\n  }\n\n  moduleName = moduleName.replace(/\\\\/g, \"/\");\n\n  if (getModuleId) {\n    return getModuleId(moduleName) || moduleName;\n  } else {\n    return moduleName;\n  }\n}"]}