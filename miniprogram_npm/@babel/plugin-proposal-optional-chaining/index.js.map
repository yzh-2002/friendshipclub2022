{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar syntaxOptionalChaining = require('@babel/plugin-syntax-optional-chaining');\nvar core = require('@babel/core');\nvar helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar syntaxOptionalChaining__default = /*#__PURE__*/_interopDefaultLegacy(syntaxOptionalChaining);\n\nfunction willPathCastToBoolean(path) {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    node,\n    parentPath\n  } = maybeWrapped;\n\n  if (parentPath.isLogicalExpression()) {\n    const {\n      operator,\n      right\n    } = parentPath.node;\n\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n\n  if (parentPath.isSequenceExpression()) {\n    const {\n      expressions\n    } = parentPath.node;\n\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\nfunction findOutermostTransparentParent(path) {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n\nconst {\n  ast\n} = core.template.expression;\n\nfunction isSimpleMemberExpression(expression) {\n  expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);\n  return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n}\n\nfunction needsMemoize(path) {\n  let optionalPath = path;\n  const {\n    scope\n  } = path;\n\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    const childKey = optionalPath.isOptionalMemberExpression() ? \"object\" : \"callee\";\n    const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(childKey));\n\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n\n    optionalPath = childPath;\n  }\n}\n\nfunction transform(path, {\n  pureGetters,\n  noDocumentAll\n}) {\n  const {\n    scope\n  } = path;\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    parentPath\n  } = maybeWrapped;\n  const willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);\n  let isDeleteOperation = false;\n  const parentIsCall = parentPath.isCallExpression({\n    callee: maybeWrapped.node\n  }) && path.isOptionalMemberExpression();\n  const optionals = [];\n  let optionalPath = path;\n\n  if (scope.path.isPattern() && needsMemoize(optionalPath)) {\n    path.replaceWith(core.template.ast`(() => ${path.node})()`);\n    return;\n  }\n\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n\n    if (node.optional) {\n      optionals.push(node);\n    }\n\n    if (optionalPath.isOptionalMemberExpression()) {\n      optionalPath.node.type = \"MemberExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      optionalPath.node.type = \"CallExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n\n  let replacementPath = path;\n\n  if (parentPath.isUnaryExpression({\n    operator: \"delete\"\n  })) {\n    replacementPath = parentPath;\n    isDeleteOperation = true;\n  }\n\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i];\n    const isCall = core.types.isCallExpression(node);\n    const replaceKey = isCall ? \"callee\" : \"object\";\n    const chainWithTypes = node[replaceKey];\n    const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);\n    let ref;\n    let check;\n\n    if (isCall && core.types.isIdentifier(chain, {\n      name: \"eval\"\n    })) {\n      check = ref = chain;\n      node[replaceKey] = core.types.sequenceExpression([core.types.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      check = ref = chainWithTypes;\n    } else {\n      ref = scope.maybeGenerateMemoised(chain);\n\n      if (ref) {\n        check = core.types.assignmentExpression(\"=\", core.types.cloneNode(ref), chainWithTypes);\n        node[replaceKey] = ref;\n      } else {\n        check = ref = chainWithTypes;\n      }\n    }\n\n    if (isCall && core.types.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        node.callee = chainWithTypes;\n      } else {\n        const {\n          object\n        } = chain;\n        let context = scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          chain.object = core.types.assignmentExpression(\"=\", context, object);\n        } else if (core.types.isSuper(object)) {\n          context = core.types.thisExpression();\n        } else {\n          context = object;\n        }\n\n        node.arguments.unshift(core.types.cloneNode(context));\n        node.callee = core.types.memberExpression(node.callee, core.types.identifier(\"call\"));\n      }\n    }\n\n    let replacement = replacementPath.node;\n\n    if (i === 0 && parentIsCall) {\n      var _baseRef;\n\n      const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);\n      let baseRef;\n\n      if (!pureGetters || !isSimpleMemberExpression(object)) {\n        baseRef = scope.maybeGenerateMemoised(object);\n\n        if (baseRef) {\n          replacement.object = core.types.assignmentExpression(\"=\", baseRef, object);\n        }\n      }\n\n      replacement = core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier(\"bind\")), [core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)]);\n    }\n\n    if (willReplacementCastToBoolean) {\n      const nonNullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} != null` : ast`\n            ${core.types.cloneNode(check)} !== null && ${core.types.cloneNode(ref)} !== void 0`;\n      replacementPath.replaceWith(core.types.logicalExpression(\"&&\", nonNullishCheck, replacement));\n      replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get(\"right\"));\n    } else {\n      const nullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} == null` : ast`\n            ${core.types.cloneNode(check)} === null || ${core.types.cloneNode(ref)} === void 0`;\n      const returnValue = isDeleteOperation ? ast`true` : ast`void 0`;\n      replacementPath.replaceWith(core.types.conditionalExpression(nullishCheck, returnValue, replacement));\n      replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get(\"alternate\"));\n    }\n  }\n}\n\nvar index = helperPluginUtils.declare((api, options) => {\n  var _api$assumption, _api$assumption2;\n\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n  const noDocumentAll = (_api$assumption = api.assumption(\"noDocumentAll\")) != null ? _api$assumption : loose;\n  const pureGetters = (_api$assumption2 = api.assumption(\"pureGetters\")) != null ? _api$assumption2 : loose;\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: syntaxOptionalChaining__default['default'].default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        transform(path, {\n          noDocumentAll,\n          pureGetters\n        });\n      }\n\n    }\n  };\n});\n\nexports.default = index;\nexports.transform = transform;\n//# sourceMappingURL=index.js.map\n"]}