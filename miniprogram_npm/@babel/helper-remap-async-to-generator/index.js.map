{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _helperWrapFunction = require(\"@babel/helper-wrap-function\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  callExpression,\n  cloneNode,\n  isIdentifier,\n  isThisExpression,\n  yieldExpression\n} = _t;\nconst awaitVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  AwaitExpression(path, {\n    wrapAwait\n  }) {\n    const argument = path.get(\"argument\");\n    path.replaceWith(yieldExpression(wrapAwait ? callExpression(cloneNode(wrapAwait), [argument.node]) : argument.node));\n  }\n\n};\n\nfunction _default(path, helpers, noNewArrows, ignoreFunctionLength) {\n  path.traverse(awaitVisitor, {\n    wrapAwait: helpers.wrapAwait\n  });\n  const isIIFE = checkIsIIFE(path);\n  path.node.async = false;\n  path.node.generator = true;\n  (0, _helperWrapFunction.default)(path, cloneNode(helpers.wrapAsync), noNewArrows, ignoreFunctionLength);\n  const isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();\n\n  if (!isProperty && !isIIFE && path.isExpression()) {\n    (0, _helperAnnotateAsPure.default)(path);\n  }\n\n  function checkIsIIFE(path) {\n    if (path.parentPath.isCallExpression({\n      callee: path.node\n    })) {\n      return true;\n    }\n\n    const {\n      parentPath\n    } = path;\n\n    if (parentPath.isMemberExpression() && isIdentifier(parentPath.node.property, {\n      name: \"bind\"\n    })) {\n      const {\n        parentPath: bindCall\n      } = parentPath;\n      return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({\n        callee: bindCall.node\n      });\n    }\n\n    return false;\n  }\n}"]}