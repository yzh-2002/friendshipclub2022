{"version":3,"sources":["index.js","nodeWrapper.js","node.js","hook.js","worker-client.js","is-in-register-worker.js","worker/handle-message.js","worker/babel-core.js","worker/transform.js","cache.js","worker/cache.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,AENA,AHSA,ADGA,AGTA;ADIA,AENA,AHSA,ADGA,AGTA;ADIA,AENA,AHSA,ADGA,AGTA;ADIA,AENA,AHSA,ADGA,AGTA,AENA;AHUA,AENA,AHSA,AENA,AENA;AHUA,AENA,AHSA,AENA,AENA;AHUA,AENA,AHSA,AENA,AGTA,ADGA;AHUA,AENA,AHSA,AENA,AGTA,ADGA;AHUA,AENA,AHSA,AENA,AGTA,ADGA;AHUA,AENA,ADGA,AGTA,ADGA,AENA;ALgBA,ACHA,AGTA,ADGA,AENA;ALgBA,ACHA,AGTA,ADGA,AENA;ACFA,ANkBA,ACHA,AGTA,ADGA,AENA;ALgBA,ACHA,AGTA,ADGA,AENA;ALgBA,ACHA,AGTA,ADGA,AENA;ALgBA,ACHA,AGTA,AGTA,AJYA,AENA;ALgBA,ACHA,AGTA,AGTA,AJYA,AENA;ALgBA,ACHA,AGTA,AGTA,AJYA,AENA;ALgBA,ACHA,AGTA,AGTA,AJYA,AENA;ALgBA,ACHA,AGTA,AGTA,AJYA,AENA;ALgBA,ACHA,AGTA,AGTA,AJYA,AENA;ALgBA,ACHA,AGTA,AGTA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AJYA,AENA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;ALgBA,ACHA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["{\n  exports = module.exports = function (...args) {\n    return register(...args);\n  };\n\n  exports.__esModule = true;\n\n  const node = require(\"./nodeWrapper\");\n\n  const register = node.default;\n  Object.assign(exports, node);\n}","const Module = require(\"module\");\n\nconst globalModuleCache = Module._cache;\nconst internalModuleCache = Object.create(null);\nModule._cache = internalModuleCache;\n\nconst node = require(\"./node\");\n\nModule._cache = globalModuleCache;\n\nconst smsPath = require.resolve(\"source-map-support\");\n\nglobalModuleCache[smsPath] = internalModuleCache[smsPath];\nconst register = node.default;\nregister();\nmodule.exports = node;","\n\nconst hook = require(\"./hook\");\n\nconst {\n  LocalClient\n} = require(\"./worker-client\");\n\nconst client = new LocalClient();\n\nfunction register(opts = {}) {\n  return hook.register(client, Object.assign({}, opts));\n}\n\nmodule.exports = Object.assign(register, {\n  revert: hook.revert,\n  default: register\n});","\n\nconst {\n  addHook\n} = require(\"pirates\");\n\nconst sourceMapSupport = require(\"source-map-support\");\n\nlet piratesRevert;\nconst maps = Object.create(null);\n\nfunction installSourceMapSupport() {\n  installSourceMapSupport = () => {};\n\n  sourceMapSupport.install({\n    handleUncaughtExceptions: false,\n    environment: \"node\",\n\n    retrieveSourceMap(filename) {\n      const map = maps == null ? void 0 : maps[filename];\n\n      if (map) {\n        return {\n          url: null,\n          map: map\n        };\n      } else {\n        return null;\n      }\n    }\n\n  });\n}\n\n{\n  const Module = require(\"module\");\n\n  let compiling = false;\n  const internalModuleCache = Module._cache;\n\n  var compileBabel7 = function compileBabel7(client, code, filename) {\n    if (!client.isLocalClient) return compile(client, code, filename);\n    if (compiling) return code;\n    const globalModuleCache = Module._cache;\n\n    try {\n      compiling = true;\n      Module._cache = internalModuleCache;\n      return compile(client, code, filename);\n    } finally {\n      compiling = false;\n      Module._cache = globalModuleCache;\n    }\n  };\n}\n\nfunction compile(client, inputCode, filename) {\n  const result = client.transform(inputCode, filename);\n  if (result === null) return inputCode;\n  const {\n    code,\n    map\n  } = result;\n\n  if (map) {\n    maps[filename] = map;\n    installSourceMapSupport();\n  }\n\n  return code;\n}\n\nexports.register = function register(client, opts = {}) {\n  var _opts$extensions;\n\n  if (piratesRevert) piratesRevert();\n  piratesRevert = addHook(compileBabel7.bind(null, client), {\n    exts: (_opts$extensions = opts.extensions) != null ? _opts$extensions : client.getDefaultExtensions(),\n    ignoreNodeModules: false\n  });\n  client.setOptions(opts);\n};\n\nexports.revert = function revert() {\n  if (piratesRevert) piratesRevert();\n};","var _class, _worker, _signal, _temp, _markInRegisterWorker, _worker_threads;\n\nfunction _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) { _classCheckPrivateStaticAccess(receiver, classConstructor); _classCheckPrivateStaticFieldDescriptor(descriptor, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\n\nfunction _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) { _classCheckPrivateStaticAccess(receiver, classConstructor); _classCheckPrivateStaticFieldDescriptor(descriptor, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\n\nfunction _classCheckPrivateStaticFieldDescriptor(descriptor, action) { if (descriptor === undefined) { throw new TypeError(\"attempted to \" + action + \" private static field before its declaration\"); } }\n\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError(\"Private static access of wrong provenance\"); } }\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\n\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n\nconst path = require(\"path\");\n\nconst ACTIONS = {\n  GET_DEFAULT_EXTENSIONS: \"GET_DEFAULT_EXTENSIONS\",\n  SET_OPTIONS: \"SET_OPTIONS\",\n  TRANSFORM: \"TRANSFORM\",\n  TRANSFORM_SYNC: \"TRANSFORM_SYNC\"\n};\n\nvar _send = new WeakMap();\n\nvar _eCache = new WeakMap();\n\nclass Client {\n  constructor(send) {\n    _classPrivateFieldInitSpec(this, _send, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _eCache, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(this, _send, send);\n  }\n\n  getDefaultExtensions() {\n    var _classPrivateFieldGet2;\n\n    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _eCache)) != null ? _classPrivateFieldGet2 : _classPrivateFieldSet(this, _eCache, _classPrivateFieldGet(this, _send).call(this, ACTIONS.GET_DEFAULT_EXTENSIONS, undefined));\n  }\n\n  setOptions(options) {\n    return _classPrivateFieldGet(this, _send).call(this, ACTIONS.SET_OPTIONS, options);\n  }\n\n  transform(code, filename) {\n    return _classPrivateFieldGet(this, _send).call(this, ACTIONS.TRANSFORM, {\n      code,\n      filename\n    });\n  }\n\n}\n\nexports.WorkerClient = (_temp = (_worker = new WeakMap(), _signal = new WeakMap(), _class = class WorkerClient extends Client {\n  constructor() {\n    super((action, payload) => {\n      _classPrivateFieldGet(this, _signal)[0] = 0;\n      const subChannel = new (_classStaticPrivateFieldSpecGet(WorkerClient, _class, _worker_threads).MessageChannel)();\n\n      _classPrivateFieldGet(this, _worker).postMessage({\n        signal: _classPrivateFieldGet(this, _signal),\n        port: subChannel.port1,\n        action,\n        payload\n      }, [subChannel.port1]);\n\n      Atomics.wait(_classPrivateFieldGet(this, _signal), 0, 0);\n\n      const {\n        message\n      } = _classStaticPrivateFieldSpecGet(WorkerClient, _class, _worker_threads).receiveMessageOnPort(subChannel.port2);\n\n      if (message.error) throw Object.assign(message.error, message.errorData);else return message.result;\n    });\n\n    _classPrivateFieldInitSpec(this, _worker, {\n      writable: true,\n      value: new (_classStaticPrivateFieldSpecGet(WorkerClient, _class, _worker_threads).Worker)(path.resolve(__dirname, \"./worker/index.js\"), {\n        env: _classStaticPrivateFieldSpecGet(WorkerClient, _class, _markInRegisterWorker).call(WorkerClient, process.env)\n      })\n    });\n\n    _classPrivateFieldInitSpec(this, _signal, {\n      writable: true,\n      value: new Int32Array(new SharedArrayBuffer(4))\n    });\n\n    _classPrivateFieldGet(this, _worker).unref();\n  }\n\n}), _markInRegisterWorker = {\n  get: _get_markInRegisterWorker,\n  set: void 0\n}, _worker_threads = {\n  get: _get_worker_threads,\n  set: void 0\n}, _temp);\n\nfunction _get_worker_threads() {\n  return require(\"worker_threads\");\n}\n\nfunction _get_markInRegisterWorker() {\n  return require(\"./is-in-register-worker\").markInRegisterWorker;\n}\n\n{\n  var _class2, _temp2, _handleMessage;\n\n  exports.LocalClient = (_temp2 = _class2 = class LocalClient extends Client {\n    constructor() {\n      var _classStaticPrivateFi;\n\n      (_classStaticPrivateFi = _classStaticPrivateFieldSpecGet(LocalClient, _class2, _handleMessage)) != null ? _classStaticPrivateFi : _classStaticPrivateFieldSpecSet(LocalClient, _class2, _handleMessage, require(\"./worker/handle-message\"));\n      super((action, payload) => {\n        return _classStaticPrivateFieldSpecGet(LocalClient, _class2, _handleMessage).call(LocalClient, action === ACTIONS.TRANSFORM ? ACTIONS.TRANSFORM_SYNC : action, payload);\n      });\n      this.isLocalClient = true;\n    }\n\n  }, _handleMessage = {\n    writable: true,\n    value: void 0\n  }, _temp2);\n}","\n\nconst envVarName = \"___INTERNAL___IS_INSIDE_BABEL_REGISTER_WORKER___\";\nconst envVarValue = \"yes_I_am\";\n\nexports.markInRegisterWorker = env => Object.assign({}, env, {\n  [envVarName]: envVarValue\n});\n\nexports.isInRegisterWorker = process.env[envVarName] === envVarValue;","const babel = require(\"./babel-core\");\n\nconst {\n  setOptions,\n  transform,\n  transformSync\n} = require(\"./transform\");\n\nmodule.exports = function handleMessage(action, payload) {\n  switch (action) {\n    case \"GET_DEFAULT_EXTENSIONS\":\n      return babel.DEFAULT_EXTENSIONS;\n\n    case \"SET_OPTIONS\":\n      setOptions(payload);\n      return;\n\n    case \"TRANSFORM\":\n      return transform(payload.code, payload.filename);\n\n    case \"TRANSFORM_SYNC\":\n      {\n        return transformSync(payload.code, payload.filename);\n      }\n  }\n\n  throw new Error(`Unknown internal parser worker action: ${action}`);\n};","function initialize(babel) {\n  exports.init = null;\n  exports.version = babel.version;\n  exports.DEFAULT_EXTENSIONS = babel.DEFAULT_EXTENSIONS;\n  exports.loadOptionsAsync = babel.loadOptionsAsync;\n  exports.transformAsync = babel.transformAsync;\n  exports.getEnv = babel.getEnv;\n  {\n    exports.OptionManager = babel.OptionManager;\n    exports.transformSync = babel.transformSync;\n  }\n}\n\n{\n  initialize(require(\"@babel/core\"));\n}","\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nconst cloneDeep = require(\"clone-deep\");\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst babel = require(\"./babel-core\");\n\nconst registerCache = require(\"../cache\");\n\nconst nmRE = escapeRegExp(path.sep + \"node_modules\" + path.sep);\n\nfunction escapeRegExp(string) {\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n}\n\nlet cache;\nlet transformOpts;\n\nexports.setOptions = function (opts) {\n  if (opts.cache === false && cache) {\n    registerCache.clear();\n    cache = null;\n  } else if (opts.cache !== false && !cache) {\n    registerCache.load();\n    cache = registerCache.get();\n  }\n\n  delete opts.cache;\n  delete opts.extensions;\n  transformOpts = Object.assign({}, opts, {\n    caller: Object.assign({\n      name: \"@babel/register\"\n    }, opts.caller || {})\n  });\n  let {\n    cwd = \".\"\n  } = transformOpts;\n  cwd = transformOpts.cwd = path.resolve(cwd);\n\n  if (transformOpts.ignore === undefined && transformOpts.only === undefined) {\n    const cwdRE = escapeRegExp(cwd);\n    transformOpts.only = [new RegExp(\"^\" + cwdRE, \"i\")];\n    transformOpts.ignore = [new RegExp(`^${cwdRE}(?:${path.sep}.*)?${nmRE}`, \"i\")];\n  }\n};\n\nexports.transform = _asyncToGenerator(function* (input, filename) {\n  const opts = yield babel.loadOptionsAsync(Object.assign({\n    sourceRoot: path.dirname(filename) + path.sep\n  }, cloneDeep(transformOpts), {\n    filename\n  }));\n  if (opts === null) return null;\n  const {\n    cached,\n    store\n  } = cacheLookup(opts, filename);\n  if (cached) return cached;\n  const {\n    code,\n    map\n  } = yield babel.transformAsync(input, Object.assign({}, opts, {\n    sourceMaps: opts.sourceMaps === undefined ? \"both\" : opts.sourceMaps,\n    ast: false\n  }));\n  return store({\n    code,\n    map\n  });\n});\n{\n  exports.transformSync = function (input, filename) {\n    const opts = new babel.OptionManager().init(Object.assign({\n      sourceRoot: path.dirname(filename) + path.sep\n    }, cloneDeep(transformOpts), {\n      filename\n    }));\n    if (opts === null) return null;\n    const {\n      cached,\n      store\n    } = cacheLookup(opts, filename);\n    if (cached) return cached;\n    const {\n      code,\n      map\n    } = babel.transformSync(input, Object.assign({}, opts, {\n      sourceMaps: opts.sourceMaps === undefined ? \"both\" : opts.sourceMaps,\n      ast: false\n    }));\n    return store({\n      code,\n      map\n    });\n  };\n}\n\nconst id = value => value;\n\nfunction cacheLookup(opts, filename) {\n  if (!cache) return {\n    cached: null,\n    store: id\n  };\n  let cacheKey = `${JSON.stringify(opts)}:${babel.version}`;\n  const env = babel.getEnv();\n  if (env) cacheKey += `:${env}`;\n  const cached = cache[cacheKey];\n  const fileMtime = +fs.statSync(filename).mtime;\n\n  if (cached && cached.mtime === fileMtime) {\n    return {\n      cached: cached.value,\n      store: id\n    };\n  }\n\n  return {\n    cached: null,\n\n    store(value) {\n      cache[cacheKey] = {\n        value,\n        mtime: fileMtime\n      };\n      registerCache.setDirty();\n      return value;\n    }\n\n  };\n}","module.exports = require(\"./worker/cache\");","\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst os = require(\"os\");\n\nconst babel = require(\"@babel/core\");\n\nconst findCacheDir = require(\"find-cache-dir\");\n\nconst DEFAULT_CACHE_DIR = findCacheDir({\n  name: \"@babel/register\"\n}) || os.homedir() || os.tmpdir();\nconst DEFAULT_FILENAME = path.join(DEFAULT_CACHE_DIR, `.babel.${babel.version}.${babel.getEnv()}.json`);\nconst FILENAME = process.env.BABEL_CACHE_PATH || DEFAULT_FILENAME;\nlet data = {};\nlet cacheDirty = false;\nlet cacheDisabled = false;\n\nfunction isCacheDisabled() {\n  var _process$env$BABEL_DI;\n\n  return (_process$env$BABEL_DI = process.env.BABEL_DISABLE_CACHE) != null ? _process$env$BABEL_DI : cacheDisabled;\n}\n\nexports.save = save;\n\nfunction save() {\n  if (isCacheDisabled() || !cacheDirty) return;\n  cacheDirty = false;\n  let serialised = \"{}\";\n\n  try {\n    serialised = JSON.stringify(data);\n  } catch (err) {\n    if (err.message === \"Invalid string length\") {\n      err.message = \"Cache too large so it's been cleared.\";\n      console.error(err.stack);\n    } else {\n      throw err;\n    }\n  }\n\n  try {\n    (((v, w) => (v = v.split(\".\"), w = w.split(\".\"), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, \"10.12\") ? fs.mkdirSync : require(\"make-dir\").sync)(path.dirname(FILENAME), {\n      recursive: true\n    });\n    fs.writeFileSync(FILENAME, serialised);\n  } catch (e) {\n    switch (e.code) {\n      case \"ENOENT\":\n      case \"EACCES\":\n      case \"EPERM\":\n        console.warn(`Babel could not write cache to file: ${FILENAME}\ndue to a permission issue. Cache is disabled.`);\n        cacheDisabled = true;\n        break;\n\n      case \"EROFS\":\n        console.warn(`Babel could not write cache to file: ${FILENAME}\nbecause it resides in a readonly filesystem. Cache is disabled.`);\n        cacheDisabled = true;\n        break;\n\n      default:\n        throw e;\n    }\n  }\n}\n\nexports.load = function load() {\n  if (isCacheDisabled()) {\n    data = {};\n    return;\n  }\n\n  process.on(\"exit\", save);\n  process.nextTick(save);\n  let cacheContent;\n\n  try {\n    cacheContent = fs.readFileSync(FILENAME);\n  } catch (e) {\n    switch (e.code) {\n      case \"EACCES\":\n        console.warn(`Babel could not read cache file: ${FILENAME}\ndue to a permission issue. Cache is disabled.`);\n        cacheDisabled = true;\n\n      default:\n        return;\n    }\n  }\n\n  try {\n    data = JSON.parse(cacheContent);\n  } catch (_unused) {}\n};\n\nexports.get = function get() {\n  return data;\n};\n\nexports.setDirty = function setDirty() {\n  cacheDirty = true;\n};\n\nexports.clear = function clear() {\n  data = {};\n};"]}