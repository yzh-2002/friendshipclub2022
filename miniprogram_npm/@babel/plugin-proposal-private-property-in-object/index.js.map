{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxPrivatePropertyInObject = require(\"@babel/plugin-syntax-private-property-in-object\");\n\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nvar _default = (0, _helperPluginUtils.declare)(({\n  assertVersion,\n  types: t,\n  template\n}, {\n  loose\n}) => {\n  assertVersion(7);\n  const classWeakSets = new WeakMap();\n  const fieldsWeakSets = new WeakMap();\n\n  function unshadow(name, targetScope, scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n\n  function injectToFieldInit(fieldPath, expr, before = false) {\n    if (fieldPath.node.value) {\n      if (before) {\n        fieldPath.get(\"value\").insertBefore(expr);\n      } else {\n        fieldPath.get(\"value\").insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n\n  function injectInitialization(classPath, init) {\n    let firstFieldPath;\n    let consturctorPath;\n\n    for (const el of classPath.get(\"body.body\")) {\n      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {\n        firstFieldPath = el;\n        break;\n      }\n\n      if (!consturctorPath && el.isClassMethod({\n        kind: \"constructor\"\n      })) {\n        consturctorPath = el;\n      }\n    }\n\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, consturctorPath, [t.expressionStatement(init)]);\n    }\n  }\n\n  function getWeakSetId(weakSets, outerClass, reference, name = \"\", inject) {\n    let id = classWeakSets.get(reference.node);\n\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      classWeakSets.set(reference.node, id);\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      (0, _helperAnnotateAsPure.default)(newExpr);\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n\n    return t.cloneNode(id);\n  }\n\n  return {\n    name: \"proposal-private-property-in-object\",\n    inherits: _pluginSyntaxPrivatePropertyInObject.default,\n\n    pre() {\n      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);\n    },\n\n    visitor: {\n      BinaryExpression(path) {\n        const {\n          node\n        } = path;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n        const {\n          name\n        } = node.left.id;\n        let privateElement;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n          privateElement = path.get(\"body.body\").find(({\n            node\n          }) => t.isPrivate(node) && node.key.id.name === name);\n          return !!privateElement;\n        });\n\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);\n          return;\n        }\n\n        if (privateElement.isMethod()) {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n\n            path.replaceWith(template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${path.node.right}\n              `);\n          } else {\n            var _outerClass$node$id;\n\n            const id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization);\n            path.replaceWith(template.expression.ast`${id}.has(${path.node.right})`);\n          }\n        } else {\n          const id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);\n          path.replaceWith(template.expression.ast`${id}.has(${path.node.right})`);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}