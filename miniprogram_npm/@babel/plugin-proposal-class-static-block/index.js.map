{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxClassStaticBlock = require(\"@babel/plugin-syntax-class-static-block\");\n\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\n\nfunction generateUid(scope, denyList) {\n  const name = \"\";\n  let uid;\n  let i = 1;\n\n  do {\n    uid = scope._generateUid(name, i);\n    i++;\n  } while (denyList.has(uid));\n\n  return uid;\n}\n\nvar _default = (0, _helperPluginUtils.declare)(({\n  types: t,\n  template,\n  assertVersion\n}) => {\n  assertVersion(\"^7.12.0\");\n  return {\n    name: \"proposal-class-static-block\",\n    inherits: _pluginSyntaxClassStaticBlock.default,\n\n    pre() {\n      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.staticBlocks, false);\n    },\n\n    visitor: {\n      ClassBody(classBody) {\n        const {\n          scope\n        } = classBody;\n        const privateNames = new Set();\n        const body = classBody.get(\"body\");\n\n        for (const path of body) {\n          if (path.isPrivate()) {\n            privateNames.add(path.get(\"key.id\").node.name);\n          }\n        }\n\n        for (const path of body) {\n          if (!path.isStaticBlock()) continue;\n          const staticBlockPrivateId = generateUid(scope, privateNames);\n          privateNames.add(staticBlockPrivateId);\n          const staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));\n          let replacement;\n          const blockBody = path.node.body;\n\n          if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {\n            replacement = blockBody[0].expression;\n          } else {\n            replacement = template.expression.ast`(() => { ${blockBody} })()`;\n          }\n\n          path.replaceWith(t.classPrivateProperty(staticBlockRef, replacement, [], true));\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}