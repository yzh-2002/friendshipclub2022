{"version":3,"sources":["index.js","utils.js","imports-cache.js","debug-utils.js","normalize-options.js","visitors/index.js","visitors/usage.js","visitors/entry.js","node/dependencies.js","meta-resolver.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ADGA,AFMA,AIZA,AHSA;AELA,ADGA,AFMA,AIZA,AHSA;AELA,ADGA,AFMA,AIZA,AHSA;AELA,ADGA,AFMA,AIZA,AHSA,AIZA;AFOA,ADGA,AFMA,AIZA,AHSA,AIZA;AFOA,ADGA,AFMA,AIZA,AHSA,AIZA;AFOA,ADGA,AFMA,AIZA,AHSA,AIZA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AIZA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AIZA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AMlBA,AFMA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AMlBA,AFMA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AMlBA,AFMA,ACHA;AHUA,ADGA,AFMA,AQxBA,AJYA,AHSA,AMlBA,AFMA,ACHA;AHUA,ADGA,AFMA,AQxBA,AJYA,AHSA,AMlBA,AFMA,ACHA;AHUA,ADGA,AFMA,AQxBA,AJYA,AHSA,AMlBA,AFMA,ACHA;AHUA,ADGA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,AFMA,ACHA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,AFMA,ACHA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\nexports.default = definePolyfillProvider;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperCompilationTargets = _interopRequireWildcard(require(\"@babel/helper-compilation-targets\"));\n\nvar _utils = require(\"./utils\");\n\nvar _importsCache = _interopRequireDefault(require(\"./imports-cache\"));\n\nvar _debugUtils = require(\"./debug-utils\");\n\nvar _normalizeOptions = require(\"./normalize-options\");\n\nvar v = _interopRequireWildcard(require(\"./visitors\"));\n\nvar deps = _interopRequireWildcard(require(\"./node/dependencies\"));\n\nvar _metaResolver = _interopRequireDefault(require(\"./meta-resolver\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst getTargets = _helperCompilationTargets.default.default || _helperCompilationTargets.default;\n\nfunction resolveOptions(options, babelApi) {\n  const {\n    method,\n    targets: targetsOption,\n    ignoreBrowserslistConfig,\n    configPath,\n    debug,\n    shouldInjectPolyfill,\n    absoluteImports\n  } = options,\n        providerOptions = _objectWithoutPropertiesLoose(options, [\"method\", \"targets\", \"ignoreBrowserslistConfig\", \"configPath\", \"debug\", \"shouldInjectPolyfill\", \"absoluteImports\"]);\n\n  let methodName;\n  if (method === \"usage-global\") methodName = \"usageGlobal\";else if (method === \"entry-global\") methodName = \"entryGlobal\";else if (method === \"usage-pure\") methodName = \"usagePure\";else if (typeof method !== \"string\") {\n    throw new Error(\".method must be a string\");\n  } else {\n    throw new Error(`.method must be one of \"entry-global\", \"usage-global\"` + ` or \"usage-pure\" (received ${JSON.stringify(method)})`);\n  }\n\n  if (typeof shouldInjectPolyfill === \"function\") {\n    if (options.include || options.exclude) {\n      throw new Error(`.include and .exclude are not supported when using the` + ` .shouldInjectPolyfill function.`);\n    }\n  } else if (shouldInjectPolyfill != null) {\n    throw new Error(`.shouldInjectPolyfill must be a function, or undefined` + ` (received ${JSON.stringify(shouldInjectPolyfill)})`);\n  }\n\n  if (absoluteImports != null && typeof absoluteImports !== \"boolean\" && typeof absoluteImports !== \"string\") {\n    throw new Error(`.absoluteImports must be a boolean, a string, or undefined` + ` (received ${JSON.stringify(absoluteImports)})`);\n  }\n\n  let targets;\n\n  if ( // If any browserslist-related option is specified, fallback to the old\n  // behavior of not using the targets specified in the top-level options.\n  targetsOption || configPath || ignoreBrowserslistConfig) {\n    const targetsObj = typeof targetsOption === \"string\" || Array.isArray(targetsOption) ? {\n      browsers: targetsOption\n    } : targetsOption;\n    targets = getTargets(targetsObj, {\n      ignoreBrowserslistConfig,\n      configPath\n    });\n  } else {\n    targets = babelApi.targets();\n  }\n\n  return {\n    method,\n    methodName,\n    targets,\n    absoluteImports: absoluteImports != null ? absoluteImports : false,\n    shouldInjectPolyfill,\n    debug: !!debug,\n    providerOptions: providerOptions\n  };\n}\n\nfunction instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {\n  const {\n    method,\n    methodName,\n    targets,\n    debug,\n    shouldInjectPolyfill,\n    providerOptions,\n    absoluteImports\n  } = resolveOptions(options, babelApi);\n  const getUtils = (0, _utils.createUtilsGetter)(new _importsCache.default(moduleName => deps.resolve(dirname, moduleName, absoluteImports))); // eslint-disable-next-line prefer-const\n\n  let include, exclude;\n  let polyfillsSupport;\n  let polyfillsNames;\n  let filterPolyfills;\n  const depsCache = new Map();\n  const api = {\n    babel: babelApi,\n    getUtils,\n    method: options.method,\n    targets,\n    createMetaResolver: _metaResolver.default,\n\n    shouldInjectPolyfill(name) {\n      if (polyfillsNames === undefined) {\n        throw new Error(`Internal error in the ${factory.name} provider: ` + `shouldInjectPolyfill() can't be called during initialization.`);\n      }\n\n      if (!polyfillsNames.has(name)) {\n        console.warn(`Internal error in the ${provider.name} provider: ` + `unknown polyfill \"${name}\".`);\n      }\n\n      if (filterPolyfills && !filterPolyfills(name)) return false;\n      let shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {\n        compatData: polyfillsSupport,\n        includes: include,\n        excludes: exclude\n      });\n\n      if (shouldInjectPolyfill) {\n        shouldInject = shouldInjectPolyfill(name, shouldInject);\n\n        if (typeof shouldInject !== \"boolean\") {\n          throw new Error(`.shouldInjectPolyfill must return a boolean.`);\n        }\n      }\n\n      return shouldInject;\n    },\n\n    debug(name) {\n      debugLog().found = true;\n      if (!debug || !name) return;\n      if (debugLog().polyfills.has(provider.name)) return;\n      debugLog().polyfills.set(name, polyfillsSupport && name && polyfillsSupport[name]);\n    },\n\n    assertDependency(name, version = \"*\") {\n      if (missingDependencies === false) return;\n\n      if (absoluteImports) {\n        // If absoluteImports is not false, we will try resolving\n        // the dependency and throw if it's not possible. We can\n        // skip the check here.\n        return;\n      }\n\n      const dep = version === \"*\" ? name : `${name}@^${version}`;\n      const found = missingDependencies.all ? false : mapGetOr(depsCache, `${name} :: ${dirname}`, () => deps.has(dirname, name));\n\n      if (!found) {\n        debugLog().missingDeps.add(dep);\n      }\n    }\n\n  };\n  const provider = factory(api, providerOptions, dirname);\n\n  if (typeof provider[methodName] !== \"function\") {\n    throw new Error(`The \"${provider.name || factory.name}\" provider doesn't ` + `support the \"${method}\" polyfilling method.`);\n  }\n\n  if (Array.isArray(provider.polyfills)) {\n    polyfillsNames = new Set(provider.polyfills);\n    filterPolyfills = provider.filterPolyfills;\n  } else if (provider.polyfills) {\n    polyfillsNames = new Set(Object.keys(provider.polyfills));\n    polyfillsSupport = provider.polyfills;\n    filterPolyfills = provider.filterPolyfills;\n  } else {\n    polyfillsNames = new Set();\n  }\n\n  ({\n    include,\n    exclude\n  } = (0, _normalizeOptions.validateIncludeExclude)(provider.name || factory.name, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []));\n  return {\n    debug,\n    method,\n    targets,\n    provider,\n\n    callProvider(payload, path) {\n      const utils = getUtils(path); // $FlowIgnore\n\n      provider[methodName](payload, utils, path);\n    }\n\n  };\n}\n\nfunction definePolyfillProvider(factory) {\n  return (0, _helperPluginUtils.declare)((babelApi, options, dirname) => {\n    babelApi.assertVersion(7);\n    const {\n      traverse\n    } = babelApi;\n    let debugLog;\n    const missingDependencies = (0, _normalizeOptions.applyMissingDependenciesDefaults)(options, babelApi);\n    const {\n      debug,\n      method,\n      targets,\n      provider,\n      callProvider\n    } = instantiateProvider(factory, options, missingDependencies, dirname, () => debugLog, babelApi);\n    const createVisitor = method === \"entry-global\" ? v.entry : v.usage;\n    const visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);\n\n    if (debug && debug !== _debugUtils.presetEnvSilentDebugHeader) {\n      console.log(`${provider.name}: \\`DEBUG\\` option`);\n      console.log(`\\nUsing targets: ${(0, _debugUtils.stringifyTargetsMultiline)(targets)}`);\n      console.log(`\\nUsing polyfills with \\`${method}\\` method:`);\n    }\n\n    return {\n      name: \"inject-polyfills\",\n      visitor,\n\n      pre() {\n        var _provider$pre;\n\n        debugLog = {\n          polyfills: new Map(),\n          found: false,\n          providers: new Set(),\n          missingDeps: new Set()\n        }; // $FlowIgnore - Flow doesn't support optional calls\n\n        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);\n      },\n\n      post() {\n        var _provider$post;\n\n        // $FlowIgnore - Flow doesn't support optional calls\n        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);\n\n        if (missingDependencies !== false) {\n          if (missingDependencies.log === \"per-file\") {\n            deps.logMissing(debugLog.missingDeps);\n          } else {\n            deps.laterLogMissing(debugLog.missingDeps);\n          }\n        }\n\n        if (!debug) return;\n        if (this.filename) console.log(`\\n[${this.filename}]`);\n\n        if (debugLog.polyfills.size === 0) {\n          console.log(method === \"entry-global\" ? debugLog.found ? `Based on your targets, the ${provider.name} polyfill did not add any polyfill.` : `The entry point for the ${provider.name} polyfill has not been found.` : `Based on your code and targets, the ${provider.name} polyfill did not add any polyfill.`);\n          return;\n        }\n\n        if (method === \"entry-global\") {\n          console.log(`The ${provider.name} polyfill entry has been replaced with ` + `the following polyfills:`);\n        } else {\n          console.log(`The ${provider.name} polyfill added the following polyfills:`);\n        }\n\n        for (const [name, support] of debugLog.polyfills) {\n          if (support) {\n            const filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, support);\n            const formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, \", \").replace(/^\\{\"/, '{ \"').replace(/\"\\}$/, '\" }');\n            console.log(`  ${name} ${formattedTargets}`);\n          } else {\n            console.log(`  ${name}`);\n          }\n        }\n      }\n\n    };\n  });\n}\n\nfunction mapGetOr(map, key, getDefault) {\n  let val = map.get(key);\n\n  if (val === undefined) {\n    val = getDefault();\n    map.set(key, val);\n  }\n\n  return val;\n}","\n\nexports.__esModule = true;\nexports.intersection = intersection;\nexports.has = has;\nexports.resolveKey = resolveKey;\nexports.resolveSource = resolveSource;\nexports.getImportSource = getImportSource;\nexports.getRequireSource = getRequireSource;\nexports.createUtilsGetter = createUtilsGetter;\n\nvar babel = _interopRequireWildcard(require(\"@babel/core\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst {\n  types: t,\n  template\n} = babel.default || babel;\n\nfunction intersection(a, b) {\n  const result = new Set();\n  a.forEach(v => b.has(v) && result.add(v));\n  return result;\n}\n\nfunction has(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n\nfunction getType(target) {\n  return Object.prototype.toString.call(target).slice(8, -1);\n}\n\nfunction resolveId(path) {\n  if (path.isIdentifier() && !path.scope.hasBinding(path.node.name,\n  /* noGlobals */\n  true)) {\n    return path.node.name;\n  }\n\n  const {\n    deopt\n  } = path.evaluate();\n\n  if (deopt && deopt.isIdentifier()) {\n    return deopt.node.name;\n  }\n}\n\nfunction resolveKey(path, computed = false) {\n  const {\n    node,\n    parent,\n    scope\n  } = path;\n  if (path.isStringLiteral()) return node.value;\n  const {\n    name\n  } = node;\n  const isIdentifier = path.isIdentifier();\n  if (isIdentifier && !(computed || parent.computed)) return name;\n\n  if (computed && path.isMemberExpression() && path.get(\"object\").isIdentifier({\n    name: \"Symbol\"\n  }) && !scope.hasBinding(\"Symbol\",\n  /* noGlobals */\n  true)) {\n    const sym = resolveKey(path.get(\"property\"), path.node.computed);\n    if (sym) return \"Symbol.\" + sym;\n  }\n\n  if (!isIdentifier || scope.hasBinding(name,\n  /* noGlobals */\n  true)) {\n    const {\n      value\n    } = path.evaluate();\n    if (typeof value === \"string\") return value;\n  }\n}\n\nfunction resolveSource(obj) {\n  if (obj.isMemberExpression() && obj.get(\"property\").isIdentifier({\n    name: \"prototype\"\n  })) {\n    const id = resolveId(obj.get(\"object\"));\n\n    if (id) {\n      return {\n        id,\n        placement: \"prototype\"\n      };\n    }\n\n    return {\n      id: null,\n      placement: null\n    };\n  }\n\n  const id = resolveId(obj);\n\n  if (id) {\n    return {\n      id,\n      placement: \"static\"\n    };\n  }\n\n  const {\n    value\n  } = obj.evaluate();\n\n  if (value !== undefined) {\n    return {\n      id: getType(value),\n      placement: \"prototype\"\n    };\n  } else if (obj.isRegExpLiteral()) {\n    return {\n      id: \"RegExp\",\n      placement: \"prototype\"\n    };\n  } else if (obj.isFunction()) {\n    return {\n      id: \"Function\",\n      placement: \"prototype\"\n    };\n  }\n\n  return {\n    id: null,\n    placement: null\n  };\n}\n\nfunction getImportSource({\n  node\n}) {\n  if (node.specifiers.length === 0) return node.source.value;\n}\n\nfunction getRequireSource({\n  node\n}) {\n  if (!t.isExpressionStatement(node)) return;\n  const {\n    expression\n  } = node;\n  const isRequire = t.isCallExpression(expression) && t.isIdentifier(expression.callee) && expression.callee.name === \"require\" && expression.arguments.length === 1 && t.isStringLiteral(expression.arguments[0]);\n  if (isRequire) return expression.arguments[0].value;\n}\n\nfunction hoist(node) {\n  node._blockHoist = 3;\n  return node;\n}\n\nfunction createUtilsGetter(cache) {\n  return path => {\n    const prog = path.findParent(p => p.isProgram());\n    return {\n      injectGlobalImport(url) {\n        cache.storeAnonymous(prog, url, (isScript, source) => {\n          return isScript ? template.statement.ast`require(${source})` : t.importDeclaration([], source);\n        });\n      },\n\n      injectNamedImport(url, name, hint = name) {\n        return cache.storeNamed(prog, url, name, (isScript, source, name) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript ? hoist(template.statement.ast`\n                  var ${id} = require(${source}).${name}\n                `) : t.importDeclaration([t.importSpecifier(id, name)], source),\n            name: id.name\n          };\n        });\n      },\n\n      injectDefaultImport(url, hint = url) {\n        return cache.storeNamed(prog, url, \"default\", (isScript, source) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript ? hoist(template.statement.ast`var ${id} = require(${source})`) : t.importDeclaration([t.importDefaultSpecifier(id)], source),\n            name: id.name\n          };\n        });\n      }\n\n    };\n  };\n}","\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar babel = _interopRequireWildcard(require(\"@babel/core\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst {\n  types: t\n} = babel.default || babel;\n\nclass ImportsCache {\n  constructor(resolver) {\n    this._imports = new WeakMap();\n    this._anonymousImports = new WeakMap();\n    this._lastImports = new WeakMap();\n    this._resolver = resolver;\n  }\n\n  storeAnonymous(programPath, url, // eslint-disable-next-line no-undef\n  getVal) {\n    const key = this._normalizeKey(programPath, url);\n\n    const imports = this._ensure(this._anonymousImports, programPath, Set);\n\n    if (imports.has(key)) return;\n    const node = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)));\n    imports.add(key);\n\n    this._injectImport(programPath, node);\n  }\n\n  storeNamed(programPath, url, name, getVal) {\n    const key = this._normalizeKey(programPath, url, name);\n\n    const imports = this._ensure(this._imports, programPath, Map);\n\n    if (!imports.has(key)) {\n      const {\n        node,\n        name: id\n      } = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)), t.identifier(name));\n      imports.set(key, id);\n\n      this._injectImport(programPath, node);\n    }\n\n    return t.identifier(imports.get(key));\n  }\n\n  _injectImport(programPath, node) {\n    let lastImport = this._lastImports.get(programPath);\n\n    if (lastImport && lastImport.node && // Sometimes the AST is modified and the \"last import\"\n    // we have has been replaced\n    lastImport.parent === programPath.node && lastImport.container === programPath.node.body) {\n      lastImport = lastImport.insertAfter(node);\n    } else {\n      lastImport = programPath.unshiftContainer(\"body\", node);\n    }\n\n    lastImport = lastImport[lastImport.length - 1];\n\n    this._lastImports.set(programPath, lastImport);\n    /*\n    let lastImport;\n     programPath.get(\"body\").forEach(path => {\n      if (path.isImportDeclaration()) lastImport = path;\n      if (\n        path.isExpressionStatement() &&\n        isRequireCall(path.get(\"expression\"))\n      ) {\n        lastImport = path;\n      }\n      if (\n        path.isVariableDeclaration() &&\n        path.get(\"declarations\").length === 1 &&\n        (isRequireCall(path.get(\"declarations.0.init\")) ||\n          (path.get(\"declarations.0.init\").isMemberExpression() &&\n            isRequireCall(path.get(\"declarations.0.init.object\"))))\n      ) {\n        lastImport = path;\n      }\n    });*/\n\n  }\n\n  _ensure(map, programPath, Collection) {\n    let collection = map.get(programPath);\n\n    if (!collection) {\n      collection = new Collection();\n      map.set(programPath, collection);\n    }\n\n    return collection;\n  }\n\n  _normalizeKey(programPath, url, name = \"\") {\n    const {\n      sourceType\n    } = programPath.node; // If we rely on the imported binding (the \"name\" parameter), we also need to cache\n    // based on the sourceType. This is because the module transforms change the names\n    // of the import variables.\n\n    return `${name && sourceType}::${url}::${name}`;\n  }\n\n}\n\nexports.default = ImportsCache;","\n\nexports.__esModule = true;\nexports.stringifyTargetsMultiline = stringifyTargetsMultiline;\nexports.stringifyTargets = stringifyTargets;\nexports.presetEnvSilentDebugHeader = void 0;\n\nvar _helperCompilationTargets = require(\"@babel/helper-compilation-targets\");\n\nconst presetEnvSilentDebugHeader = \"#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets\";\nexports.presetEnvSilentDebugHeader = presetEnvSilentDebugHeader;\n\nfunction stringifyTargetsMultiline(targets) {\n  return JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2);\n}\n\nfunction stringifyTargets(targets) {\n  return JSON.stringify(targets).replace(/,/g, \", \").replace(/^\\{\"/, '{ \"').replace(/\"\\}$/, '\" }');\n}","\n\nexports.__esModule = true;\nexports.validateIncludeExclude = validateIncludeExclude;\nexports.applyMissingDependenciesDefaults = applyMissingDependenciesDefaults;\n\nvar _utils = require(\"./utils\");\n\nfunction patternToRegExp(pattern) {\n  if (pattern instanceof RegExp) return pattern;\n\n  try {\n    return new RegExp(`^${pattern}$`);\n  } catch (_unused) {\n    return null;\n  }\n}\n\nfunction buildUnusedError(label, unused) {\n  if (!unused.length) return \"\";\n  return `  - The following \"${label}\" patterns didn't match any polyfill:\\n` + unused.map(original => `    ${String(original)}\\n`).join(\"\");\n}\n\nfunction buldDuplicatesError(duplicates) {\n  if (!duplicates.size) return \"\";\n  return `  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\\n` + Array.from(duplicates, name => `    ${name}\\n`).join(\"\");\n}\n\nfunction validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {\n  let current;\n\n  const filter = pattern => {\n    const regexp = patternToRegExp(pattern);\n    if (!regexp) return false;\n    let matched = false;\n\n    for (const polyfill of polyfills) {\n      if (regexp.test(polyfill)) {\n        matched = true;\n        current.add(polyfill);\n      }\n    }\n\n    return !matched;\n  }; // prettier-ignore\n\n\n  const include = current = new Set();\n  const unusedInclude = Array.from(includePatterns).filter(filter); // prettier-ignore\n\n  const exclude = current = new Set();\n  const unusedExclude = Array.from(excludePatterns).filter(filter);\n  const duplicates = (0, _utils.intersection)(include, exclude);\n\n  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {\n    throw new Error(`Error while validating the \"${provider}\" provider options:\\n` + buildUnusedError(\"include\", unusedInclude) + buildUnusedError(\"exclude\", unusedExclude) + buldDuplicatesError(duplicates));\n  }\n\n  return {\n    include,\n    exclude\n  };\n}\n\nfunction applyMissingDependenciesDefaults(options, babelApi) {\n  const {\n    missingDependencies = {}\n  } = options;\n  if (missingDependencies === false) return false;\n  const caller = babelApi.caller(caller => caller == null ? void 0 : caller.name);\n  const {\n    log = \"deferred\",\n    inject = caller === \"rollup-plugin-babel\" ? \"throw\" : \"import\",\n    all = false\n  } = missingDependencies;\n  return {\n    log,\n    inject,\n    all\n  };\n}","\n\nexports.__esModule = true;\nexports.entry = exports.usage = void 0;\n\nvar _usage = _interopRequireDefault(require(\"./usage\"));\n\nexports.usage = _usage.default;\n\nvar _entry = _interopRequireDefault(require(\"./entry\"));\n\nexports.entry = _entry.default;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _utils = require(\"../utils\");\n\nvar _default = callProvider => {\n  function property(object, key, placement, path) {\n    return callProvider({\n      kind: \"property\",\n      object,\n      key,\n      placement\n    }, path);\n  }\n\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path) {\n      const {\n        node: {\n          name\n        },\n        scope\n      } = path;\n      if (scope.getBindingIdentifier(name)) return;\n      callProvider({\n        kind: \"global\",\n        name\n      }, path);\n    },\n\n    MemberExpression(path) {\n      const key = (0, _utils.resolveKey)(path.get(\"property\"), path.node.computed);\n      if (!key || key === \"prototype\") return;\n      const object = path.get(\"object\");\n      const binding = object.scope.getBinding(object.node.name);\n      if (binding && binding.path.isImportNamespaceSpecifier()) return;\n      const source = (0, _utils.resolveSource)(object);\n      return property(source.id, key, source.placement, path);\n    },\n\n    ObjectPattern(path) {\n      const {\n        parentPath,\n        parent\n      } = path;\n      let obj; // const { keys, values } = Object\n\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\"); // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\"); // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n\n      let id = null;\n      let placement = null;\n      if (obj) ({\n        id,\n        placement\n      } = (0, _utils.resolveSource)(obj));\n\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = (0, _utils.resolveKey)(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n\n    BinaryExpression(path) {\n      if (path.node.operator !== \"in\") return;\n      const source = (0, _utils.resolveSource)(path.get(\"right\"));\n      const key = (0, _utils.resolveKey)(path.get(\"left\"), true);\n      if (!key) return;\n      callProvider({\n        kind: \"in\",\n        object: source.id,\n        key,\n        placement: source.placement\n      }, path);\n    }\n\n  };\n};\n\nexports.default = _default;","\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _utils = require(\"../utils\");\n\nvar _default = callProvider => ({\n  ImportDeclaration(path) {\n    const source = (0, _utils.getImportSource)(path);\n    if (!source) return;\n    callProvider({\n      kind: \"import\",\n      source\n    }, path);\n  },\n\n  Program(path) {\n    path.get(\"body\").forEach(bodyPath => {\n      const source = (0, _utils.getRequireSource)(bodyPath);\n      if (!source) return;\n      callProvider({\n        kind: \"import\",\n        source\n      }, bodyPath);\n    });\n  }\n\n});\n\nexports.default = _default;","\n\nexports.__esModule = true;\nexports.resolve = resolve;\nexports.has = has;\nexports.logMissing = logMissing;\nexports.laterLogMissing = laterLogMissing;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash.debounce\"));\n\nvar _resolve = _interopRequireDefault(require(\"resolve\"));\n\nvar _module = require(\"module\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst nativeRequireResolve = parseFloat(process.versions.node) >= 8.9; // $FlowIgnore\n\n// eslint-disable-line\nfunction resolve(dirname, moduleName, absoluteImports) {\n  if (absoluteImports === false) return moduleName;\n  let basedir = dirname;\n\n  if (typeof absoluteImports === \"string\") {\n    basedir = _path.default.resolve(basedir, absoluteImports);\n  }\n\n  try {\n    if (nativeRequireResolve) {\n      return require.resolve(moduleName, {\n        paths: [basedir]\n      });\n    } else {\n      return _resolve.default.sync(moduleName, {\n        basedir\n      });\n    }\n  } catch (err) {\n    if (err.code !== \"MODULE_NOT_FOUND\") throw err; // $FlowIgnore\n\n    throw Object.assign(new Error(`Failed to resolve \"${moduleName}\" relative to \"${dirname}\"`), {\n      code: \"BABEL_POLYFILL_NOT_FOUND\",\n      polyfill: moduleName,\n      dirname\n    });\n  }\n}\n\nfunction has(basedir, name) {\n  try {\n    if (nativeRequireResolve) {\n      require.resolve(name, {\n        paths: [basedir]\n      });\n    } else {\n      _resolve.default.sync(name, {\n        basedir\n      });\n    }\n\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\n\nfunction logMissing(missingDeps) {\n  if (missingDeps.size === 0) return;\n  const deps = Array.from(missingDeps).sort().join(\" \");\n  console.warn(\"\\nSome polyfills have been added but are not present in your dependencies.\\n\" + \"Please run one of the following commands:\\n\" + `\\tnpm install --save ${deps}\\n` + `\\tyarn add ${deps}\\n`);\n  process.exitCode = 1;\n}\n\nlet allMissingDeps = new Set();\nconst laterLogMissingDependencies = (0, _lodash.default)(() => {\n  logMissing(allMissingDeps);\n  allMissingDeps = new Set();\n}, 100);\n\nfunction laterLogMissing(missingDeps) {\n  if (missingDeps.size === 0) return;\n  missingDeps.forEach(name => allMissingDeps.add(name));\n  laterLogMissingDependencies();\n}","\n\nexports.__esModule = true;\nexports.default = createMetaResolver;\n\nvar _utils = require(\"./utils\");\n\nconst PossibleGlobalObjects = new Set([\"global\", \"globalThis\", \"self\", \"window\"]);\n\nfunction createMetaResolver(polyfills) {\n  const {\n    static: staticP,\n    instance: instanceP,\n    global: globalP\n  } = polyfills;\n  return meta => {\n    if (meta.kind === \"global\" && globalP && (0, _utils.has)(globalP, meta.name)) {\n      return {\n        kind: \"global\",\n        desc: globalP[meta.name],\n        name: meta.name\n      };\n    }\n\n    if (meta.kind === \"property\" || meta.kind === \"in\") {\n      const {\n        placement,\n        object,\n        key\n      } = meta;\n\n      if (object && placement === \"static\") {\n        if (globalP && PossibleGlobalObjects.has(object) && (0, _utils.has)(globalP, key)) {\n          return {\n            kind: \"global\",\n            desc: globalP[key],\n            name: key\n          };\n        }\n\n        if (staticP && (0, _utils.has)(staticP, object) && (0, _utils.has)(staticP[object], key)) {\n          return {\n            kind: \"static\",\n            desc: staticP[object][key],\n            name: `${object}$${key}`\n          };\n        }\n      }\n\n      if (instanceP && (0, _utils.has)(instanceP, key)) {\n        return {\n          kind: \"instance\",\n          desc: instanceP[key],\n          name: `${key}`\n        };\n      }\n    }\n  };\n}"]}