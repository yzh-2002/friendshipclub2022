{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  assignmentExpression,\n  cloneNode,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isPrivateName,\n  isPureish,\n  isSuper,\n  memberExpression,\n  toComputedKey\n} = _t;\n\nfunction getObjRef(node, nodes, scope) {\n  let ref;\n\n  if (isIdentifier(node)) {\n    if (scope.hasBinding(node.name)) {\n      return node;\n    } else {\n      ref = node;\n    }\n  } else if (isMemberExpression(node)) {\n    ref = node.object;\n\n    if (isSuper(ref) || isIdentifier(ref) && scope.hasBinding(ref.name)) {\n      return ref;\n    }\n  } else {\n    throw new Error(`We can't explode this node type ${node[\"type\"]}`);\n  }\n\n  const temp = scope.generateUidIdentifierBasedOnNode(ref);\n  scope.push({\n    id: temp\n  });\n  nodes.push(assignmentExpression(\"=\", cloneNode(temp), cloneNode(ref)));\n  return temp;\n}\n\nfunction getPropRef(node, nodes, scope) {\n  const prop = node.property;\n\n  if (isPrivateName(prop)) {\n    throw new Error(\"We can't generate property ref for private name, please install `@babel/plugin-proposal-class-properties`\");\n  }\n\n  const key = toComputedKey(node, prop);\n  if (isLiteral(key) && isPureish(key)) return key;\n  const temp = scope.generateUidIdentifierBasedOnNode(prop);\n  scope.push({\n    id: temp\n  });\n  nodes.push(assignmentExpression(\"=\", cloneNode(temp), cloneNode(prop)));\n  return temp;\n}\n\nfunction _default(node, nodes, file, scope, allowedSingleIdent) {\n  let obj;\n\n  if (isIdentifier(node) && allowedSingleIdent) {\n    obj = node;\n  } else {\n    obj = getObjRef(node, nodes, scope);\n  }\n\n  let ref, uid;\n\n  if (isIdentifier(node)) {\n    ref = cloneNode(node);\n    uid = obj;\n  } else {\n    const prop = getPropRef(node, nodes, scope);\n    const computed = node.computed || isLiteral(prop);\n    uid = memberExpression(cloneNode(obj), cloneNode(prop), computed);\n    ref = memberExpression(cloneNode(obj), cloneNode(prop), computed);\n  }\n\n  return {\n    uid: uid,\n    ref: ref\n  };\n}"]}