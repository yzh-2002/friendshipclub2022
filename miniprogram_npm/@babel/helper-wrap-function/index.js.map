{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = wrapFunction;\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _template = require(\"@babel/template\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isRestElement,\n  returnStatement\n} = _t;\n\nconst buildAnonymousExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`);\n\nconst buildNamedExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`);\n\nconst buildDeclarationWrapper = (0, _template.default)(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(path, callId) {\n  const node = path.node;\n  const body = node.body;\n  const container = functionExpression(null, [], blockStatement(body.body), true);\n  body.body = [returnStatement(callExpression(callExpression(callId, [container]), []))];\n  node.async = false;\n  node.generator = false;\n  path.get(\"body.body.0.argument.callee.arguments.0\").unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(path, callId, noNewArrows, ignoreFunctionLength) {\n  const node = path.node;\n  const isDeclaration = path.isFunctionDeclaration();\n  const functionId = node.id;\n  const wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;\n\n  if (path.isArrowFunctionExpression()) {\n    path.arrowFunctionToExpression({\n      noNewArrows\n    });\n  }\n\n  node.id = null;\n\n  if (isDeclaration) {\n    node.type = \"FunctionExpression\";\n  }\n\n  const built = callExpression(callId, [node]);\n  const params = [];\n\n  for (const param of node.params) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const container = wrapper({\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params\n  });\n\n  if (isDeclaration) {\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    const retFunction = container.callee.body.body[1].argument;\n\n    if (!functionId) {\n      (0, _helperFunctionName.default)({\n        node: retFunction,\n        parent: path.parent,\n        scope: path.scope\n      });\n    }\n\n    if (!retFunction || retFunction.id || !ignoreFunctionLength && params.length) {\n      path.replaceWith(container);\n    } else {\n      path.replaceWith(built);\n    }\n  }\n}\n\nfunction wrapFunction(path, callId, noNewArrows = true, ignoreFunctionLength = false) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(path, callId, noNewArrows, ignoreFunctionLength);\n  }\n}"]}