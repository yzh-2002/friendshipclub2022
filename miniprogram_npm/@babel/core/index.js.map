{"version":3,"sources":["index.js","transformation/file/file.js","tools/build-external-helpers.js","config/files/index.js","config/files/package.js","config/files/utils.js","config/caching.js","gensync-utils/async.js","config/util.js","gensync-utils/fs.js","config/files/configuration.js","config/helpers/config-api.js","config/cache-contexts.js","config/files/module-types.js","config/pattern-to-regex.js","config/files/plugins.js","config/files/import-meta-resolve.js","vendor/import-meta-resolve.js","config/helpers/environment.js","config/index.js","config/full.js","config/plugin.js","config/helpers/deep-array.js","config/item.js","config/config-descriptors.js","config/resolve-targets.js","config/config-chain.js","config/validation/options.js","config/validation/removed.js","config/validation/option-assertions.js","config/printer.js","config/validation/plugins.js","config/partial.js","transform.js","transformation/index.js","transformation/plugin-pass.js","transformation/block-hoist-plugin.js","transformation/normalize-opts.js","transformation/normalize-file.js","parser/index.js","parser/util/missing-plugin-helper.js","transformation/util/clone-deep.js","transformation/util/clone-deep-browser.js","transformation/file/generate.js","transformation/file/merge-map.js","transform-file.js","transform-ast.js","parse.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,ACHA,AJYA,AENA,ADGA;AELA,ACHA,AJYA,AENA,ADGA;AELA,ACHA,AJYA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AENA,APqBA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AENA,APqBA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AENA,APqBA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AGTA,ADGA,APqBA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AGTA,ADGA,APqBA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AGTA,ADGA,APqBA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AGTA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AGTA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,AGTA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,ACHA,ACHA,AGTA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,ACHA,ACHA,AGTA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,ACHA,ACHA,AGTA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,ACHA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,ACHA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,ACHA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AWhCA,ANkBA,AIZA,APqBA,ACHA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,ACHA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,ACHA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,ACHA,AMlBA,AHSA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,ACHA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,ACHA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,ACHA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,APqBA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA;AKdA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AGTA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AOrBA,AJYA,ANkBA,ADGA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AOrBA,AJYA,APqBA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AOrBA,AJYA,APqBA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AOrBA,ACHA,ALeA,APqBA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AV8BA,AMlBA,AOrBA,ACHA,ALeA,APqBA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AJYA,AOrBA,ACHA,ALeA,APqBA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AOrBA,ACHA,ALeA,APqBA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AOrBA,ACHA,ALeA,APqBA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AOrBA,ACHA,ALeA,APqBA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AOrBA,ACHA,ALeA,AOrBA,Ad0CA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AQxBA,ALeA,AOrBA,Ad0CA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AQxBA,ALeA,AOrBA,Ad0CA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,ALeA,AOrBA,Ad0CA,AENA,AT2BA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,ALeA,AOrBA,Ad0CA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,ALeA,AOrBA,Ad0CA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,Ad0CA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,Ad0CA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AIZA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,Ad0CA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AkBtDA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,Ad0CA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AkBtDA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,Ad0CA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AkBtDA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,Ad0CA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AkBtDA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AlBsDA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AkBtDA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AlBsDA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AkBtDA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AlBsDA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AlBsDA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AlBsDA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AlBsDA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AENA,ApB4DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AENA,ApB4DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AENA,ApB4DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AENA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AT2BA,AOrBA,AIZA,AENA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AFMA,AIZA,AENA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AT2BA,AWjCA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AFMA,AIZA,AIZA,AFMA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AMlBA,AbuCA,AU9BA,AENA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AFMA,AIZA,AIZA,AFMA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,APqBA,AU9BA,AENA,AKfA,AT2BA,AWjCA,AHSA,AIZA,AFMA,AIZA,AIZA,AFMA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,APqBA,AU9BA,AENA,AKfA,AT2BA,AQxBA,AIZA,AFMA,AS3BA,ALeA,AIZA,AFMA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,APqBA,AU9BA,AENA,AKfA,AT2BA,AQxBA,AIZA,AFMA,AS3BA,ALeA,AIZA,AFMA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,APqBA,AU9BA,AENA,AKfA,AT2BA,AQxBA,AIZA,AFMA,AS3BA,ALeA,AIZA,AFMA,ACHA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,APqBA,AU9BA,AENA,AKfA,AT2BA,AQxBA,AIZA,AFMA,AS3BA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,APqBA,AU9BA,AENA,AKfA,AT2BA,AQxBA,AIZA,AFMA,AS3BA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AFMA,AS3BA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AXiCA,AS3BA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,ADGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AgBhDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AiCnGA,AjBmDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AiCnGA,AjBmDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AiCnGA,AjBmDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AiCnGA,ACHA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AiCnGA,ACHA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AhCgGA,AiCnGA,ACHA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,ACHA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,ACHA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,ACHA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,AGTA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,AGTA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,AGTA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,ArB+DA,APqBA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AENA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ArC+GA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ArC+GA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ArC+GA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AMlBA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AMlBA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AMlBA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,AiCnGA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,A0C9HA,AT2BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,A0C9HA,AT2BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AQxBA,AIZA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,A0C9HA,AT2BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A+B7FA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A2CjIA,AZoCA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A2CjIA,AZoCA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A2CjIA,AZoCA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A4CpIA,ADGA,AZoCA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A4CpIA,ADGA,AZoCA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AT2BA,AYpCA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,AuCrHA,ACHA,AtCkHA,A4CpIA,ADGA,AZoCA,AGTA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AGTA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AGTA,AS3BA,AFMA,ALeA,AIZA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AGTA,AS3BA,AFMA,ADGA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AGTA,AS3BA,AFMA,ADGA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AGTA,AENA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,ADGA,AxBwEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,AHSA,A5BoFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,AzB2EA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AOrBA,AzB2EA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,AFMA,AlBsDA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,AIZA,A/B6FA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AtCkHA,A4CpIA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ADGA,ApB4DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,ADGA,AT2BA,AnCyGA,A0C9HA,ACHA,AV8BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,ADGA,AT2BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,AV8BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,AV8BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,AV8BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,AV8BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,AV8BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,AV8BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,AV8BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AMlBA,AV8BA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,A+C7IA,ARwBA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AJYA,AnCyGA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AuCrHA,ACHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,A0C9HA,AT2BA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AFMA,ADGA,AFMA,A3BiFA,AwCxHA,AvCqHA,AiCnGA,AIZA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AvCqHA,AqC/GA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,A3BiFA,AwCxHA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AFMA,ArB+DA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AFMA,AavCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AYpCA,AHSA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AFMA,Ad0CA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AKfA,AKfA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AXkCA,AoB5DA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,AhBgDA,AU9BA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,ANkBA,AS3BA,AWjCA,AvBqEA;AS1BA,AGTA,AWjCA,AvBqEA;AS1BA,Ac1CA,AvBqEA;AS1BA,Ac1CA,AvBqEA;AS1BA,Ac1CA,AvBqEA;AS1BA,Ac1CA,AvBqEA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_EXTENSIONS = void 0;\nObject.defineProperty(exports, \"File\", {\n  enumerable: true,\n  get: function () {\n    return _file.default;\n  }\n});\nexports.OptionManager = void 0;\nexports.Plugin = Plugin;\nObject.defineProperty(exports, \"buildExternalHelpers\", {\n  enumerable: true,\n  get: function () {\n    return _buildExternalHelpers.default;\n  }\n});\nObject.defineProperty(exports, \"createConfigItem\", {\n  enumerable: true,\n  get: function () {\n    return _config.createConfigItem;\n  }\n});\nObject.defineProperty(exports, \"createConfigItemAsync\", {\n  enumerable: true,\n  get: function () {\n    return _config.createConfigItemAsync;\n  }\n});\nObject.defineProperty(exports, \"createConfigItemSync\", {\n  enumerable: true,\n  get: function () {\n    return _config.createConfigItemSync;\n  }\n});\nObject.defineProperty(exports, \"getEnv\", {\n  enumerable: true,\n  get: function () {\n    return _environment.getEnv;\n  }\n});\nObject.defineProperty(exports, \"loadOptions\", {\n  enumerable: true,\n  get: function () {\n    return _config.loadOptions;\n  }\n});\nObject.defineProperty(exports, \"loadOptionsAsync\", {\n  enumerable: true,\n  get: function () {\n    return _config.loadOptionsAsync;\n  }\n});\nObject.defineProperty(exports, \"loadOptionsSync\", {\n  enumerable: true,\n  get: function () {\n    return _config.loadOptionsSync;\n  }\n});\nObject.defineProperty(exports, \"loadPartialConfig\", {\n  enumerable: true,\n  get: function () {\n    return _config.loadPartialConfig;\n  }\n});\nObject.defineProperty(exports, \"loadPartialConfigAsync\", {\n  enumerable: true,\n  get: function () {\n    return _config.loadPartialConfigAsync;\n  }\n});\nObject.defineProperty(exports, \"loadPartialConfigSync\", {\n  enumerable: true,\n  get: function () {\n    return _config.loadPartialConfigSync;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parse;\n  }\n});\nObject.defineProperty(exports, \"parseAsync\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parseAsync;\n  }\n});\nObject.defineProperty(exports, \"parseSync\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parseSync;\n  }\n});\nObject.defineProperty(exports, \"resolvePlugin\", {\n  enumerable: true,\n  get: function () {\n    return _files.resolvePlugin;\n  }\n});\nObject.defineProperty(exports, \"resolvePreset\", {\n  enumerable: true,\n  get: function () {\n    return _files.resolvePreset;\n  }\n});\nObject.defineProperty(exports, \"template\", {\n  enumerable: true,\n  get: function () {\n    return _template().default;\n  }\n});\nObject.defineProperty(exports, \"tokTypes\", {\n  enumerable: true,\n  get: function () {\n    return _parser().tokTypes;\n  }\n});\nObject.defineProperty(exports, \"transform\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transform;\n  }\n});\nObject.defineProperty(exports, \"transformAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transformAsync;\n  }\n});\nObject.defineProperty(exports, \"transformFile\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFile;\n  }\n});\nObject.defineProperty(exports, \"transformFileAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFileAsync;\n  }\n});\nObject.defineProperty(exports, \"transformFileSync\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFileSync;\n  }\n});\nObject.defineProperty(exports, \"transformFromAst\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAst;\n  }\n});\nObject.defineProperty(exports, \"transformFromAstAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAstAsync;\n  }\n});\nObject.defineProperty(exports, \"transformFromAstSync\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAstSync;\n  }\n});\nObject.defineProperty(exports, \"transformSync\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transformSync;\n  }\n});\nObject.defineProperty(exports, \"traverse\", {\n  enumerable: true,\n  get: function () {\n    return _traverse().default;\n  }\n});\nexports.version = exports.types = void 0;\n\nvar _file = require(\"./transformation/file/file\");\n\nvar _buildExternalHelpers = require(\"./tools/build-external-helpers\");\n\nvar _files = require(\"./config/files\");\n\nvar _environment = require(\"./config/helpers/environment\");\n\nfunction _types() {\n  const data = require(\"@babel/types\");\n\n  _types = function () {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"types\", {\n  enumerable: true,\n  get: function () {\n    return _types();\n  }\n});\n\nfunction _parser() {\n  const data = require(\"@babel/parser\");\n\n  _parser = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _template() {\n  const data = require(\"@babel/template\");\n\n  _template = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _config = require(\"./config\");\n\nvar _transform = require(\"./transform\");\n\nvar _transformFile = require(\"./transform-file\");\n\nvar _transformAst = require(\"./transform-ast\");\n\nvar _parse = require(\"./parse\");\n\nconst version = \"7.17.9\";\nexports.version = version;\nconst DEFAULT_EXTENSIONS = Object.freeze([\".js\", \".jsx\", \".es6\", \".es\", \".mjs\", \".cjs\"]);\nexports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;\n\nclass OptionManager {\n  init(opts) {\n    return (0, _config.loadOptions)(opts);\n  }\n\n}\n\nexports.OptionManager = OptionManager;\n\nfunction Plugin(alias) {\n  throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction helpers() {\n  const data = require(\"@babel/helpers\");\n\n  helpers = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _codeFrame() {\n  const data = require(\"@babel/code-frame\");\n\n  _codeFrame = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _t() {\n  const data = require(\"@babel/types\");\n\n  _t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _helperModuleTransforms() {\n  const data = require(\"@babel/helper-module-transforms\");\n\n  _helperModuleTransforms = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _semver() {\n  const data = require(\"semver\");\n\n  _semver = function () {\n    return data;\n  };\n\n  return data;\n}\n\nconst {\n  cloneNode,\n  interpreterDirective\n} = _t();\n\nconst errorVisitor = {\n  enter(path, state) {\n    const loc = path.node.loc;\n\n    if (loc) {\n      state.loc = loc;\n      path.stop();\n    }\n  }\n\n};\n\nclass File {\n  constructor(options, {\n    code,\n    ast,\n    inputMap\n  }) {\n    this._map = new Map();\n    this.opts = void 0;\n    this.declarations = {};\n    this.path = null;\n    this.ast = {};\n    this.scope = void 0;\n    this.metadata = {};\n    this.code = \"\";\n    this.inputMap = null;\n    this.hub = {\n      file: this,\n      getCode: () => this.code,\n      getScope: () => this.scope,\n      addHelper: this.addHelper.bind(this),\n      buildError: this.buildCodeFrameError.bind(this)\n    };\n    this.opts = options;\n    this.code = code;\n    this.ast = ast;\n    this.inputMap = inputMap;\n    this.path = _traverse().NodePath.get({\n      hub: this.hub,\n      parentPath: null,\n      parent: this.ast,\n      container: this.ast,\n      key: \"program\"\n    }).setContext();\n    this.scope = this.path.scope;\n  }\n\n  get shebang() {\n    const {\n      interpreter\n    } = this.path.node;\n    return interpreter ? interpreter.value : \"\";\n  }\n\n  set shebang(value) {\n    if (value) {\n      this.path.get(\"interpreter\").replaceWith(interpreterDirective(value));\n    } else {\n      this.path.get(\"interpreter\").remove();\n    }\n  }\n\n  set(key, val) {\n    if (key === \"helpersNamespace\") {\n      throw new Error(\"Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.\" + \"If you are using @babel/plugin-external-helpers you will need to use a newer \" + \"version than the one you currently have installed. \" + \"If you have your own implementation, you'll want to explore using 'helperGenerator' \" + \"alongside 'file.availableHelper()'.\");\n    }\n\n    this._map.set(key, val);\n  }\n\n  get(key) {\n    return this._map.get(key);\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  getModuleName() {\n    return (0, _helperModuleTransforms().getModuleName)(this.opts, this.opts);\n  }\n\n  addImport() {\n    throw new Error(\"This API has been removed. If you're looking for this \" + \"functionality in Babel 7, you should import the \" + \"'@babel/helper-module-imports' module and use the functions exposed \" + \" from that module, such as 'addNamed' or 'addDefault'.\");\n  }\n\n  availableHelper(name, versionRange) {\n    let minVersion;\n\n    try {\n      minVersion = helpers().minVersion(name);\n    } catch (err) {\n      if (err.code !== \"BABEL_HELPER_UNKNOWN\") throw err;\n      return false;\n    }\n\n    if (typeof versionRange !== \"string\") return true;\n    if (_semver().valid(versionRange)) versionRange = `^${versionRange}`;\n    return !_semver().intersects(`<${minVersion}`, versionRange) && !_semver().intersects(`>=8.0.0`, versionRange);\n  }\n\n  addHelper(name) {\n    const declar = this.declarations[name];\n    if (declar) return cloneNode(declar);\n    const generator = this.get(\"helperGenerator\");\n\n    if (generator) {\n      const res = generator(name);\n      if (res) return res;\n    }\n\n    helpers().ensure(name, File);\n    const uid = this.declarations[name] = this.scope.generateUidIdentifier(name);\n    const dependencies = {};\n\n    for (const dep of helpers().getDependencies(name)) {\n      dependencies[dep] = this.addHelper(dep);\n    }\n\n    const {\n      nodes,\n      globals\n    } = helpers().get(name, dep => dependencies[dep], uid, Object.keys(this.scope.getAllBindings()));\n    globals.forEach(name => {\n      if (this.path.scope.hasBinding(name, true)) {\n        this.path.scope.rename(name);\n      }\n    });\n    nodes.forEach(node => {\n      node._compact = true;\n    });\n    this.path.unshiftContainer(\"body\", nodes);\n    this.path.get(\"body\").forEach(path => {\n      if (nodes.indexOf(path.node) === -1) return;\n      if (path.isVariableDeclaration()) this.scope.registerDeclaration(path);\n    });\n    return uid;\n  }\n\n  addTemplateObject() {\n    throw new Error(\"This function has been moved into the template literal transform itself.\");\n  }\n\n  buildCodeFrameError(node, msg, _Error = SyntaxError) {\n    let loc = node && (node.loc || node._loc);\n\n    if (!loc && node) {\n      const state = {\n        loc: null\n      };\n      (0, _traverse().default)(node, errorVisitor, this.scope, state);\n      loc = state.loc;\n      let txt = \"This is an error on an internal node. Probably an internal error.\";\n      if (loc) txt += \" Location has been estimated.\";\n      msg += ` (${txt})`;\n    }\n\n    if (loc) {\n      const {\n        highlightCode = true\n      } = this.opts;\n      msg += \"\\n\" + (0, _codeFrame().codeFrameColumns)(this.code, {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column + 1\n        },\n        end: loc.end && loc.start.line === loc.end.line ? {\n          line: loc.end.line,\n          column: loc.end.column + 1\n        } : undefined\n      }, {\n        highlightCode\n      });\n    }\n\n    return new _Error(msg);\n  }\n\n}\n\nexports.default = File;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nfunction helpers() {\n  const data = require(\"@babel/helpers\");\n\n  helpers = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _generator() {\n  const data = require(\"@babel/generator\");\n\n  _generator = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _template() {\n  const data = require(\"@babel/template\");\n\n  _template = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _t() {\n  const data = require(\"@babel/types\");\n\n  _t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = require(\"../transformation/file/file\");\n\nconst {\n  arrayExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  exportNamedDeclaration,\n  exportSpecifier,\n  expressionStatement,\n  functionExpression,\n  identifier,\n  memberExpression,\n  objectExpression,\n  program,\n  stringLiteral,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t();\n\nconst buildUmdWrapper = replacements => _template().default.statement`\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  `(replacements);\n\nfunction buildGlobal(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  const container = functionExpression(null, [identifier(\"global\")], blockStatement(body));\n  const tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", identifier(\"global\")), stringLiteral(\"undefined\")), identifier(\"self\"), identifier(\"global\"))]))]);\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, assignmentExpression(\"=\", memberExpression(identifier(\"global\"), namespace), objectExpression([])))]));\n  buildHelpers(body, namespace, allowlist);\n  return tree;\n}\n\nfunction buildModule(allowlist) {\n  const body = [];\n  const refs = buildHelpers(body, null, allowlist);\n  body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(name => {\n    return exportSpecifier(cloneNode(refs[name]), identifier(name));\n  })));\n  return program(body, [], \"module\");\n}\n\nfunction buildUmd(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, identifier(\"global\"))]));\n  buildHelpers(body, namespace, allowlist);\n  return program([buildUmdWrapper({\n    FACTORY_PARAMETERS: identifier(\"global\"),\n    BROWSER_ARGUMENTS: assignmentExpression(\"=\", memberExpression(identifier(\"root\"), namespace), objectExpression([])),\n    COMMON_ARGUMENTS: identifier(\"exports\"),\n    AMD_ARGUMENTS: arrayExpression([stringLiteral(\"exports\")]),\n    FACTORY_BODY: body,\n    UMD_ROOT: identifier(\"this\")\n  })]);\n}\n\nfunction buildVar(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, objectExpression([]))]));\n  const tree = program(body);\n  buildHelpers(body, namespace, allowlist);\n  body.push(expressionStatement(namespace));\n  return tree;\n}\n\nfunction buildHelpers(body, namespace, allowlist) {\n  const getHelperReference = name => {\n    return namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name}`);\n  };\n\n  const refs = {};\n  helpers().list.forEach(function (name) {\n    if (allowlist && allowlist.indexOf(name) < 0) return;\n    const ref = refs[name] = getHelperReference(name);\n    helpers().ensure(name, _file.default);\n    const {\n      nodes\n    } = helpers().get(name, getHelperReference, ref);\n    body.push(...nodes);\n  });\n  return refs;\n}\n\nfunction _default(allowlist, outputType = \"global\") {\n  let tree;\n  const build = {\n    global: buildGlobal,\n    module: buildModule,\n    umd: buildUmd,\n    var: buildVar\n  }[outputType];\n\n  if (build) {\n    tree = build(allowlist);\n  } else {\n    throw new Error(`Unsupported output type ${outputType}`);\n  }\n\n  return (0, _generator().default)(tree).code;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ROOT_CONFIG_FILENAMES\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.ROOT_CONFIG_FILENAMES;\n  }\n});\nObject.defineProperty(exports, \"findConfigUpwards\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findConfigUpwards;\n  }\n});\nObject.defineProperty(exports, \"findPackageData\", {\n  enumerable: true,\n  get: function () {\n    return _package.findPackageData;\n  }\n});\nObject.defineProperty(exports, \"findRelativeConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findRelativeConfig;\n  }\n});\nObject.defineProperty(exports, \"findRootConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findRootConfig;\n  }\n});\nObject.defineProperty(exports, \"loadConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.loadConfig;\n  }\n});\nObject.defineProperty(exports, \"loadPlugin\", {\n  enumerable: true,\n  get: function () {\n    return plugins.loadPlugin;\n  }\n});\nObject.defineProperty(exports, \"loadPreset\", {\n  enumerable: true,\n  get: function () {\n    return plugins.loadPreset;\n  }\n});\nexports.resolvePreset = exports.resolvePlugin = void 0;\nObject.defineProperty(exports, \"resolveShowConfigPath\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.resolveShowConfigPath;\n  }\n});\n\nvar _package = require(\"./package\");\n\nvar _configuration = require(\"./configuration\");\n\nvar plugins = require(\"./plugins\");\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\n({});\n\nconst resolvePlugin = _gensync()(plugins.resolvePlugin).sync;\n\nexports.resolvePlugin = resolvePlugin;\n\nconst resolvePreset = _gensync()(plugins.resolvePreset).sync;\n\nexports.resolvePreset = resolvePreset;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findPackageData = findPackageData;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _utils = require(\"./utils\");\n\nconst PACKAGE_FILENAME = \"package.json\";\n\nfunction* findPackageData(filepath) {\n  let pkg = null;\n  const directories = [];\n  let isPackage = true;\n\n  let dirname = _path().dirname(filepath);\n\n  while (!pkg && _path().basename(dirname) !== \"node_modules\") {\n    directories.push(dirname);\n    pkg = yield* readConfigPackage(_path().join(dirname, PACKAGE_FILENAME));\n\n    const nextLoc = _path().dirname(dirname);\n\n    if (dirname === nextLoc) {\n      isPackage = false;\n      break;\n    }\n\n    dirname = nextLoc;\n  }\n\n  return {\n    filepath,\n    directories,\n    pkg,\n    isPackage\n  };\n}\n\nconst readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {\n  let options;\n\n  try {\n    options = JSON.parse(content);\n  } catch (err) {\n    err.message = `${filepath}: Error while parsing JSON - ${err.message}`;\n    throw err;\n  }\n\n  if (!options) throw new Error(`${filepath}: No config detected`);\n\n  if (typeof options !== \"object\") {\n    throw new Error(`${filepath}: Config returned typeof ${typeof options}`);\n  }\n\n  if (Array.isArray(options)) {\n    throw new Error(`${filepath}: Expected config object but found array`);\n  }\n\n  return {\n    filepath,\n    dirname: _path().dirname(filepath),\n    options\n  };\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeStaticFileCache = makeStaticFileCache;\n\nvar _caching = require(\"../caching\");\n\nvar fs = require(\"../../gensync-utils/fs\");\n\nfunction _fs2() {\n  const data = require(\"fs\");\n\n  _fs2 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction makeStaticFileCache(fn) {\n  return (0, _caching.makeStrongCache)(function* (filepath, cache) {\n    const cached = cache.invalidate(() => fileMtime(filepath));\n\n    if (cached === null) {\n      return null;\n    }\n\n    return fn(filepath, yield* fs.readFile(filepath, \"utf8\"));\n  });\n}\n\nfunction fileMtime(filepath) {\n  if (!_fs2().existsSync(filepath)) return null;\n\n  try {\n    return +_fs2().statSync(filepath).mtime;\n  } catch (e) {\n    if (e.code !== \"ENOENT\" && e.code !== \"ENOTDIR\") throw e;\n  }\n\n  return null;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertSimpleType = assertSimpleType;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nconst synchronize = gen => {\n  return _gensync()(gen).sync;\n};\n\nfunction* genTrue() {\n  return true;\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  const callCacheSync = new CallCache();\n  const callCacheAsync = new CallCache();\n  const futureCache = new CallCache();\n  return function* cachedFunction(arg, data) {\n    const asyncContext = yield* (0, _async.isAsync)();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n    const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);\n    if (cached.valid) return cached.value;\n    const cache = new CacheConfigurator(data);\n    const handlerResult = handler(arg, cache);\n    let finishLock;\n    let value;\n\n    if ((0, _util.isIterableIterator)(handlerResult)) {\n      const gen = handlerResult;\n      value = yield* (0, _async.onFirstPause)(gen, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\nfunction* getCachedValue(cache, arg, data) {\n  const cachedValue = cache.get(arg);\n\n  if (cachedValue) {\n    for (const {\n      value,\n      valid\n    } of cachedValue) {\n      if (yield* valid(data)) return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  const cached = yield* getCachedValue(callCache, arg, data);\n\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n\n    if (cached.valid) {\n      const value = yield* (0, _async.waitFor)(cached.value.promise);\n      return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  const finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  let cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n    const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);\n\n    if ((0, _async.isThenable)(key)) {\n      return key.then(key => {\n        this._pairs.push([key, fn]);\n\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return function* (data) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nclass Lock {\n  constructor() {\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value) {\n    this.released = true;\n\n    this._resolve(value);\n  }\n\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forwardAsync = forwardAsync;\nexports.isAsync = void 0;\nexports.isThenable = isThenable;\nexports.maybeAsync = maybeAsync;\nexports.waitFor = exports.onFirstPause = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nconst id = x => x;\n\nconst runGenerator = _gensync()(function* (item) {\n  return yield* item;\n});\n\nconst isAsync = _gensync()({\n  sync: () => false,\n  errback: cb => cb(null, true)\n});\n\nexports.isAsync = isAsync;\n\nfunction maybeAsync(fn, message) {\n  return _gensync()({\n    sync(...args) {\n      const result = fn.apply(this, args);\n      if (isThenable(result)) throw new Error(message);\n      return result;\n    },\n\n    async(...args) {\n      return Promise.resolve(fn.apply(this, args));\n    }\n\n  });\n}\n\nconst withKind = _gensync()({\n  sync: cb => cb(\"sync\"),\n  async: cb => cb(\"async\")\n});\n\nfunction forwardAsync(action, cb) {\n  const g = _gensync()(action);\n\n  return withKind(kind => {\n    const adapted = g[kind];\n    return cb(adapted);\n  });\n}\n\nconst onFirstPause = _gensync()({\n  name: \"onFirstPause\",\n  arity: 2,\n  sync: function (item) {\n    return runGenerator.sync(item);\n  },\n  errback: function (item, firstPause, cb) {\n    let completed = false;\n    runGenerator.errback(item, (err, value) => {\n      completed = true;\n      cb(err, value);\n    });\n\n    if (!completed) {\n      firstPause();\n    }\n  }\n});\n\nexports.onFirstPause = onFirstPause;\n\nconst waitFor = _gensync()({\n  sync: id,\n  async: id\n});\n\nexports.waitFor = waitFor;\n\nfunction isThenable(val) {\n  return !!val && (typeof val === \"object\" || typeof val === \"function\") && !!val.then && typeof val.then === \"function\";\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIterableIterator = isIterableIterator;\nexports.mergeOptions = mergeOptions;\n\nfunction mergeOptions(target, source) {\n  for (const k of Object.keys(source)) {\n    if ((k === \"parserOpts\" || k === \"generatorOpts\" || k === \"assumptions\") && source[k]) {\n      const parserOpts = source[k];\n      const targetObj = target[k] || (target[k] = {});\n      mergeDefaultFields(targetObj, parserOpts);\n    } else {\n      const val = source[k];\n      if (val !== undefined) target[k] = val;\n    }\n  }\n}\n\nfunction mergeDefaultFields(target, source) {\n  for (const k of Object.keys(source)) {\n    const val = source[k];\n    if (val !== undefined) target[k] = val;\n  }\n}\n\nfunction isIterableIterator(value) {\n  return !!value && typeof value.next === \"function\" && typeof value[Symbol.iterator] === \"function\";\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stat = exports.readFile = void 0;\n\nfunction _fs() {\n  const data = require(\"fs\");\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nconst readFile = _gensync()({\n  sync: _fs().readFileSync,\n  errback: _fs().readFile\n});\n\nexports.readFile = readFile;\n\nconst stat = _gensync()({\n  sync: _fs().statSync,\n  errback: _fs().stat\n});\n\nexports.stat = stat;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ROOT_CONFIG_FILENAMES = void 0;\nexports.findConfigUpwards = findConfigUpwards;\nexports.findRelativeConfig = findRelativeConfig;\nexports.findRootConfig = findRootConfig;\nexports.loadConfig = loadConfig;\nexports.resolveShowConfigPath = resolveShowConfigPath;\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  const data = require(\"fs\");\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _json() {\n  const data = require(\"json5\");\n\n  _json = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"../caching\");\n\nvar _configApi = require(\"../helpers/config-api\");\n\nvar _utils = require(\"./utils\");\n\nvar _moduleTypes = require(\"./module-types\");\n\nvar _patternToRegex = require(\"../pattern-to-regex\");\n\nvar fs = require(\"../../gensync-utils/fs\");\n\nfunction _module() {\n  const data = require(\"module\");\n\n  _module = function () {\n    return data;\n  };\n\n  return data;\n}\n\nconst debug = _debug()(\"babel:config:loading:files:configuration\");\n\nconst ROOT_CONFIG_FILENAMES = [\"babel.config.js\", \"babel.config.cjs\", \"babel.config.mjs\", \"babel.config.json\"];\nexports.ROOT_CONFIG_FILENAMES = ROOT_CONFIG_FILENAMES;\nconst RELATIVE_CONFIG_FILENAMES = [\".babelrc\", \".babelrc.js\", \".babelrc.cjs\", \".babelrc.mjs\", \".babelrc.json\"];\nconst BABELIGNORE_FILENAME = \".babelignore\";\n\nfunction findConfigUpwards(rootDir) {\n  let dirname = rootDir;\n\n  for (;;) {\n    for (const filename of ROOT_CONFIG_FILENAMES) {\n      if (_fs().existsSync(_path().join(dirname, filename))) {\n        return dirname;\n      }\n    }\n\n    const nextDir = _path().dirname(dirname);\n\n    if (dirname === nextDir) break;\n    dirname = nextDir;\n  }\n\n  return null;\n}\n\nfunction* findRelativeConfig(packageData, envName, caller) {\n  let config = null;\n  let ignore = null;\n\n  const dirname = _path().dirname(packageData.filepath);\n\n  for (const loc of packageData.directories) {\n    if (!config) {\n      var _packageData$pkg;\n\n      config = yield* loadOneConfig(RELATIVE_CONFIG_FILENAMES, loc, envName, caller, ((_packageData$pkg = packageData.pkg) == null ? void 0 : _packageData$pkg.dirname) === loc ? packageToBabelConfig(packageData.pkg) : null);\n    }\n\n    if (!ignore) {\n      const ignoreLoc = _path().join(loc, BABELIGNORE_FILENAME);\n\n      ignore = yield* readIgnoreConfig(ignoreLoc);\n\n      if (ignore) {\n        debug(\"Found ignore %o from %o.\", ignore.filepath, dirname);\n      }\n    }\n  }\n\n  return {\n    config,\n    ignore\n  };\n}\n\nfunction findRootConfig(dirname, envName, caller) {\n  return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname, envName, caller);\n}\n\nfunction* loadOneConfig(names, dirname, envName, caller, previousConfig = null) {\n  const configs = yield* _gensync().all(names.map(filename => readConfig(_path().join(dirname, filename), envName, caller)));\n  const config = configs.reduce((previousConfig, config) => {\n    if (config && previousConfig) {\n      throw new Error(`Multiple configuration files found. Please remove one:\\n` + ` - ${_path().basename(previousConfig.filepath)}\\n` + ` - ${config.filepath}\\n` + `from ${dirname}`);\n    }\n\n    return config || previousConfig;\n  }, previousConfig);\n\n  if (config) {\n    debug(\"Found configuration %o from %o.\", config.filepath, dirname);\n  }\n\n  return config;\n}\n\nfunction* loadConfig(name, dirname, envName, caller) {\n  const filepath = (((v, w) => (v = v.split(\".\"), w = w.split(\".\"), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, \"8.9\") ? require.resolve : (r, {\n    paths: [b]\n  }, M = require(\"module\")) => {\n    let f = M._findPath(r, M._nodeModulePaths(b).concat(b));\n\n    if (f) return f;\n    f = new Error(`Cannot resolve module '${r}'`);\n    f.code = \"MODULE_NOT_FOUND\";\n    throw f;\n  })(name, {\n    paths: [dirname]\n  });\n  const conf = yield* readConfig(filepath, envName, caller);\n\n  if (!conf) {\n    throw new Error(`Config file ${filepath} contains no configuration data`);\n  }\n\n  debug(\"Loaded config %o from %o.\", name, dirname);\n  return conf;\n}\n\nfunction readConfig(filepath, envName, caller) {\n  const ext = _path().extname(filepath);\n\n  return ext === \".js\" || ext === \".cjs\" || ext === \".mjs\" ? readConfigJS(filepath, {\n    envName,\n    caller\n  }) : readConfigJSON5(filepath);\n}\n\nconst LOADING_CONFIGS = new Set();\nconst readConfigJS = (0, _caching.makeStrongCache)(function* readConfigJS(filepath, cache) {\n  if (!_fs().existsSync(filepath)) {\n    cache.never();\n    return null;\n  }\n\n  if (LOADING_CONFIGS.has(filepath)) {\n    cache.never();\n    debug(\"Auto-ignoring usage of config %o.\", filepath);\n    return {\n      filepath,\n      dirname: _path().dirname(filepath),\n      options: {}\n    };\n  }\n\n  let options;\n\n  try {\n    LOADING_CONFIGS.add(filepath);\n    options = yield* (0, _moduleTypes.default)(filepath, \"You appear to be using a native ECMAScript module configuration \" + \"file, which is only supported when running Babel asynchronously.\");\n  } catch (err) {\n    err.message = `${filepath}: Error while loading config - ${err.message}`;\n    throw err;\n  } finally {\n    LOADING_CONFIGS.delete(filepath);\n  }\n\n  let assertCache = false;\n\n  if (typeof options === \"function\") {\n    yield* [];\n    options = options((0, _configApi.makeConfigAPI)(cache));\n    assertCache = true;\n  }\n\n  if (!options || typeof options !== \"object\" || Array.isArray(options)) {\n    throw new Error(`${filepath}: Configuration should be an exported JavaScript object.`);\n  }\n\n  if (typeof options.then === \"function\") {\n    throw new Error(`You appear to be using an async configuration, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously return your config.`);\n  }\n\n  if (assertCache && !cache.configured()) throwConfigError();\n  return {\n    filepath,\n    dirname: _path().dirname(filepath),\n    options\n  };\n});\nconst packageToBabelConfig = (0, _caching.makeWeakCacheSync)(file => {\n  const babel = file.options[\"babel\"];\n  if (typeof babel === \"undefined\") return null;\n\n  if (typeof babel !== \"object\" || Array.isArray(babel) || babel === null) {\n    throw new Error(`${file.filepath}: .babel property must be an object`);\n  }\n\n  return {\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: babel\n  };\n});\nconst readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {\n  let options;\n\n  try {\n    options = _json().parse(content);\n  } catch (err) {\n    err.message = `${filepath}: Error while parsing config - ${err.message}`;\n    throw err;\n  }\n\n  if (!options) throw new Error(`${filepath}: No config detected`);\n\n  if (typeof options !== \"object\") {\n    throw new Error(`${filepath}: Config returned typeof ${typeof options}`);\n  }\n\n  if (Array.isArray(options)) {\n    throw new Error(`${filepath}: Expected config object but found array`);\n  }\n\n  delete options[\"$schema\"];\n  return {\n    filepath,\n    dirname: _path().dirname(filepath),\n    options\n  };\n});\nconst readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {\n  const ignoreDir = _path().dirname(filepath);\n\n  const ignorePatterns = content.split(\"\\n\").map(line => line.replace(/#(.*?)$/, \"\").trim()).filter(line => !!line);\n\n  for (const pattern of ignorePatterns) {\n    if (pattern[0] === \"!\") {\n      throw new Error(`Negation of file paths is not supported.`);\n    }\n  }\n\n  return {\n    filepath,\n    dirname: _path().dirname(filepath),\n    ignore: ignorePatterns.map(pattern => (0, _patternToRegex.default)(pattern, ignoreDir))\n  };\n});\n\nfunction* resolveShowConfigPath(dirname) {\n  const targetPath = process.env.BABEL_SHOW_CONFIG_FOR;\n\n  if (targetPath != null) {\n    const absolutePath = _path().resolve(dirname, targetPath);\n\n    const stats = yield* fs.stat(absolutePath);\n\n    if (!stats.isFile()) {\n      throw new Error(`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);\n    }\n\n    return absolutePath;\n  }\n\n  return null;\n}\n\nfunction throwConfigError() {\n  throw new Error(`\\\nCaching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don't call this function again.\n  api.cache(true);\n\n  // Don't cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === \"production\");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === \"production\");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};`);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeConfigAPI = makeConfigAPI;\nexports.makePluginAPI = makePluginAPI;\nexports.makePresetAPI = makePresetAPI;\n\nfunction _semver() {\n  const data = require(\"semver\");\n\n  _semver = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ = require(\"../../\");\n\nvar _caching = require(\"../caching\");\n\nvar Context = require(\"../cache-contexts\");\n\nfunction makeConfigAPI(cache) {\n  const env = value => cache.using(data => {\n    if (typeof value === \"undefined\") return data.envName;\n\n    if (typeof value === \"function\") {\n      return (0, _caching.assertSimpleType)(value(data.envName));\n    }\n\n    if (!Array.isArray(value)) value = [value];\n    return value.some(entry => {\n      if (typeof entry !== \"string\") {\n        throw new Error(\"Unexpected non-string value\");\n      }\n\n      return entry === data.envName;\n    });\n  });\n\n  const caller = cb => cache.using(data => (0, _caching.assertSimpleType)(cb(data.caller)));\n\n  return {\n    version: _.version,\n    cache: cache.simple(),\n    env,\n    async: () => false,\n    caller,\n    assertVersion\n  };\n}\n\nfunction makePresetAPI(cache, externalDependencies) {\n  const targets = () => JSON.parse(cache.using(data => JSON.stringify(data.targets)));\n\n  const addExternalDependency = ref => {\n    externalDependencies.push(ref);\n  };\n\n  return Object.assign({}, makeConfigAPI(cache), {\n    targets,\n    addExternalDependency\n  });\n}\n\nfunction makePluginAPI(cache, externalDependencies) {\n  const assumption = name => cache.using(data => data.assumptions[name]);\n\n  return Object.assign({}, makePresetAPI(cache, externalDependencies), {\n    assumption\n  });\n}\n\nfunction assertVersion(range) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n\n    range = `^${range}.0.0-0`;\n  }\n\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n\n  if (_semver().satisfies(_.version, range)) return;\n  const limit = Error.stackTraceLimit;\n\n  if (typeof limit === \"number\" && limit < 25) {\n    Error.stackTraceLimit = 25;\n  }\n\n  const err = new Error(`Requires Babel \"${range}\", but was loaded with \"${_.version}\". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` + `to see what is calling Babel.`);\n\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version: _.version,\n    range\n  });\n}","","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadCjsOrMjsDefault;\nexports.supportsESM = void 0;\n\nvar _async = require(\"../../gensync-utils/async\");\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _url() {\n  const data = require(\"url\");\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _module() {\n  const data = require(\"module\");\n\n  _module = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nlet import_;\n\ntry {\n  import_ = require(\"./import\").default;\n} catch (_unused) {}\n\nconst supportsESM = !!import_;\nexports.supportsESM = supportsESM;\n\nfunction* loadCjsOrMjsDefault(filepath, asyncError, fallbackToTranspiledModule = false) {\n  switch (guessJSModuleType(filepath)) {\n    case \"cjs\":\n      return loadCjsDefault(filepath, fallbackToTranspiledModule);\n\n    case \"unknown\":\n      try {\n        return loadCjsDefault(filepath, fallbackToTranspiledModule);\n      } catch (e) {\n        if (e.code !== \"ERR_REQUIRE_ESM\") throw e;\n      }\n\n    case \"mjs\":\n      if (yield* (0, _async.isAsync)()) {\n        return yield* (0, _async.waitFor)(loadMjsDefault(filepath));\n      }\n\n      throw new Error(asyncError);\n  }\n}\n\nfunction guessJSModuleType(filename) {\n  switch (_path().extname(filename)) {\n    case \".cjs\":\n      return \"cjs\";\n\n    case \".mjs\":\n      return \"mjs\";\n\n    default:\n      return \"unknown\";\n  }\n}\n\nfunction loadCjsDefault(filepath, fallbackToTranspiledModule) {\n  const module = require(filepath);\n\n  return module != null && module.__esModule ? module.default || (fallbackToTranspiledModule ? module : undefined) : module;\n}\n\nfunction loadMjsDefault(_x) {\n  return _loadMjsDefault.apply(this, arguments);\n}\n\nfunction _loadMjsDefault() {\n  _loadMjsDefault = _asyncToGenerator(function* (filepath) {\n    if (!import_) {\n      throw new Error(\"Internal error: Native ECMAScript modules aren't supported\" + \" by this platform.\\n\");\n    }\n\n    const module = yield import_((0, _url().pathToFileURL)(filepath));\n    return module.default;\n  });\n  return _loadMjsDefault.apply(this, arguments);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = pathToPattern;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nconst sep = `\\\\${_path().sep}`;\nconst endSep = `(?:${sep}|$)`;\nconst substitution = `[^${sep}]+`;\nconst starPat = `(?:${substitution}${sep})`;\nconst starPatLast = `(?:${substitution}${endSep})`;\nconst starStarPat = `${starPat}*?`;\nconst starStarPatLast = `${starPat}*?${starPatLast}?`;\n\nfunction escapeRegExp(string) {\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n}\n\nfunction pathToPattern(pattern, dirname) {\n  const parts = _path().resolve(dirname, pattern).split(_path().sep);\n\n  return new RegExp([\"^\", ...parts.map((part, i) => {\n    const last = i === parts.length - 1;\n    if (part === \"**\") return last ? starStarPatLast : starStarPat;\n    if (part === \"*\") return last ? starPatLast : starPat;\n\n    if (part.indexOf(\"*.\") === 0) {\n      return substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep);\n    }\n\n    return escapeRegExp(part) + (last ? endSep : sep);\n  })].join(\"\"));\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadPlugin = loadPlugin;\nexports.loadPreset = loadPreset;\nexports.resolvePlugin = resolvePlugin;\nexports.resolvePreset = resolvePreset;\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../../gensync-utils/async\");\n\nvar _moduleTypes = require(\"./module-types\");\n\nfunction _url() {\n  const data = require(\"url\");\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _importMetaResolve = require(\"./import-meta-resolve\");\n\nfunction _module() {\n  const data = require(\"module\");\n\n  _module = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nconst debug = _debug()(\"babel:config:loading:files:plugins\");\n\nconst EXACT_RE = /^module:/;\nconst BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\\/|babel-plugin-)/;\nconst BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\\/|babel-preset-)/;\nconst BABEL_PLUGIN_ORG_RE = /^(@babel\\/)(?!plugin-|[^/]+\\/)/;\nconst BABEL_PRESET_ORG_RE = /^(@babel\\/)(?!preset-|[^/]+\\/)/;\nconst OTHER_PLUGIN_ORG_RE = /^(@(?!babel\\/)[^/]+\\/)(?![^/]*babel-plugin(?:-|\\/|$)|[^/]+\\/)/;\nconst OTHER_PRESET_ORG_RE = /^(@(?!babel\\/)[^/]+\\/)(?![^/]*babel-preset(?:-|\\/|$)|[^/]+\\/)/;\nconst OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;\n\nfunction* resolvePlugin(name, dirname) {\n  return yield* resolveStandardizedName(\"plugin\", name, dirname);\n}\n\nfunction* resolvePreset(name, dirname) {\n  return yield* resolveStandardizedName(\"preset\", name, dirname);\n}\n\nfunction* loadPlugin(name, dirname) {\n  const filepath = yield* resolvePlugin(name, dirname);\n  const value = yield* requireModule(\"plugin\", filepath);\n  debug(\"Loaded plugin %o from %o.\", name, dirname);\n  return {\n    filepath,\n    value\n  };\n}\n\nfunction* loadPreset(name, dirname) {\n  const filepath = yield* resolvePreset(name, dirname);\n  const value = yield* requireModule(\"preset\", filepath);\n  debug(\"Loaded preset %o from %o.\", name, dirname);\n  return {\n    filepath,\n    value\n  };\n}\n\nfunction standardizeName(type, name) {\n  if (_path().isAbsolute(name)) return name;\n  const isPreset = type === \"preset\";\n  return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`).replace(EXACT_RE, \"\");\n}\n\nfunction* resolveAlternativesHelper(type, name) {\n  const standardizedName = standardizeName(type, name);\n  const {\n    error,\n    value\n  } = yield standardizedName;\n  if (!error) return value;\n  if (error.code !== \"MODULE_NOT_FOUND\") throw error;\n\n  if (standardizedName !== name && !(yield name).error) {\n    error.message += `\\n- If you want to resolve \"${name}\", use \"module:${name}\"`;\n  }\n\n  if (!(yield standardizeName(type, \"@babel/\" + name)).error) {\n    error.message += `\\n- Did you mean \"@babel/${name}\"?`;\n  }\n\n  const oppositeType = type === \"preset\" ? \"plugin\" : \"preset\";\n\n  if (!(yield standardizeName(oppositeType, name)).error) {\n    error.message += `\\n- Did you accidentally pass a ${oppositeType} as a ${type}?`;\n  }\n\n  throw error;\n}\n\nfunction tryRequireResolve(id, {\n  paths: [dirname]\n}) {\n  try {\n    return {\n      error: null,\n      value: (((v, w) => (v = v.split(\".\"), w = w.split(\".\"), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, \"8.9\") ? require.resolve : (r, {\n        paths: [b]\n      }, M = require(\"module\")) => {\n        let f = M._findPath(r, M._nodeModulePaths(b).concat(b));\n\n        if (f) return f;\n        f = new Error(`Cannot resolve module '${r}'`);\n        f.code = \"MODULE_NOT_FOUND\";\n        throw f;\n      })(id, {\n        paths: [dirname]\n      })\n    };\n  } catch (error) {\n    return {\n      error,\n      value: null\n    };\n  }\n}\n\nfunction tryImportMetaResolve(_x, _x2) {\n  return _tryImportMetaResolve.apply(this, arguments);\n}\n\nfunction _tryImportMetaResolve() {\n  _tryImportMetaResolve = _asyncToGenerator(function* (id, options) {\n    try {\n      return {\n        error: null,\n        value: yield (0, _importMetaResolve.default)(id, options)\n      };\n    } catch (error) {\n      return {\n        error,\n        value: null\n      };\n    }\n  });\n  return _tryImportMetaResolve.apply(this, arguments);\n}\n\nfunction resolveStandardizedNameForRequrie(type, name, dirname) {\n  const it = resolveAlternativesHelper(type, name);\n  let res = it.next();\n\n  while (!res.done) {\n    res = it.next(tryRequireResolve(res.value, {\n      paths: [dirname]\n    }));\n  }\n\n  return res.value;\n}\n\nfunction resolveStandardizedNameForImport(_x3, _x4, _x5) {\n  return _resolveStandardizedNameForImport.apply(this, arguments);\n}\n\nfunction _resolveStandardizedNameForImport() {\n  _resolveStandardizedNameForImport = _asyncToGenerator(function* (type, name, dirname) {\n    const parentUrl = (0, _url().pathToFileURL)(_path().join(dirname, \"./babel-virtual-resolve-base.js\")).href;\n    const it = resolveAlternativesHelper(type, name);\n    let res = it.next();\n\n    while (!res.done) {\n      res = it.next(yield tryImportMetaResolve(res.value, parentUrl));\n    }\n\n    return (0, _url().fileURLToPath)(res.value);\n  });\n  return _resolveStandardizedNameForImport.apply(this, arguments);\n}\n\nconst resolveStandardizedName = _gensync()({\n  sync(type, name, dirname = process.cwd()) {\n    return resolveStandardizedNameForRequrie(type, name, dirname);\n  },\n\n  async(type, name, dirname = process.cwd()) {\n    return _asyncToGenerator(function* () {\n      if (!_moduleTypes.supportsESM) {\n        return resolveStandardizedNameForRequrie(type, name, dirname);\n      }\n\n      try {\n        return yield resolveStandardizedNameForImport(type, name, dirname);\n      } catch (e) {\n        try {\n          return resolveStandardizedNameForRequrie(type, name, dirname);\n        } catch (e2) {\n          if (e.type === \"MODULE_NOT_FOUND\") throw e;\n          if (e2.type === \"MODULE_NOT_FOUND\") throw e2;\n          throw e;\n        }\n      }\n    })();\n  }\n\n});\n\n{\n  var LOADING_MODULES = new Set();\n}\n\nfunction* requireModule(type, name) {\n  {\n    if (!(yield* (0, _async.isAsync)()) && LOADING_MODULES.has(name)) {\n      throw new Error(`Reentrant ${type} detected trying to load \"${name}\". This module is not ignored ` + \"and is trying to load itself while compiling itself, leading to a dependency cycle. \" + 'We recommend adding it to your \"ignore\" list in your babelrc, or to a .babelignore.');\n    }\n  }\n\n  try {\n    {\n      LOADING_MODULES.add(name);\n    }\n    return yield* (0, _moduleTypes.default)(name, `You appear to be using a native ECMAScript module ${type}, ` + \"which is only supported when running Babel asynchronously.\", true);\n  } catch (err) {\n    err.message = `[BABEL]: ${err.message} (While processing: ${name})`;\n    throw err;\n  } finally {\n    {\n      LOADING_MODULES.delete(name);\n    }\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = resolve;\n\nfunction _module() {\n  const data = require(\"module\");\n\n  _module = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _importMetaResolve = require(\"../../vendor/import-meta-resolve\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nlet import_;\n\ntry {\n  import_ = require(\"./import\").default;\n} catch (_unused) {}\n\nconst importMetaResolveP = import_ && process.execArgv.includes(\"--experimental-import-meta-resolve\") ? import_(\"data:text/javascript,export default import.meta.resolve\").then(m => m.default || _importMetaResolve.resolve, () => _importMetaResolve.resolve) : Promise.resolve(_importMetaResolve.resolve);\n\nfunction resolve(_x, _x2) {\n  return _resolve.apply(this, arguments);\n}\n\nfunction _resolve() {\n  _resolve = _asyncToGenerator(function* (specifier, parent) {\n    return (yield importMetaResolveP)(specifier, parent);\n  });\n  return _resolve.apply(this, arguments);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.moduleResolve = moduleResolve;\nexports.resolve = resolve;\n\nfunction _url() {\n  const data = require(\"url\");\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  const data = _interopRequireWildcard(require(\"fs\"), true);\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _assert() {\n  const data = require(\"assert\");\n\n  _assert = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _util() {\n  const data = require(\"util\");\n\n  _util = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction createCommonjsModule(fn) {\n  var module = {\n    exports: {}\n  };\n  return fn(module, module.exports), module.exports;\n}\n\nconst SEMVER_SPEC_VERSION = '2.0.0';\nconst MAX_LENGTH$2 = 256;\nconst MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\nconst MAX_SAFE_COMPONENT_LENGTH = 16;\nvar constants = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH: MAX_LENGTH$2,\n  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,\n  MAX_SAFE_COMPONENT_LENGTH\n};\nconst debug = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error('SEMVER', ...args) : () => {};\nvar debug_1 = debug;\nvar re_1 = createCommonjsModule(function (module, exports) {\n  const {\n    MAX_SAFE_COMPONENT_LENGTH\n  } = constants;\n  exports = module.exports = {};\n  const re = exports.re = [];\n  const src = exports.src = [];\n  const t = exports.t = {};\n  let R = 0;\n\n  const createToken = (name, value, isGlobal) => {\n    const index = R++;\n    debug_1(index, value);\n    t[name] = index;\n    src[index] = value;\n    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);\n  };\n\n  createToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*');\n  createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');\n  createToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*');\n  createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` + `(${src[t.NUMERICIDENTIFIER]})\\\\.` + `(${src[t.NUMERICIDENTIFIER]})`);\n  createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n  createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);\n  createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);\n  createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n  createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n  createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');\n  createToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n  createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);\n  createToken('FULL', `^${src[t.FULLPLAIN]}$`);\n  createToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);\n  createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);\n  createToken('GTLT', '((?:<|>)?=?)');\n  createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n  createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n  createToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);\n  createToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);\n  createToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n  createToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n  createToken('COERCE', `${'(^|[^\\\\d])' + '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\\\d])`);\n  createToken('COERCERTL', src[t.COERCE], true);\n  createToken('LONETILDE', '(?:~>?)');\n  createToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n  exports.tildeTrimReplace = '$1~';\n  createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n  createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n  createToken('LONECARET', '(?:\\\\^)');\n  createToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n  exports.caretTrimReplace = '$1^';\n  createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n  createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n  createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n  createToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n  createToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n  exports.comparatorTrimReplace = '$1$2$3';\n  createToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` + `\\\\s+-\\\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\\\s*$`);\n  createToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\\\s+-\\\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\\\s*$`);\n  createToken('STAR', '(<|>)?=?\\\\s*\\\\*');\n  createToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$');\n  createToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$');\n});\nconst opts = ['includePrerelease', 'loose', 'rtl'];\n\nconst parseOptions = options => !options ? {} : typeof options !== 'object' ? {\n  loose: true\n} : opts.filter(k => options[k]).reduce((options, k) => {\n  options[k] = true;\n  return options;\n}, {});\n\nvar parseOptions_1 = parseOptions;\nconst numeric = /^[0-9]+$/;\n\nconst compareIdentifiers$1 = (a, b) => {\n  const anum = numeric.test(a);\n  const bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n};\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);\n\nvar identifiers = {\n  compareIdentifiers: compareIdentifiers$1,\n  rcompareIdentifiers\n};\nconst {\n  MAX_LENGTH: MAX_LENGTH$1,\n  MAX_SAFE_INTEGER\n} = constants;\nconst {\n  re: re$4,\n  t: t$4\n} = re_1;\nconst {\n  compareIdentifiers\n} = identifiers;\n\nclass SemVer {\n  constructor(version, options) {\n    options = parseOptions_1(options);\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {\n        return version;\n      } else {\n        version = version.version;\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`);\n    }\n\n    if (version.length > MAX_LENGTH$1) {\n      throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);\n    }\n\n    debug_1('SemVer', version, options);\n    this.options = options;\n    this.loose = !!options.loose;\n    this.includePrerelease = !!options.includePrerelease;\n    const m = version.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`);\n    }\n\n    this.raw = version;\n    this.major = +m[1];\n    this.minor = +m[2];\n    this.patch = +m[3];\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version');\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version');\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version');\n    }\n\n    if (!m[4]) {\n      this.prerelease = [];\n    } else {\n      this.prerelease = m[4].split('.').map(id => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id;\n\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num;\n          }\n        }\n\n        return id;\n      });\n    }\n\n    this.build = m[5] ? m[5].split('.') : [];\n    this.format();\n  }\n\n  format() {\n    this.version = `${this.major}.${this.minor}.${this.patch}`;\n\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`;\n    }\n\n    return this.version;\n  }\n\n  toString() {\n    return this.version;\n  }\n\n  compare(other) {\n    debug_1('SemVer.compare', this.version, this.options, other);\n\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0;\n      }\n\n      other = new SemVer(other, this.options);\n    }\n\n    if (other.version === this.version) {\n      return 0;\n    }\n\n    return this.compareMain(other) || this.comparePre(other);\n  }\n\n  compareMain(other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n  }\n\n  comparePre(other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1;\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1;\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0;\n    }\n\n    let i = 0;\n\n    do {\n      const a = this.prerelease[i];\n      const b = other.prerelease[i];\n      debug_1('prerelease compare', i, a, b);\n\n      if (a === undefined && b === undefined) {\n        return 0;\n      } else if (b === undefined) {\n        return 1;\n      } else if (a === undefined) {\n        return -1;\n      } else if (a === b) {\n        continue;\n      } else {\n        return compareIdentifiers(a, b);\n      }\n    } while (++i);\n  }\n\n  compareBuild(other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n\n    let i = 0;\n\n    do {\n      const a = this.build[i];\n      const b = other.build[i];\n      debug_1('prerelease compare', i, a, b);\n\n      if (a === undefined && b === undefined) {\n        return 0;\n      } else if (b === undefined) {\n        return 1;\n      } else if (a === undefined) {\n        return -1;\n      } else if (a === b) {\n        continue;\n      } else {\n        return compareIdentifiers(a, b);\n      }\n    } while (++i);\n  }\n\n  inc(release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0;\n        this.patch = 0;\n        this.minor = 0;\n        this.major++;\n        this.inc('pre', identifier);\n        break;\n\n      case 'preminor':\n        this.prerelease.length = 0;\n        this.patch = 0;\n        this.minor++;\n        this.inc('pre', identifier);\n        break;\n\n      case 'prepatch':\n        this.prerelease.length = 0;\n        this.inc('patch', identifier);\n        this.inc('pre', identifier);\n        break;\n\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier);\n        }\n\n        this.inc('pre', identifier);\n        break;\n\n      case 'major':\n        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n          this.major++;\n        }\n\n        this.minor = 0;\n        this.patch = 0;\n        this.prerelease = [];\n        break;\n\n      case 'minor':\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++;\n        }\n\n        this.patch = 0;\n        this.prerelease = [];\n        break;\n\n      case 'patch':\n        if (this.prerelease.length === 0) {\n          this.patch++;\n        }\n\n        this.prerelease = [];\n        break;\n\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0];\n        } else {\n          let i = this.prerelease.length;\n\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++;\n              i = -2;\n            }\n          }\n\n          if (i === -1) {\n            this.prerelease.push(0);\n          }\n        }\n\n        if (identifier) {\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0];\n            }\n          } else {\n            this.prerelease = [identifier, 0];\n          }\n        }\n\n        break;\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`);\n    }\n\n    this.format();\n    this.raw = this.version;\n    return this;\n  }\n\n}\n\nvar semver$1 = SemVer;\nconst {\n  MAX_LENGTH\n} = constants;\nconst {\n  re: re$3,\n  t: t$3\n} = re_1;\n\nconst parse = (version, options) => {\n  options = parseOptions_1(options);\n\n  if (version instanceof semver$1) {\n    return version;\n  }\n\n  if (typeof version !== 'string') {\n    return null;\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null;\n  }\n\n  const r = options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL];\n\n  if (!r.test(version)) {\n    return null;\n  }\n\n  try {\n    return new semver$1(version, options);\n  } catch (er) {\n    return null;\n  }\n};\n\nvar parse_1 = parse;\n\nconst valid$1 = (version, options) => {\n  const v = parse_1(version, options);\n  return v ? v.version : null;\n};\n\nvar valid_1 = valid$1;\n\nconst clean = (version, options) => {\n  const s = parse_1(version.trim().replace(/^[=v]+/, ''), options);\n  return s ? s.version : null;\n};\n\nvar clean_1 = clean;\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof options === 'string') {\n    identifier = options;\n    options = undefined;\n  }\n\n  try {\n    return new semver$1(version, options).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n};\n\nvar inc_1 = inc;\n\nconst compare = (a, b, loose) => new semver$1(a, loose).compare(new semver$1(b, loose));\n\nvar compare_1 = compare;\n\nconst eq = (a, b, loose) => compare_1(a, b, loose) === 0;\n\nvar eq_1 = eq;\n\nconst diff = (version1, version2) => {\n  if (eq_1(version1, version2)) {\n    return null;\n  } else {\n    const v1 = parse_1(version1);\n    const v2 = parse_1(version2);\n    const hasPre = v1.prerelease.length || v2.prerelease.length;\n    const prefix = hasPre ? 'pre' : '';\n    const defaultResult = hasPre ? 'prerelease' : '';\n\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key;\n        }\n      }\n    }\n\n    return defaultResult;\n  }\n};\n\nvar diff_1 = diff;\n\nconst major = (a, loose) => new semver$1(a, loose).major;\n\nvar major_1 = major;\n\nconst minor = (a, loose) => new semver$1(a, loose).minor;\n\nvar minor_1 = minor;\n\nconst patch = (a, loose) => new semver$1(a, loose).patch;\n\nvar patch_1 = patch;\n\nconst prerelease = (version, options) => {\n  const parsed = parse_1(version, options);\n  return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n};\n\nvar prerelease_1 = prerelease;\n\nconst rcompare = (a, b, loose) => compare_1(b, a, loose);\n\nvar rcompare_1 = rcompare;\n\nconst compareLoose = (a, b) => compare_1(a, b, true);\n\nvar compareLoose_1 = compareLoose;\n\nconst compareBuild = (a, b, loose) => {\n  const versionA = new semver$1(a, loose);\n  const versionB = new semver$1(b, loose);\n  return versionA.compare(versionB) || versionA.compareBuild(versionB);\n};\n\nvar compareBuild_1 = compareBuild;\n\nconst sort = (list, loose) => list.sort((a, b) => compareBuild_1(a, b, loose));\n\nvar sort_1 = sort;\n\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild_1(b, a, loose));\n\nvar rsort_1 = rsort;\n\nconst gt = (a, b, loose) => compare_1(a, b, loose) > 0;\n\nvar gt_1 = gt;\n\nconst lt = (a, b, loose) => compare_1(a, b, loose) < 0;\n\nvar lt_1 = lt;\n\nconst neq = (a, b, loose) => compare_1(a, b, loose) !== 0;\n\nvar neq_1 = neq;\n\nconst gte = (a, b, loose) => compare_1(a, b, loose) >= 0;\n\nvar gte_1 = gte;\n\nconst lte = (a, b, loose) => compare_1(a, b, loose) <= 0;\n\nvar lte_1 = lte;\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      return a === b;\n\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      return a !== b;\n\n    case '':\n    case '=':\n    case '==':\n      return eq_1(a, b, loose);\n\n    case '!=':\n      return neq_1(a, b, loose);\n\n    case '>':\n      return gt_1(a, b, loose);\n\n    case '>=':\n      return gte_1(a, b, loose);\n\n    case '<':\n      return lt_1(a, b, loose);\n\n    case '<=':\n      return lte_1(a, b, loose);\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`);\n  }\n};\n\nvar cmp_1 = cmp;\nconst {\n  re: re$2,\n  t: t$2\n} = re_1;\n\nconst coerce = (version, options) => {\n  if (version instanceof semver$1) {\n    return version;\n  }\n\n  if (typeof version === 'number') {\n    version = String(version);\n  }\n\n  if (typeof version !== 'string') {\n    return null;\n  }\n\n  options = options || {};\n  let match = null;\n\n  if (!options.rtl) {\n    match = version.match(re$2[t$2.COERCE]);\n  } else {\n    let next;\n\n    while ((next = re$2[t$2.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n      if (!match || next.index + next[0].length !== match.index + match[0].length) {\n        match = next;\n      }\n\n      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n    }\n\n    re$2[t$2.COERCERTL].lastIndex = -1;\n  }\n\n  if (match === null) return null;\n  return parse_1(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options);\n};\n\nvar coerce_1 = coerce;\n\nvar iterator = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value;\n    }\n  };\n};\n\nvar yallist = Yallist;\nYallist.Node = Node;\nYallist.create = Yallist;\n\nfunction Yallist(list) {\n  var self = this;\n\n  if (!(self instanceof Yallist)) {\n    self = new Yallist();\n  }\n\n  self.tail = null;\n  self.head = null;\n  self.length = 0;\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item);\n    });\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i]);\n    }\n  }\n\n  return self;\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list');\n  }\n\n  var next = node.next;\n  var prev = node.prev;\n\n  if (next) {\n    next.prev = prev;\n  }\n\n  if (prev) {\n    prev.next = next;\n  }\n\n  if (node === this.head) {\n    this.head = next;\n  }\n\n  if (node === this.tail) {\n    this.tail = prev;\n  }\n\n  node.list.length--;\n  node.next = null;\n  node.prev = null;\n  node.list = null;\n  return next;\n};\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var head = this.head;\n  node.list = this;\n  node.next = head;\n\n  if (head) {\n    head.prev = node;\n  }\n\n  this.head = node;\n\n  if (!this.tail) {\n    this.tail = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var tail = this.tail;\n  node.list = this;\n  node.prev = tail;\n\n  if (tail) {\n    tail.next = node;\n  }\n\n  this.tail = node;\n\n  if (!this.head) {\n    this.head = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined;\n  }\n\n  var res = this.tail.value;\n  this.tail = this.tail.prev;\n\n  if (this.tail) {\n    this.tail.next = null;\n  } else {\n    this.head = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined;\n  }\n\n  var res = this.head.value;\n  this.head = this.head.next;\n\n  if (this.head) {\n    this.head.prev = null;\n  } else {\n    this.tail = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.next;\n  }\n};\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.prev;\n  }\n};\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    walker = walker.next;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    walker = walker.prev;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.next;\n  }\n\n  return res;\n};\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.prev;\n  }\n\n  return res;\n};\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc;\n  var walker = this.head;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.head) {\n    walker = this.head.next;\n    acc = this.head.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.next;\n  }\n\n  return acc;\n};\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc;\n  var walker = this.tail;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.tail) {\n    walker = this.tail.prev;\n    acc = this.tail.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.prev;\n  }\n\n  return acc;\n};\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.next;\n  }\n\n  return arr;\n};\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.prev;\n  }\n\n  return arr;\n};\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next;\n  }\n\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev;\n  }\n\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1;\n  }\n\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next;\n  }\n\n  var ret = [];\n\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value);\n    walker = this.removeNode(walker);\n  }\n\n  if (walker === null) {\n    walker = this.tail;\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev;\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i]);\n  }\n\n  return ret;\n};\n\nYallist.prototype.reverse = function () {\n  var head = this.head;\n  var tail = this.tail;\n\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev;\n    walker.prev = walker.next;\n    walker.next = p;\n  }\n\n  this.head = tail;\n  this.tail = head;\n  return this;\n};\n\nfunction insert(self, node, value) {\n  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);\n\n  if (inserted.next === null) {\n    self.tail = inserted;\n  }\n\n  if (inserted.prev === null) {\n    self.head = inserted;\n  }\n\n  self.length++;\n  return inserted;\n}\n\nfunction push(self, item) {\n  self.tail = new Node(item, self.tail, null, self);\n\n  if (!self.head) {\n    self.head = self.tail;\n  }\n\n  self.length++;\n}\n\nfunction unshift(self, item) {\n  self.head = new Node(item, null, self.head, self);\n\n  if (!self.tail) {\n    self.tail = self.head;\n  }\n\n  self.length++;\n}\n\nfunction Node(value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list);\n  }\n\n  this.list = list;\n  this.value = value;\n\n  if (prev) {\n    prev.next = this;\n    this.prev = prev;\n  } else {\n    this.prev = null;\n  }\n\n  if (next) {\n    next.prev = this;\n    this.next = next;\n  } else {\n    this.next = null;\n  }\n}\n\ntry {\n  iterator(Yallist);\n} catch (er) {}\n\nconst MAX = Symbol('max');\nconst LENGTH = Symbol('length');\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator');\nconst ALLOW_STALE = Symbol('allowStale');\nconst MAX_AGE = Symbol('maxAge');\nconst DISPOSE = Symbol('dispose');\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');\nconst LRU_LIST = Symbol('lruList');\nconst CACHE = Symbol('cache');\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');\n\nconst naiveLength = () => 1;\n\nclass LRUCache {\n  constructor(options) {\n    if (typeof options === 'number') options = {\n      max: options\n    };\n    if (!options) options = {};\n    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');\n    this[MAX] = options.max || Infinity;\n    const lc = options.length || naiveLength;\n    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;\n    this[ALLOW_STALE] = options.stale || false;\n    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');\n    this[MAX_AGE] = options.maxAge || 0;\n    this[DISPOSE] = options.dispose;\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;\n    this.reset();\n  }\n\n  set max(mL) {\n    if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');\n    this[MAX] = mL || Infinity;\n    trim(this);\n  }\n\n  get max() {\n    return this[MAX];\n  }\n\n  set allowStale(allowStale) {\n    this[ALLOW_STALE] = !!allowStale;\n  }\n\n  get allowStale() {\n    return this[ALLOW_STALE];\n  }\n\n  set maxAge(mA) {\n    if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');\n    this[MAX_AGE] = mA;\n    trim(this);\n  }\n\n  get maxAge() {\n    return this[MAX_AGE];\n  }\n\n  set lengthCalculator(lC) {\n    if (typeof lC !== 'function') lC = naiveLength;\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC;\n      this[LENGTH] = 0;\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n        this[LENGTH] += hit.length;\n      });\n    }\n\n    trim(this);\n  }\n\n  get lengthCalculator() {\n    return this[LENGTH_CALCULATOR];\n  }\n\n  get length() {\n    return this[LENGTH];\n  }\n\n  get itemCount() {\n    return this[LRU_LIST].length;\n  }\n\n  rforEach(fn, thisp) {\n    thisp = thisp || this;\n\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev;\n      forEachStep(this, fn, walker, thisp);\n      walker = prev;\n    }\n  }\n\n  forEach(fn, thisp) {\n    thisp = thisp || this;\n\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next;\n      forEachStep(this, fn, walker, thisp);\n      walker = next;\n    }\n  }\n\n  keys() {\n    return this[LRU_LIST].toArray().map(k => k.key);\n  }\n\n  values() {\n    return this[LRU_LIST].toArray().map(k => k.value);\n  }\n\n  reset() {\n    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));\n    }\n\n    this[CACHE] = new Map();\n    this[LRU_LIST] = new yallist();\n    this[LENGTH] = 0;\n  }\n\n  dump() {\n    return this[LRU_LIST].map(hit => isStale(this, hit) ? false : {\n      k: hit.key,\n      v: hit.value,\n      e: hit.now + (hit.maxAge || 0)\n    }).toArray().filter(h => h);\n  }\n\n  dumpLru() {\n    return this[LRU_LIST];\n  }\n\n  set(key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE];\n    if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');\n    const now = maxAge ? Date.now() : 0;\n    const len = this[LENGTH_CALCULATOR](value, key);\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key));\n        return false;\n      }\n\n      const node = this[CACHE].get(key);\n      const item = node.value;\n\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);\n      }\n\n      item.now = now;\n      item.maxAge = maxAge;\n      item.value = value;\n      this[LENGTH] += len - item.length;\n      item.length = len;\n      this.get(key);\n      trim(this);\n      return true;\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge);\n\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE]) this[DISPOSE](key, value);\n      return false;\n    }\n\n    this[LENGTH] += hit.length;\n    this[LRU_LIST].unshift(hit);\n    this[CACHE].set(key, this[LRU_LIST].head);\n    trim(this);\n    return true;\n  }\n\n  has(key) {\n    if (!this[CACHE].has(key)) return false;\n    const hit = this[CACHE].get(key).value;\n    return !isStale(this, hit);\n  }\n\n  get(key) {\n    return get(this, key, true);\n  }\n\n  peek(key) {\n    return get(this, key, false);\n  }\n\n  pop() {\n    const node = this[LRU_LIST].tail;\n    if (!node) return null;\n    del(this, node);\n    return node.value;\n  }\n\n  del(key) {\n    del(this, this[CACHE].get(key));\n  }\n\n  load(arr) {\n    this.reset();\n    const now = Date.now();\n\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l];\n      const expiresAt = hit.e || 0;\n      if (expiresAt === 0) this.set(hit.k, hit.v);else {\n        const maxAge = expiresAt - now;\n\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge);\n        }\n      }\n    }\n  }\n\n  prune() {\n    this[CACHE].forEach((value, key) => get(this, key, false));\n  }\n\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key);\n\n  if (node) {\n    const hit = node.value;\n\n    if (isStale(self, hit)) {\n      del(self, node);\n      if (!self[ALLOW_STALE]) return undefined;\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();\n        self[LRU_LIST].unshiftNode(node);\n      }\n    }\n\n    return hit.value;\n  }\n};\n\nconst isStale = (self, hit) => {\n  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;\n  const diff = Date.now() - hit.now;\n  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];\n};\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {\n      const prev = walker.prev;\n      del(self, walker);\n      walker = prev;\n    }\n  }\n};\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value;\n    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);\n    self[LENGTH] -= hit.length;\n    self[CACHE].delete(hit.key);\n    self[LRU_LIST].removeNode(node);\n  }\n};\n\nclass Entry {\n  constructor(key, value, length, now, maxAge) {\n    this.key = key;\n    this.value = value;\n    this.length = length;\n    this.now = now;\n    this.maxAge = maxAge || 0;\n  }\n\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value;\n\n  if (isStale(self, hit)) {\n    del(self, node);\n    if (!self[ALLOW_STALE]) hit = undefined;\n  }\n\n  if (hit) fn.call(thisp, hit.value, hit.key, self);\n};\n\nvar lruCache = LRUCache;\n\nclass Range {\n  constructor(range, options) {\n    options = parseOptions_1(options);\n\n    if (range instanceof Range) {\n      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n        return range;\n      } else {\n        return new Range(range.raw, options);\n      }\n    }\n\n    if (range instanceof comparator) {\n      this.raw = range.value;\n      this.set = [[range]];\n      this.format();\n      return this;\n    }\n\n    this.options = options;\n    this.loose = !!options.loose;\n    this.includePrerelease = !!options.includePrerelease;\n    this.raw = range;\n    this.set = range.split(/\\s*\\|\\|\\s*/).map(range => this.parseRange(range.trim())).filter(c => c.length);\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`);\n    }\n\n    if (this.set.length > 1) {\n      const first = this.set[0];\n      this.set = this.set.filter(c => !isNullSet(c[0]));\n      if (this.set.length === 0) this.set = [first];else if (this.set.length > 1) {\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c];\n            break;\n          }\n        }\n      }\n    }\n\n    this.format();\n  }\n\n  format() {\n    this.range = this.set.map(comps => {\n      return comps.join(' ').trim();\n    }).join('||').trim();\n    return this.range;\n  }\n\n  toString() {\n    return this.range;\n  }\n\n  parseRange(range) {\n    range = range.trim();\n    const memoOpts = Object.keys(this.options).join(',');\n    const memoKey = `parseRange:${memoOpts}:${range}`;\n    const cached = cache.get(memoKey);\n    if (cached) return cached;\n    const loose = this.options.loose;\n    const hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));\n    debug_1('hyphen replace', range);\n    range = range.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace);\n    debug_1('comparator trim', range, re$1[t$1.COMPARATORTRIM]);\n    range = range.replace(re$1[t$1.TILDETRIM], tildeTrimReplace);\n    range = range.replace(re$1[t$1.CARETTRIM], caretTrimReplace);\n    range = range.split(/\\s+/).join(' ');\n    const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR];\n    const rangeList = range.split(' ').map(comp => parseComparator(comp, this.options)).join(' ').split(/\\s+/).map(comp => replaceGTE0(comp, this.options)).filter(this.options.loose ? comp => !!comp.match(compRe) : () => true).map(comp => new comparator(comp, this.options));\n    rangeList.length;\n    const rangeMap = new Map();\n\n    for (const comp of rangeList) {\n      if (isNullSet(comp)) return [comp];\n      rangeMap.set(comp.value, comp);\n    }\n\n    if (rangeMap.size > 1 && rangeMap.has('')) rangeMap.delete('');\n    const result = [...rangeMap.values()];\n    cache.set(memoKey, result);\n    return result;\n  }\n\n  intersects(range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required');\n    }\n\n    return this.set.some(thisComparators => {\n      return isSatisfiable(thisComparators, options) && range.set.some(rangeComparators => {\n        return isSatisfiable(rangeComparators, options) && thisComparators.every(thisComparator => {\n          return rangeComparators.every(rangeComparator => {\n            return thisComparator.intersects(rangeComparator, options);\n          });\n        });\n      });\n    });\n  }\n\n  test(version) {\n    if (!version) {\n      return false;\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new semver$1(version, this.options);\n      } catch (er) {\n        return false;\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nvar range = Range;\nconst cache = new lruCache({\n  max: 1000\n});\nconst {\n  re: re$1,\n  t: t$1,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = re_1;\n\nconst isNullSet = c => c.value === '<0.0.0-0';\n\nconst isAny = c => c.value === '';\n\nconst isSatisfiable = (comparators, options) => {\n  let result = true;\n  const remainingComparators = comparators.slice();\n  let testComparator = remainingComparators.pop();\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every(otherComparator => {\n      return testComparator.intersects(otherComparator, options);\n    });\n    testComparator = remainingComparators.pop();\n  }\n\n  return result;\n};\n\nconst parseComparator = (comp, options) => {\n  debug_1('comp', comp, options);\n  comp = replaceCarets(comp, options);\n  debug_1('caret', comp);\n  comp = replaceTildes(comp, options);\n  debug_1('tildes', comp);\n  comp = replaceXRanges(comp, options);\n  debug_1('xrange', comp);\n  comp = replaceStars(comp, options);\n  debug_1('stars', comp);\n  return comp;\n};\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*';\n\nconst replaceTildes = (comp, options) => comp.trim().split(/\\s+/).map(comp => {\n  return replaceTilde(comp, options);\n}).join(' ');\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug_1('tilde', comp, _, M, m, p, pr);\n    let ret;\n\n    if (isX(M)) {\n      ret = '';\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;\n    } else if (isX(p)) {\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;\n    } else if (pr) {\n      debug_1('replaceTilde pr', pr);\n      ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n    } else {\n      ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;\n    }\n\n    debug_1('tilde return', ret);\n    return ret;\n  });\n};\n\nconst replaceCarets = (comp, options) => comp.trim().split(/\\s+/).map(comp => {\n  return replaceCaret(comp, options);\n}).join(' ');\n\nconst replaceCaret = (comp, options) => {\n  debug_1('caret', comp, options);\n  const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET];\n  const z = options.includePrerelease ? '-0' : '';\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug_1('caret', comp, _, M, m, p, pr);\n    let ret;\n\n    if (isX(M)) {\n      ret = '';\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;\n      }\n    } else if (pr) {\n      debug_1('replaceCaret pr', pr);\n\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;\n      }\n    } else {\n      debug_1('no pr');\n\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;\n        } else {\n          ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;\n        }\n      } else {\n        ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;\n      }\n    }\n\n    debug_1('caret return', ret);\n    return ret;\n  });\n};\n\nconst replaceXRanges = (comp, options) => {\n  debug_1('replaceXRanges', comp, options);\n  return comp.split(/\\s+/).map(comp => {\n    return replaceXRange(comp, options);\n  }).join(' ');\n};\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim();\n  const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug_1('xRange', comp, ret, gtlt, M, m, p, pr);\n    const xM = isX(M);\n    const xm = xM || isX(m);\n    const xp = xm || isX(p);\n    const anyX = xp;\n\n    if (gtlt === '=' && anyX) {\n      gtlt = '';\n    }\n\n    pr = options.includePrerelease ? '-0' : '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        ret = '<0.0.0-0';\n      } else {\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      if (xm) {\n        m = 0;\n      }\n\n      p = 0;\n\n      if (gtlt === '>') {\n        gtlt = '>=';\n\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        gtlt = '<';\n\n        if (xm) {\n          M = +M + 1;\n        } else {\n          m = +m + 1;\n        }\n      }\n\n      if (gtlt === '<') pr = '-0';\n      ret = `${gtlt + M}.${m}.${p}${pr}`;\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;\n    }\n\n    debug_1('xRange return', ret);\n    return ret;\n  });\n};\n\nconst replaceStars = (comp, options) => {\n  debug_1('replaceStars', comp, options);\n  return comp.trim().replace(re$1[t$1.STAR], '');\n};\n\nconst replaceGTE0 = (comp, options) => {\n  debug_1('replaceGTE0', comp, options);\n  return comp.trim().replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], '');\n};\n\nconst hyphenReplace = incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = '';\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;\n  } else if (fpr) {\n    from = `>=${from}`;\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`;\n  }\n\n  if (isX(tM)) {\n    to = '';\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`;\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`;\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`;\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`;\n  } else {\n    to = `<=${to}`;\n  }\n\n  return `${from} ${to}`.trim();\n};\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false;\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    for (let i = 0; i < set.length; i++) {\n      debug_1(set[i].semver);\n\n      if (set[i].semver === comparator.ANY) {\n        continue;\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver;\n\n        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return true;\n};\n\nconst ANY$2 = Symbol('SemVer ANY');\n\nclass Comparator {\n  static get ANY() {\n    return ANY$2;\n  }\n\n  constructor(comp, options) {\n    options = parseOptions_1(options);\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp;\n      } else {\n        comp = comp.value;\n      }\n    }\n\n    debug_1('comparator', comp, options);\n    this.options = options;\n    this.loose = !!options.loose;\n    this.parse(comp);\n\n    if (this.semver === ANY$2) {\n      this.value = '';\n    } else {\n      this.value = this.operator + this.semver.version;\n    }\n\n    debug_1('comp', this);\n  }\n\n  parse(comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n    const m = comp.match(r);\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`);\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : '';\n\n    if (this.operator === '=') {\n      this.operator = '';\n    }\n\n    if (!m[2]) {\n      this.semver = ANY$2;\n    } else {\n      this.semver = new semver$1(m[2], this.options.loose);\n    }\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  test(version) {\n    debug_1('Comparator.test', version, this.options.loose);\n\n    if (this.semver === ANY$2 || version === ANY$2) {\n      return true;\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new semver$1(version, this.options);\n      } catch (er) {\n        return false;\n      }\n    }\n\n    return cmp_1(version, this.operator, this.semver, this.options);\n  }\n\n  intersects(comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required');\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      };\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true;\n      }\n\n      return new range(comp.value, options).test(this.value);\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true;\n      }\n\n      return new range(this.value, options).test(comp.semver);\n    }\n\n    const sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');\n    const sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');\n    const sameSemVer = this.semver.version === comp.semver.version;\n    const differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');\n    const oppositeDirectionsLessThan = cmp_1(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');\n    const oppositeDirectionsGreaterThan = cmp_1(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');\n    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n  }\n\n}\n\nvar comparator = Comparator;\nconst {\n  re,\n  t\n} = re_1;\n\nconst satisfies = (version, range$1, options) => {\n  try {\n    range$1 = new range(range$1, options);\n  } catch (er) {\n    return false;\n  }\n\n  return range$1.test(version);\n};\n\nvar satisfies_1 = satisfies;\n\nconst toComparators = (range$1, options) => new range(range$1, options).set.map(comp => comp.map(c => c.value).join(' ').trim().split(' '));\n\nvar toComparators_1 = toComparators;\n\nconst maxSatisfying = (versions, range$1, options) => {\n  let max = null;\n  let maxSV = null;\n  let rangeObj = null;\n\n  try {\n    rangeObj = new range(range$1, options);\n  } catch (er) {\n    return null;\n  }\n\n  versions.forEach(v => {\n    if (rangeObj.test(v)) {\n      if (!max || maxSV.compare(v) === -1) {\n        max = v;\n        maxSV = new semver$1(max, options);\n      }\n    }\n  });\n  return max;\n};\n\nvar maxSatisfying_1 = maxSatisfying;\n\nconst minSatisfying = (versions, range$1, options) => {\n  let min = null;\n  let minSV = null;\n  let rangeObj = null;\n\n  try {\n    rangeObj = new range(range$1, options);\n  } catch (er) {\n    return null;\n  }\n\n  versions.forEach(v => {\n    if (rangeObj.test(v)) {\n      if (!min || minSV.compare(v) === 1) {\n        min = v;\n        minSV = new semver$1(min, options);\n      }\n    }\n  });\n  return min;\n};\n\nvar minSatisfying_1 = minSatisfying;\n\nconst minVersion = (range$1, loose) => {\n  range$1 = new range(range$1, loose);\n  let minver = new semver$1('0.0.0');\n\n  if (range$1.test(minver)) {\n    return minver;\n  }\n\n  minver = new semver$1('0.0.0-0');\n\n  if (range$1.test(minver)) {\n    return minver;\n  }\n\n  minver = null;\n\n  for (let i = 0; i < range$1.set.length; ++i) {\n    const comparators = range$1.set[i];\n    let setMin = null;\n    comparators.forEach(comparator => {\n      const compver = new semver$1(comparator.semver.version);\n\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++;\n          } else {\n            compver.prerelease.push(0);\n          }\n\n          compver.raw = compver.format();\n\n        case '':\n        case '>=':\n          if (!setMin || gt_1(compver, setMin)) {\n            setMin = compver;\n          }\n\n          break;\n\n        case '<':\n        case '<=':\n          break;\n\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`);\n      }\n    });\n    if (setMin && (!minver || gt_1(minver, setMin))) minver = setMin;\n  }\n\n  if (minver && range$1.test(minver)) {\n    return minver;\n  }\n\n  return null;\n};\n\nvar minVersion_1 = minVersion;\n\nconst validRange = (range$1, options) => {\n  try {\n    return new range(range$1, options).range || '*';\n  } catch (er) {\n    return null;\n  }\n};\n\nvar valid = validRange;\nconst {\n  ANY: ANY$1\n} = comparator;\n\nconst outside = (version, range$1, hilo, options) => {\n  version = new semver$1(version, options);\n  range$1 = new range(range$1, options);\n  let gtfn, ltefn, ltfn, comp, ecomp;\n\n  switch (hilo) {\n    case '>':\n      gtfn = gt_1;\n      ltefn = lte_1;\n      ltfn = lt_1;\n      comp = '>';\n      ecomp = '>=';\n      break;\n\n    case '<':\n      gtfn = lt_1;\n      ltefn = gte_1;\n      ltfn = gt_1;\n      comp = '<';\n      ecomp = '<=';\n      break;\n\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  if (satisfies_1(version, range$1, options)) {\n    return false;\n  }\n\n  for (let i = 0; i < range$1.set.length; ++i) {\n    const comparators = range$1.set[i];\n    let high = null;\n    let low = null;\n    comparators.forEach(comparator$1 => {\n      if (comparator$1.semver === ANY$1) {\n        comparator$1 = new comparator('>=0.0.0');\n      }\n\n      high = high || comparator$1;\n      low = low || comparator$1;\n\n      if (gtfn(comparator$1.semver, high.semver, options)) {\n        high = comparator$1;\n      } else if (ltfn(comparator$1.semver, low.semver, options)) {\n        low = comparator$1;\n      }\n    });\n\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar outside_1 = outside;\n\nconst gtr = (version, range, options) => outside_1(version, range, '>', options);\n\nvar gtr_1 = gtr;\n\nconst ltr = (version, range, options) => outside_1(version, range, '<', options);\n\nvar ltr_1 = ltr;\n\nconst intersects = (r1, r2, options) => {\n  r1 = new range(r1, options);\n  r2 = new range(r2, options);\n  return r1.intersects(r2);\n};\n\nvar intersects_1 = intersects;\n\nvar simplify = (versions, range, options) => {\n  const set = [];\n  let min = null;\n  let prev = null;\n  const v = versions.sort((a, b) => compare_1(a, b, options));\n\n  for (const version of v) {\n    const included = satisfies_1(version, range, options);\n\n    if (included) {\n      prev = version;\n      if (!min) min = version;\n    } else {\n      if (prev) {\n        set.push([min, prev]);\n      }\n\n      prev = null;\n      min = null;\n    }\n  }\n\n  if (min) set.push([min, null]);\n  const ranges = [];\n\n  for (const [min, max] of set) {\n    if (min === max) ranges.push(min);else if (!max && min === v[0]) ranges.push('*');else if (!max) ranges.push(`>=${min}`);else if (min === v[0]) ranges.push(`<=${max}`);else ranges.push(`${min} - ${max}`);\n  }\n\n  const simplified = ranges.join(' || ');\n  const original = typeof range.raw === 'string' ? range.raw : String(range);\n  return simplified.length < original.length ? simplified : range;\n};\n\nconst {\n  ANY\n} = comparator;\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) return true;\n  sub = new range(sub, options);\n  dom = new range(dom, options);\n  let sawNonNull = false;\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options);\n      sawNonNull = sawNonNull || isSub !== null;\n      if (isSub) continue OUTER;\n    }\n\n    if (sawNonNull) return false;\n  }\n\n  return true;\n};\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) return true;\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) return true;else if (options.includePrerelease) sub = [new comparator('>=0.0.0-0')];else sub = [new comparator('>=0.0.0')];\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) return true;else dom = [new comparator('>=0.0.0')];\n  }\n\n  const eqSet = new Set();\n  let gt, lt;\n\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') gt = higherGT(gt, c, options);else if (c.operator === '<' || c.operator === '<=') lt = lowerLT(lt, c, options);else eqSet.add(c.semver);\n  }\n\n  if (eqSet.size > 1) return null;\n  let gtltComp;\n\n  if (gt && lt) {\n    gtltComp = compare_1(gt.semver, lt.semver, options);\n    if (gtltComp > 0) return null;else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) return null;\n  }\n\n  for (const eq of eqSet) {\n    if (gt && !satisfies_1(eq, String(gt), options)) return null;\n    if (lt && !satisfies_1(eq, String(lt), options)) return null;\n\n    for (const c of dom) {\n      if (!satisfies_1(eq, String(c), options)) return false;\n    }\n\n    return true;\n  }\n\n  let higher, lower;\n  let hasDomLT, hasDomGT;\n  let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;\n  let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;\n\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false;\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';\n\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false;\n        }\n      }\n\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options);\n        if (higher === c && higher !== gt) return false;\n      } else if (gt.operator === '>=' && !satisfies_1(gt.semver, String(c), options)) return false;\n    }\n\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false;\n        }\n      }\n\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options);\n        if (lower === c && lower !== lt) return false;\n      } else if (lt.operator === '<=' && !satisfies_1(lt.semver, String(c), options)) return false;\n    }\n\n    if (!c.operator && (lt || gt) && gtltComp !== 0) return false;\n  }\n\n  if (gt && hasDomLT && !lt && gtltComp !== 0) return false;\n  if (lt && hasDomGT && !gt && gtltComp !== 0) return false;\n  if (needDomGTPre || needDomLTPre) return false;\n  return true;\n};\n\nconst higherGT = (a, b, options) => {\n  if (!a) return b;\n  const comp = compare_1(a.semver, b.semver, options);\n  return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;\n};\n\nconst lowerLT = (a, b, options) => {\n  if (!a) return b;\n  const comp = compare_1(a.semver, b.semver, options);\n  return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;\n};\n\nvar subset_1 = subset;\nvar semver = {\n  re: re_1.re,\n  src: re_1.src,\n  tokens: re_1.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  SemVer: semver$1,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n  parse: parse_1,\n  valid: valid_1,\n  clean: clean_1,\n  inc: inc_1,\n  diff: diff_1,\n  major: major_1,\n  minor: minor_1,\n  patch: patch_1,\n  prerelease: prerelease_1,\n  compare: compare_1,\n  rcompare: rcompare_1,\n  compareLoose: compareLoose_1,\n  compareBuild: compareBuild_1,\n  sort: sort_1,\n  rsort: rsort_1,\n  gt: gt_1,\n  lt: lt_1,\n  eq: eq_1,\n  neq: neq_1,\n  gte: gte_1,\n  lte: lte_1,\n  cmp: cmp_1,\n  coerce: coerce_1,\n  Comparator: comparator,\n  Range: range,\n  satisfies: satisfies_1,\n  toComparators: toComparators_1,\n  maxSatisfying: maxSatisfying_1,\n  minSatisfying: minSatisfying_1,\n  minVersion: minVersion_1,\n  validRange: valid,\n  outside: outside_1,\n  gtr: gtr_1,\n  ltr: ltr_1,\n  intersects: intersects_1,\n  simplifyRange: simplify,\n  subset: subset_1\n};\n\nvar builtins = function ({\n  version = process.version,\n  experimental = false\n} = {}) {\n  var coreModules = ['assert', 'buffer', 'child_process', 'cluster', 'console', 'constants', 'crypto', 'dgram', 'dns', 'domain', 'events', 'fs', 'http', 'https', 'module', 'net', 'os', 'path', 'punycode', 'querystring', 'readline', 'repl', 'stream', 'string_decoder', 'sys', 'timers', 'tls', 'tty', 'url', 'util', 'vm', 'zlib'];\n  if (semver.lt(version, '6.0.0')) coreModules.push('freelist');\n  if (semver.gte(version, '1.0.0')) coreModules.push('v8');\n  if (semver.gte(version, '1.1.0')) coreModules.push('process');\n  if (semver.gte(version, '8.0.0')) coreModules.push('inspector');\n  if (semver.gte(version, '8.1.0')) coreModules.push('async_hooks');\n  if (semver.gte(version, '8.4.0')) coreModules.push('http2');\n  if (semver.gte(version, '8.5.0')) coreModules.push('perf_hooks');\n  if (semver.gte(version, '10.0.0')) coreModules.push('trace_events');\n\n  if (semver.gte(version, '10.5.0') && (experimental || semver.gte(version, '12.0.0'))) {\n    coreModules.push('worker_threads');\n  }\n\n  if (semver.gte(version, '12.16.0') && experimental) {\n    coreModules.push('wasi');\n  }\n\n  return coreModules;\n};\n\nconst reader = {\n  read\n};\n\nfunction read(jsonPath) {\n  return find(_path().dirname(jsonPath));\n}\n\nfunction find(dir) {\n  try {\n    const string = _fs().default.readFileSync(_path().toNamespacedPath(_path().join(dir, 'package.json')), 'utf8');\n\n    return {\n      string\n    };\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      const parent = _path().dirname(dir);\n\n      if (dir !== parent) return find(parent);\n      return {\n        string: undefined\n      };\n    }\n\n    throw error;\n  }\n}\n\nconst isWindows = process.platform === 'win32';\nconst own$1 = {}.hasOwnProperty;\nconst codes = {};\nconst messages = new Map();\nconst nodeInternalPrefix = '__node_internal_';\nlet userStackTraceLimit;\ncodes.ERR_INVALID_MODULE_SPECIFIER = createError('ERR_INVALID_MODULE_SPECIFIER', (request, reason, base = undefined) => {\n  return `Invalid module \"${request}\" ${reason}${base ? ` imported from ${base}` : ''}`;\n}, TypeError);\ncodes.ERR_INVALID_PACKAGE_CONFIG = createError('ERR_INVALID_PACKAGE_CONFIG', (path, base, message) => {\n  return `Invalid package config ${path}${base ? ` while importing ${base}` : ''}${message ? `. ${message}` : ''}`;\n}, Error);\ncodes.ERR_INVALID_PACKAGE_TARGET = createError('ERR_INVALID_PACKAGE_TARGET', (pkgPath, key, target, isImport = false, base = undefined) => {\n  const relError = typeof target === 'string' && !isImport && target.length > 0 && !target.startsWith('./');\n\n  if (key === '.') {\n    _assert()(isImport === false);\n\n    return `Invalid \"exports\" main target ${JSON.stringify(target)} defined ` + `in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ? '; targets must start with \"./\"' : ''}`;\n  }\n\n  return `Invalid \"${isImport ? 'imports' : 'exports'}\" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ? '; targets must start with \"./\"' : ''}`;\n}, Error);\ncodes.ERR_MODULE_NOT_FOUND = createError('ERR_MODULE_NOT_FOUND', (path, base, type = 'package') => {\n  return `Cannot find ${type} '${path}' imported from ${base}`;\n}, Error);\ncodes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError('ERR_PACKAGE_IMPORT_NOT_DEFINED', (specifier, packagePath, base) => {\n  return `Package import specifier \"${specifier}\" is not defined${packagePath ? ` in package ${packagePath}package.json` : ''} imported from ${base}`;\n}, TypeError);\ncodes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError('ERR_PACKAGE_PATH_NOT_EXPORTED', (pkgPath, subpath, base = undefined) => {\n  if (subpath === '.') return `No \"exports\" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\n  return `Package subpath '${subpath}' is not defined by \"exports\" in ${pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\n}, Error);\ncodes.ERR_UNSUPPORTED_DIR_IMPORT = createError('ERR_UNSUPPORTED_DIR_IMPORT', \"Directory import '%s' is not supported \" + 'resolving ES modules imported from %s', Error);\ncodes.ERR_UNKNOWN_FILE_EXTENSION = createError('ERR_UNKNOWN_FILE_EXTENSION', 'Unknown file extension \"%s\" for %s', TypeError);\ncodes.ERR_INVALID_ARG_VALUE = createError('ERR_INVALID_ARG_VALUE', (name, value, reason = 'is invalid') => {\n  let inspected = (0, _util().inspect)(value);\n\n  if (inspected.length > 128) {\n    inspected = `${inspected.slice(0, 128)}...`;\n  }\n\n  const type = name.includes('.') ? 'property' : 'argument';\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}, TypeError);\ncodes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError('ERR_UNSUPPORTED_ESM_URL_SCHEME', url => {\n  let message = 'Only file and data URLs are supported by the default ESM loader';\n\n  if (isWindows && url.protocol.length === 2) {\n    message += '. On Windows, absolute paths must be valid file:// URLs';\n  }\n\n  message += `. Received protocol '${url.protocol}'`;\n  return message;\n}, Error);\n\nfunction createError(sym, value, def) {\n  messages.set(sym, value);\n  return makeNodeErrorWithCode(def, sym);\n}\n\nfunction makeNodeErrorWithCode(Base, key) {\n  return NodeError;\n\n  function NodeError(...args) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    const error = new Base();\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const message = getMessage(key, args, error);\n    Object.defineProperty(error, 'message', {\n      value: message,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    Object.defineProperty(error, 'toString', {\n      value() {\n        return `${this.name} [${key}]: ${this.message}`;\n      },\n\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    addCodeToName(error, Base.name, key);\n    error.code = key;\n    return error;\n  }\n}\n\nconst addCodeToName = hideStackFrames(function (error, name, code) {\n  error = captureLargerStackTrace(error);\n  error.name = `${name} [${code}]`;\n  error.stack;\n\n  if (name === 'SystemError') {\n    Object.defineProperty(error, 'name', {\n      value: name,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  } else {\n    delete error.name;\n  }\n});\n\nfunction isErrorStackTraceLimitWritable() {\n  const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');\n\n  if (desc === undefined) {\n    return Object.isExtensible(Error);\n  }\n\n  return own$1.call(desc, 'writable') ? desc.writable : desc.set !== undefined;\n}\n\nfunction hideStackFrames(fn) {\n  const hidden = nodeInternalPrefix + fn.name;\n  Object.defineProperty(fn, 'name', {\n    value: hidden\n  });\n  return fn;\n}\n\nconst captureLargerStackTrace = hideStackFrames(function (error) {\n  const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n\n  if (stackTraceLimitIsWritable) {\n    userStackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = Number.POSITIVE_INFINITY;\n  }\n\n  Error.captureStackTrace(error);\n  if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\n  return error;\n});\n\nfunction getMessage(key, args, self) {\n  const message = messages.get(key);\n\n  if (typeof message === 'function') {\n    _assert()(message.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${message.length}).`);\n\n    return Reflect.apply(message, self, args);\n  }\n\n  const expectedLength = (message.match(/%[dfijoOs]/g) || []).length;\n\n  _assert()(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);\n\n  if (args.length === 0) return message;\n  args.unshift(message);\n  return Reflect.apply(_util().format, null, args);\n}\n\nconst {\n  ERR_UNKNOWN_FILE_EXTENSION\n} = codes;\nconst extensionFormatMap = {\n  __proto__: null,\n  '.cjs': 'commonjs',\n  '.js': 'module',\n  '.mjs': 'module'\n};\n\nfunction defaultGetFormat(url) {\n  if (url.startsWith('node:')) {\n    return {\n      format: 'builtin'\n    };\n  }\n\n  const parsed = new (_url().URL)(url);\n\n  if (parsed.protocol === 'data:') {\n    const {\n      1: mime\n    } = /^([^/]+\\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null];\n    const format = mime === 'text/javascript' ? 'module' : null;\n    return {\n      format\n    };\n  }\n\n  if (parsed.protocol === 'file:') {\n    const ext = _path().extname(parsed.pathname);\n\n    let format;\n\n    if (ext === '.js') {\n      format = getPackageType(parsed.href) === 'module' ? 'module' : 'commonjs';\n    } else {\n      format = extensionFormatMap[ext];\n    }\n\n    if (!format) {\n      throw new ERR_UNKNOWN_FILE_EXTENSION(ext, (0, _url().fileURLToPath)(url));\n    }\n\n    return {\n      format: format || null\n    };\n  }\n\n  return {\n    format: null\n  };\n}\n\nconst listOfBuiltins = builtins();\nconst {\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME,\n  ERR_INVALID_ARG_VALUE\n} = codes;\nconst own = {}.hasOwnProperty;\nconst DEFAULT_CONDITIONS = Object.freeze(['node', 'import']);\nconst DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\nconst encodedSepRegEx = /%2f|%2c/i;\nconst emittedPackageWarnings = new Set();\nconst packageJsonCache = new Map();\n\nfunction emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {\n  const pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(`Use of deprecated folder mapping \"${match}\" in the ${isExports ? '\"exports\"' : '\"imports\"'} field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ''}.\\n` + `Update this package.json to use a subpath pattern like \"${match}*\".`, 'DeprecationWarning', 'DEP0148');\n}\n\nfunction emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {\n  const {\n    format\n  } = defaultGetFormat(url.href);\n  if (format !== 'module') return;\n  const path = (0, _url().fileURLToPath)(url.href);\n  const pkgPath = (0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl));\n  const basePath = (0, _url().fileURLToPath)(base);\n  if (main) process.emitWarning(`Package ${pkgPath} has a \"main\" field set to ${JSON.stringify(main)}, ` + `excluding the full filename and extension to the resolved file at \"${path.slice(pkgPath.length)}\", imported from ${basePath}.\\n Automatic extension resolution of the \"main\" field is` + 'deprecated for ES modules.', 'DeprecationWarning', 'DEP0151');else process.emitWarning(`No \"main\" or \"exports\" field defined in the package.json for ${pkgPath} resolving the main entry point \"${path.slice(pkgPath.length)}\", imported from ${basePath}.\\nDefault \"index\" lookups for the main are deprecated for ES modules.`, 'DeprecationWarning', 'DEP0151');\n}\n\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!Array.isArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions', conditions, 'expected an array');\n    }\n\n    return new Set(conditions);\n  }\n\n  return DEFAULT_CONDITIONS_SET;\n}\n\nfunction tryStatSync(path) {\n  try {\n    return (0, _fs().statSync)(path);\n  } catch (_unused) {\n    return new (_fs().Stats)();\n  }\n}\n\nfunction getPackageConfig(path, specifier, base) {\n  const existing = packageJsonCache.get(path);\n\n  if (existing !== undefined) {\n    return existing;\n  }\n\n  const source = reader.read(path).string;\n\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path,\n      exists: false,\n      main: undefined,\n      name: undefined,\n      type: 'none',\n      exports: undefined,\n      imports: undefined\n    };\n    packageJsonCache.set(path, packageConfig);\n    return packageConfig;\n  }\n\n  let packageJson;\n\n  try {\n    packageJson = JSON.parse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(path, (base ? `\"${specifier}\" from ` : '') + (0, _url().fileURLToPath)(base || specifier), error.message);\n  }\n\n  const {\n    exports,\n    imports,\n    main,\n    name,\n    type\n  } = packageJson;\n  const packageConfig = {\n    pjsonPath: path,\n    exists: true,\n    main: typeof main === 'string' ? main : undefined,\n    name: typeof name === 'string' ? name : undefined,\n    type: type === 'module' || type === 'commonjs' ? type : 'none',\n    exports,\n    imports: imports && typeof imports === 'object' ? imports : undefined\n  };\n  packageJsonCache.set(path, packageConfig);\n  return packageConfig;\n}\n\nfunction getPackageScopeConfig(resolved) {\n  let packageJsonUrl = new (_url().URL)('./package.json', resolved);\n\n  while (true) {\n    const packageJsonPath = packageJsonUrl.pathname;\n    if (packageJsonPath.endsWith('node_modules/package.json')) break;\n    const packageConfig = getPackageConfig((0, _url().fileURLToPath)(packageJsonUrl), resolved);\n    if (packageConfig.exists) return packageConfig;\n    const lastPackageJsonUrl = packageJsonUrl;\n    packageJsonUrl = new (_url().URL)('../package.json', packageJsonUrl);\n    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname) break;\n  }\n\n  const packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);\n  const packageConfig = {\n    pjsonPath: packageJsonPath,\n    exists: false,\n    main: undefined,\n    name: undefined,\n    type: 'none',\n    exports: undefined,\n    imports: undefined\n  };\n  packageJsonCache.set(packageJsonPath, packageConfig);\n  return packageConfig;\n}\n\nfunction fileExists(url) {\n  return tryStatSync((0, _url().fileURLToPath)(url)).isFile();\n}\n\nfunction legacyMainResolve(packageJsonUrl, packageConfig, base) {\n  let guess;\n\n  if (packageConfig.main !== undefined) {\n    guess = new (_url().URL)(`./${packageConfig.main}`, packageJsonUrl);\n    if (fileExists(guess)) return guess;\n    const tries = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];\n    let i = -1;\n\n    while (++i < tries.length) {\n      guess = new (_url().URL)(tries[i], packageJsonUrl);\n      if (fileExists(guess)) break;\n      guess = undefined;\n    }\n\n    if (guess) {\n      emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);\n      return guess;\n    }\n  }\n\n  const tries = ['./index.js', './index.json', './index.node'];\n  let i = -1;\n\n  while (++i < tries.length) {\n    guess = new (_url().URL)(tries[i], packageJsonUrl);\n    if (fileExists(guess)) break;\n    guess = undefined;\n  }\n\n  if (guess) {\n    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);\n    return guess;\n  }\n\n  throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), (0, _url().fileURLToPath)(base));\n}\n\nfunction finalizeResolution(resolved, base) {\n  if (encodedSepRegEx.test(resolved.pathname)) throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded \"/\" or \"\\\\\" characters', (0, _url().fileURLToPath)(base));\n  const path = (0, _url().fileURLToPath)(resolved);\n  const stats = tryStatSync(path.endsWith('/') ? path.slice(-1) : path);\n\n  if (stats.isDirectory()) {\n    const error = new ERR_UNSUPPORTED_DIR_IMPORT(path, (0, _url().fileURLToPath)(base));\n    error.url = String(resolved);\n    throw error;\n  }\n\n  if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(path || resolved.pathname, base && (0, _url().fileURLToPath)(base), 'module');\n  }\n\n  return resolved;\n}\n\nfunction throwImportNotDefined(specifier, packageJsonUrl, base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && (0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), (0, _url().fileURLToPath)(base));\n}\n\nfunction throwExportsNotFound(subpath, packageJsonUrl, base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), subpath, base && (0, _url().fileURLToPath)(base));\n}\n\nfunction throwInvalidSubpath(subpath, packageJsonUrl, internal, base) {\n  const reason = `request is not a valid subpath for the \"${internal ? 'imports' : 'exports'}\" resolution of ${(0, _url().fileURLToPath)(packageJsonUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason, base && (0, _url().fileURLToPath)(base));\n}\n\nfunction throwInvalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {\n  target = typeof target === 'object' && target !== null ? JSON.stringify(target, null, '') : `${target}`;\n  throw new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url().URL)('.', packageJsonUrl)), subpath, target, internal, base && (0, _url().fileURLToPath)(base));\n}\n\nfunction resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/') throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);\n\n  if (!target.startsWith('./')) {\n    if (internal && !target.startsWith('../') && !target.startsWith('/')) {\n      let isURL = false;\n\n      try {\n        new (_url().URL)(target);\n        isURL = true;\n      } catch (_unused2) {}\n\n      if (!isURL) {\n        const exportTarget = pattern ? target.replace(patternRegEx, subpath) : target + subpath;\n        return packageResolve(exportTarget, packageJsonUrl, conditions);\n      }\n    }\n\n    throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);\n  }\n\n  if (invalidSegmentRegEx.test(target.slice(2))) throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);\n  const resolved = new (_url().URL)(target, packageJsonUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new (_url().URL)('.', packageJsonUrl).pathname;\n  if (!resolvedPath.startsWith(packagePath)) throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);\n  if (subpath === '') return resolved;\n  if (invalidSegmentRegEx.test(subpath)) throwInvalidSubpath(match + subpath, packageJsonUrl, internal, base);\n  if (pattern) return new (_url().URL)(resolved.href.replace(patternRegEx, subpath));\n  return new (_url().URL)(subpath, resolved);\n}\n\nfunction isArrayIndex(key) {\n  const keyNumber = Number(key);\n  if (`${keyNumber}` !== key) return false;\n  return keyNumber >= 0 && keyNumber < 0xffffffff;\n}\n\nfunction resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, conditions);\n  }\n\n  if (Array.isArray(target)) {\n    const targetList = target;\n    if (targetList.length === 0) return null;\n    let lastException;\n    let i = -1;\n\n    while (++i < targetList.length) {\n      const targetItem = targetList[i];\n      let resolved;\n\n      try {\n        resolved = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);\n      } catch (error) {\n        lastException = error;\n        if (error.code === 'ERR_INVALID_PACKAGE_TARGET') continue;\n        throw error;\n      }\n\n      if (resolved === undefined) continue;\n\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n\n      return resolved;\n    }\n\n    if (lastException === undefined || lastException === null) {\n      return lastException;\n    }\n\n    throw lastException;\n  }\n\n  if (typeof target === 'object' && target !== null) {\n    const keys = Object.getOwnPropertyNames(target);\n    let i = -1;\n\n    while (++i < keys.length) {\n      const key = keys[i];\n\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '\"exports\" cannot contain numeric property keys.');\n      }\n    }\n\n    i = -1;\n\n    while (++i < keys.length) {\n      const key = keys[i];\n\n      if (key === 'default' || conditions && conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, conditions);\n        if (resolved === undefined) continue;\n        return resolved;\n      }\n    }\n\n    return undefined;\n  }\n\n  if (target === null) {\n    return null;\n  }\n\n  throwInvalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);\n}\n\nfunction isConditionalExportsMainSugar(exports, packageJsonUrl, base) {\n  if (typeof exports === 'string' || Array.isArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n  const keys = Object.getOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  let j = -1;\n\n  while (++j < keys.length) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' + ' The exports object must either be an object of package subpath keys' + ' or an object of main entry condition name keys only.');\n    }\n  }\n\n  return isConditionalSugar;\n}\n\nfunction packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) exports = {\n    '.': exports\n  };\n\n  if (own.call(exports, packageSubpath)) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(packageJsonUrl, target, '', packageSubpath, base, false, false, conditions);\n    if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJsonUrl, base);\n    return {\n      resolved,\n      exact: true\n    };\n  }\n\n  let bestMatch = '';\n  const keys = Object.getOwnPropertyNames(exports);\n  let i = -1;\n\n  while (++i < keys.length) {\n    const key = keys[i];\n\n    if (key[key.length - 1] === '*' && packageSubpath.startsWith(key.slice(0, -1)) && packageSubpath.length >= key.length && key.length > bestMatch.length) {\n      bestMatch = key;\n    } else if (key[key.length - 1] === '/' && packageSubpath.startsWith(key) && key.length > bestMatch.length) {\n      bestMatch = key;\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const pattern = bestMatch[bestMatch.length - 1] === '*';\n    const subpath = packageSubpath.slice(bestMatch.length - (pattern ? 1 : 0));\n    const resolved = resolvePackageTarget(packageJsonUrl, target, subpath, bestMatch, base, pattern, false, conditions);\n    if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJsonUrl, base);\n    if (!pattern) emitFolderMapDeprecation(bestMatch, packageJsonUrl, true, base);\n    return {\n      resolved,\n      exact: pattern\n    };\n  }\n\n  throwExportsNotFound(packageSubpath, packageJsonUrl, base);\n}\n\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === '#' || name.startsWith('#/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, _url().fileURLToPath)(base));\n  }\n\n  let packageJsonUrl;\n  const packageConfig = getPackageScopeConfig(base);\n\n  if (packageConfig.exists) {\n    packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n\n    if (imports) {\n      if (own.call(imports, name)) {\n        const resolved = resolvePackageTarget(packageJsonUrl, imports[name], '', name, base, false, true, conditions);\n        if (resolved !== null) return {\n          resolved,\n          exact: true\n        };\n      } else {\n        let bestMatch = '';\n        const keys = Object.getOwnPropertyNames(imports);\n        let i = -1;\n\n        while (++i < keys.length) {\n          const key = keys[i];\n\n          if (key[key.length - 1] === '*' && name.startsWith(key.slice(0, -1)) && name.length >= key.length && key.length > bestMatch.length) {\n            bestMatch = key;\n          } else if (key[key.length - 1] === '/' && name.startsWith(key) && key.length > bestMatch.length) {\n            bestMatch = key;\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const pattern = bestMatch[bestMatch.length - 1] === '*';\n          const subpath = name.slice(bestMatch.length - (pattern ? 1 : 0));\n          const resolved = resolvePackageTarget(packageJsonUrl, target, subpath, bestMatch, base, pattern, true, conditions);\n\n          if (resolved !== null) {\n            if (!pattern) emitFolderMapDeprecation(bestMatch, packageJsonUrl, false, base);\n            return {\n              resolved,\n              exact: pattern\n            };\n          }\n        }\n      }\n    }\n  }\n\n  throwImportNotDefined(name, packageJsonUrl, base);\n}\n\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\nfunction parsePackageName(specifier, base) {\n  let separatorIndex = specifier.indexOf('/');\n  let validPackageName = true;\n  let isScoped = false;\n\n  if (specifier[0] === '@') {\n    isScoped = true;\n\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = specifier.indexOf('/', separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);\n  let i = -1;\n\n  while (++i < packageName.length) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(specifier, 'is not a valid package name', (0, _url().fileURLToPath)(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' : specifier.slice(separatorIndex));\n  return {\n    packageName,\n    packageSubpath,\n    isScoped\n  };\n}\n\nfunction packageResolve(specifier, base, conditions) {\n  const {\n    packageName,\n    packageSubpath,\n    isScoped\n  } = parsePackageName(specifier, base);\n  const packageConfig = getPackageScopeConfig(base);\n\n  if (packageConfig.exists) {\n    const packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);\n\n    if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions).resolved;\n    }\n  }\n\n  let packageJsonUrl = new (_url().URL)('./node_modules/' + packageName + '/package.json', base);\n  let packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);\n  let lastPath;\n\n  do {\n    const stat = tryStatSync(packageJsonPath.slice(0, -13));\n\n    if (!stat.isDirectory()) {\n      lastPath = packageJsonPath;\n      packageJsonUrl = new (_url().URL)((isScoped ? '../../../../node_modules/' : '../../../node_modules/') + packageName + '/package.json', packageJsonUrl);\n      packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);\n      continue;\n    }\n\n    const packageConfig = getPackageConfig(packageJsonPath, specifier, base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null) return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions).resolved;\n    if (packageSubpath === '.') return legacyMainResolve(packageJsonUrl, packageConfig, base);\n    return new (_url().URL)(packageSubpath, packageJsonUrl);\n  } while (packageJsonPath.length !== lastPath.length);\n\n  throw new ERR_MODULE_NOT_FOUND(packageName, (0, _url().fileURLToPath)(base));\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n\n    if (specifier[1] === '.' && (specifier.length === 2 || specifier[2] === '/')) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\nfunction moduleResolve(specifier, base, conditions) {\n  let resolved;\n\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new (_url().URL)(specifier, base);\n  } else if (specifier[0] === '#') {\n    ({\n      resolved\n    } = packageImportsResolve(specifier, base, conditions));\n  } else {\n    try {\n      resolved = new (_url().URL)(specifier);\n    } catch (_unused3) {\n      resolved = packageResolve(specifier, base, conditions);\n    }\n  }\n\n  return finalizeResolution(resolved, base);\n}\n\nfunction defaultResolve(specifier, context = {}) {\n  const {\n    parentURL\n  } = context;\n  let parsed;\n\n  try {\n    parsed = new (_url().URL)(specifier);\n\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch (_unused4) {}\n\n  if (parsed && parsed.protocol === 'node:') return {\n    url: specifier\n  };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:') throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n\n  if (listOfBuiltins.includes(specifier)) {\n    return {\n      url: 'node:' + specifier\n    };\n  }\n\n  if (parentURL.startsWith('data:')) {\n    new (_url().URL)(specifier, parentURL);\n  }\n\n  const conditions = getConditionsSet(context.conditions);\n  let url = moduleResolve(specifier, new (_url().URL)(parentURL), conditions);\n  const urlPath = (0, _url().fileURLToPath)(url);\n  const real = (0, _fs().realpathSync)(urlPath);\n  const old = url;\n  url = (0, _url().pathToFileURL)(real + (urlPath.endsWith(_path().sep) ? '/' : ''));\n  url.search = old.search;\n  url.hash = old.hash;\n  return {\n    url: `${url}`\n  };\n}\n\nfunction resolve(_x, _x2) {\n  return _resolve.apply(this, arguments);\n}\n\nfunction _resolve() {\n  _resolve = _asyncToGenerator(function* (specifier, parent) {\n    if (!parent) {\n      throw new Error('Please pass `parent`: `import-meta-resolve` cannot ponyfill that');\n    }\n\n    try {\n      return defaultResolve(specifier, {\n        parentURL: parent\n      }).url;\n    } catch (error) {\n      return error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ? error.url : Promise.reject(error);\n    }\n  });\n  return _resolve.apply(this, arguments);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEnv = getEnv;\n\nfunction getEnv(defaultValue = \"development\") {\n  return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConfigItem = createConfigItem;\nexports.createConfigItemSync = exports.createConfigItemAsync = void 0;\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return _full.default;\n  }\n});\nexports.loadPartialConfigSync = exports.loadPartialConfigAsync = exports.loadPartialConfig = exports.loadOptionsSync = exports.loadOptionsAsync = exports.loadOptions = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _full = require(\"./full\");\n\nvar _partial = require(\"./partial\");\n\nvar _item = require(\"./item\");\n\nconst loadOptionsRunner = _gensync()(function* (opts) {\n  var _config$options;\n\n  const config = yield* (0, _full.default)(opts);\n  return (_config$options = config == null ? void 0 : config.options) != null ? _config$options : null;\n});\n\nconst createConfigItemRunner = _gensync()(_item.createConfigItem);\n\nconst maybeErrback = runner => (opts, callback) => {\n  if (callback === undefined && typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n\n  return callback ? runner.errback(opts, callback) : runner.sync(opts);\n};\n\nconst loadPartialConfig = maybeErrback(_partial.loadPartialConfig);\nexports.loadPartialConfig = loadPartialConfig;\nconst loadPartialConfigSync = _partial.loadPartialConfig.sync;\nexports.loadPartialConfigSync = loadPartialConfigSync;\nconst loadPartialConfigAsync = _partial.loadPartialConfig.async;\nexports.loadPartialConfigAsync = loadPartialConfigAsync;\nconst loadOptions = maybeErrback(loadOptionsRunner);\nexports.loadOptions = loadOptions;\nconst loadOptionsSync = loadOptionsRunner.sync;\nexports.loadOptionsSync = loadOptionsSync;\nconst loadOptionsAsync = loadOptionsRunner.async;\nexports.loadOptionsAsync = loadOptionsAsync;\nconst createConfigItemSync = createConfigItemRunner.sync;\nexports.createConfigItemSync = createConfigItemSync;\nconst createConfigItemAsync = createConfigItemRunner.async;\nexports.createConfigItemAsync = createConfigItemAsync;\n\nfunction createConfigItem(target, options, callback) {\n  if (callback !== undefined) {\n    return createConfigItemRunner.errback(target, options, callback);\n  } else if (typeof options === \"function\") {\n    return createConfigItemRunner.errback(target, undefined, callback);\n  } else {\n    return createConfigItemRunner.sync(target, options);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nvar context = require(\"../index\");\n\nvar _plugin = require(\"./plugin\");\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nvar _deepArray = require(\"./helpers/deep-array\");\n\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"./caching\");\n\nvar _options = require(\"./validation/options\");\n\nvar _plugins = require(\"./validation/plugins\");\n\nvar _configApi = require(\"./helpers/config-api\");\n\nvar _partial = require(\"./partial\");\n\nvar Context = require(\"./cache-contexts\");\n\nvar _default = _gensync()(function* loadFullConfig(inputOpts) {\n  var _opts$assumptions;\n\n  const result = yield* (0, _partial.default)(inputOpts);\n\n  if (!result) {\n    return null;\n  }\n\n  const {\n    options,\n    context,\n    fileHandling\n  } = result;\n\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n\n  const optionDefaults = {};\n  const {\n    plugins,\n    presets\n  } = options;\n\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n\n  const presetContext = Object.assign({}, context, {\n    targets: options.targets\n  });\n\n  const toDescriptor = item => {\n    const desc = (0, _item.getItemDescriptor)(item);\n\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n\n    return desc;\n  };\n\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass = [[]];\n  const passes = [];\n  const externalDependencies = [];\n  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n    const presets = [];\n\n    for (let i = 0; i < rawPresets.length; i++) {\n      const descriptor = rawPresets[i];\n\n      if (descriptor.options !== false) {\n        try {\n          var preset = yield* loadPresetDescriptor(descriptor, presetContext);\n        } catch (e) {\n          if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", e);\n          }\n\n          throw e;\n        }\n\n        externalDependencies.push(preset.externalDependencies);\n\n        if (descriptor.ownPass) {\n          presets.push({\n            preset: preset.chain,\n            pass: []\n          });\n        } else {\n          presets.unshift({\n            preset: preset.chain,\n            pass: pluginDescriptorsPass\n          });\n        }\n      }\n    }\n\n    if (presets.length > 0) {\n      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));\n\n      for (const {\n        preset,\n        pass\n      } of presets) {\n        if (!preset) return true;\n        pass.push(...preset.plugins);\n        const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n        if (ignored) return true;\n        preset.options.forEach(opts => {\n          (0, _util.mergeOptions)(optionDefaults, opts);\n        });\n      }\n    }\n  })(presetsDescriptors, pluginDescriptorsByPass[0]);\n  if (ignored) return null;\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  const pluginContext = Object.assign({}, presetContext, {\n    assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}\n  });\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n\n    for (const descs of pluginDescriptorsByPass) {\n      const pass = [];\n      passes.push(pass);\n\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor = descs[i];\n\n        if (descriptor.options !== false) {\n          try {\n            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", e);\n            }\n\n            throw e;\n          }\n\n          pass.push(plugin);\n          externalDependencies.push(plugin.externalDependencies);\n        }\n      }\n    }\n  })();\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\n\nexports.default = _default;\n\nfunction enhanceError(context, fn) {\n  return function* (arg1, arg2) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        e.message = `[BABEL] ${context.filename || \"unknown\"}: ${e.message}`;\n      }\n\n      throw e;\n    }\n  };\n}\n\nconst makeDescriptorLoader = apiFactory => (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) {\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  const externalDependencies = [];\n  let item = value;\n\n  if (typeof value === \"function\") {\n    const factory = (0, _async.maybeAsync)(value, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);\n    const api = Object.assign({}, context, apiFactory(cache, externalDependencies));\n\n    try {\n      item = yield* factory(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += ` (While processing: ${JSON.stringify(alias)})`;\n      }\n\n      throw e;\n    }\n  }\n\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n\n  if ((0, _async.isThenable)(item)) {\n    yield* [];\n    throw new Error(`You appear to be using a promise as a plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version. ` + `As an alternative, you can prefix the promise with \"await\". ` + `(While processing: ${JSON.stringify(alias)})`);\n  }\n\n  if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === \"forever\")) {\n    let error = `A plugin/preset has external untracked dependencies ` + `(${externalDependencies[0]}), but the cache `;\n\n    if (!cache.configured()) {\n      error += `has not been configured to be invalidated when the external dependencies change. `;\n    } else {\n      error += ` has been configured to never be invalidated. `;\n    }\n\n    error += `Plugins/presets should configure their cache to be invalidated when the external ` + `dependencies change, for example using \\`api.cache.invalidate(() => ` + `statSync(filepath).mtimeMs)\\` or \\`api.cache.never()\\`\\n` + `(While processing: ${JSON.stringify(alias)})`;\n    throw new Error(error);\n  }\n\n  return {\n    value: item,\n    options,\n    dirname,\n    alias,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\n\nconst pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);\nconst presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);\n\nfunction* loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n\n    return descriptor.value;\n  }\n\n  return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context), context);\n}\n\nconst instantiatePlugin = (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias,\n  externalDependencies\n}, cache) {\n  const pluginObj = (0, _plugins.validatePluginObject)(value);\n  const plugin = Object.assign({}, pluginObj);\n\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname\n    };\n    const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n\n    if (inherits.externalDependencies.length > 0) {\n      if (externalDependencies.length === 0) {\n        externalDependencies = inherits.externalDependencies;\n      } else {\n        externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);\n      }\n    }\n  }\n\n  return new _plugin.default(plugin, options, alias, externalDependencies);\n});\n\nconst validateIfOptionNeedsFilename = (options, descriptor) => {\n  if (options.test || options.include || options.exclude) {\n    const formattedPresetName = descriptor.name ? `\"${descriptor.name}\"` : \"/* your preset */\";\n    throw new Error([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\\`\\`\\``, `babel.transform(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\\`\\`\\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join(\"\\n\"));\n  }\n};\n\nconst validatePreset = (preset, context, descriptor) => {\n  if (!context.filename) {\n    const {\n      options\n    } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));\n    }\n  }\n};\n\nfunction* loadPresetDescriptor(descriptor, context) {\n  const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context));\n  validatePreset(preset, context, descriptor);\n  return {\n    chain: yield* (0, _configChain.buildPresetChain)(preset, context),\n    externalDependencies: preset.externalDependencies\n  };\n}\n\nconst instantiatePreset = (0, _caching.makeWeakCacheSync)(({\n  value,\n  dirname,\n  alias,\n  externalDependencies\n}) => {\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname,\n    externalDependencies\n  };\n});\n\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function (...args) {\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _deepArray = require(\"./helpers/deep-array\");\n\nclass Plugin {\n  constructor(plugin, options, key, externalDependencies = (0, _deepArray.finalize)([])) {\n    this.key = void 0;\n    this.manipulateOptions = void 0;\n    this.post = void 0;\n    this.pre = void 0;\n    this.visitor = void 0;\n    this.parserOverride = void 0;\n    this.generatorOverride = void 0;\n    this.options = void 0;\n    this.externalDependencies = void 0;\n    this.key = plugin.name || key;\n    this.manipulateOptions = plugin.manipulateOptions;\n    this.post = plugin.post;\n    this.pre = plugin.pre;\n    this.visitor = plugin.visitor || {};\n    this.parserOverride = plugin.parserOverride;\n    this.generatorOverride = plugin.generatorOverride;\n    this.options = options;\n    this.externalDependencies = externalDependencies;\n  }\n\n}\n\nexports.default = Plugin;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.finalize = finalize;\nexports.flattenToSet = flattenToSet;\n\nfunction finalize(deepArr) {\n  return Object.freeze(deepArr);\n}\n\nfunction flattenToSet(arr) {\n  const result = new Set();\n  const stack = [arr];\n\n  while (stack.length > 0) {\n    for (const el of stack.pop()) {\n      if (Array.isArray(el)) stack.push(el);else result.add(el);\n    }\n  }\n\n  return result;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConfigItem = createConfigItem;\nexports.createItemFromDescriptor = createItemFromDescriptor;\nexports.getItemDescriptor = getItemDescriptor;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nfunction createItemFromDescriptor(desc) {\n  return new ConfigItem(desc);\n}\n\nfunction* createConfigItem(value, {\n  dirname = \".\",\n  type\n} = {}) {\n  const descriptor = yield* (0, _configDescriptors.createDescriptor)(value, _path().resolve(dirname), {\n    type,\n    alias: \"programmatic item\"\n  });\n  return createItemFromDescriptor(descriptor);\n}\n\nfunction getItemDescriptor(item) {\n  if (item != null && item[CONFIG_ITEM_BRAND]) {\n    return item._descriptor;\n  }\n\n  return undefined;\n}\n\nconst CONFIG_ITEM_BRAND = Symbol.for(\"@babel/core@7 - ConfigItem\");\n\nclass ConfigItem {\n  constructor(descriptor) {\n    this._descriptor = void 0;\n    this[CONFIG_ITEM_BRAND] = true;\n    this.value = void 0;\n    this.options = void 0;\n    this.dirname = void 0;\n    this.name = void 0;\n    this.file = void 0;\n    this._descriptor = descriptor;\n    Object.defineProperty(this, \"_descriptor\", {\n      enumerable: false\n    });\n    Object.defineProperty(this, CONFIG_ITEM_BRAND, {\n      enumerable: false\n    });\n    this.value = this._descriptor.value;\n    this.options = this._descriptor.options;\n    this.dirname = this._descriptor.dirname;\n    this.name = this._descriptor.name;\n    this.file = this._descriptor.file ? {\n      request: this._descriptor.file.request,\n      resolved: this._descriptor.file.resolved\n    } : undefined;\n    Object.freeze(this);\n  }\n\n}\n\nObject.freeze(ConfigItem.prototype);","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCachedDescriptors = createCachedDescriptors;\nexports.createDescriptor = createDescriptor;\nexports.createUncachedDescriptors = createUncachedDescriptors;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _files = require(\"./files\");\n\nvar _item = require(\"./item\");\n\nvar _caching = require(\"./caching\");\n\nvar _resolveTargets = require(\"./resolve-targets\");\n\nfunction isEqualDescriptor(a, b) {\n  return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);\n}\n\nfunction* handlerOf(value) {\n  return value;\n}\n\nfunction optionsWithResolvedBrowserslistConfigFile(options, dirname) {\n  if (typeof options.browserslistConfigFile === \"string\") {\n    options.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile, dirname);\n  }\n\n  return options;\n}\n\nfunction createCachedDescriptors(dirname, options, alias) {\n  const {\n    plugins,\n    presets,\n    passPerPreset\n  } = options;\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname)(alias) : () => handlerOf([]),\n    presets: presets ? () => createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset) : () => handlerOf([])\n  };\n}\n\nfunction createUncachedDescriptors(dirname, options, alias) {\n  let plugins;\n  let presets;\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n\n    *plugins() {\n      if (!plugins) {\n        plugins = yield* createPluginDescriptors(options.plugins || [], dirname, alias);\n      }\n\n      return plugins;\n    },\n\n    *presets() {\n      if (!presets) {\n        presets = yield* createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset);\n      }\n\n      return presets;\n    }\n\n  };\n}\n\nconst PRESET_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {\n  const dirname = cache.using(dir => dir);\n  return (0, _caching.makeStrongCacheSync)(alias => (0, _caching.makeStrongCache)(function* (passPerPreset) {\n    const descriptors = yield* createPresetDescriptors(items, dirname, alias, passPerPreset);\n    return descriptors.map(desc => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc));\n  }));\n});\nconst PLUGIN_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {\n  const dirname = cache.using(dir => dir);\n  return (0, _caching.makeStrongCache)(function* (alias) {\n    const descriptors = yield* createPluginDescriptors(items, dirname, alias);\n    return descriptors.map(desc => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc));\n  });\n});\nconst DEFAULT_OPTIONS = {};\n\nfunction loadCachedDescriptor(cache, desc) {\n  const {\n    value,\n    options = DEFAULT_OPTIONS\n  } = desc;\n  if (options === false) return desc;\n  let cacheByOptions = cache.get(value);\n\n  if (!cacheByOptions) {\n    cacheByOptions = new WeakMap();\n    cache.set(value, cacheByOptions);\n  }\n\n  let possibilities = cacheByOptions.get(options);\n\n  if (!possibilities) {\n    possibilities = [];\n    cacheByOptions.set(options, possibilities);\n  }\n\n  if (possibilities.indexOf(desc) === -1) {\n    const matches = possibilities.filter(possibility => isEqualDescriptor(possibility, desc));\n\n    if (matches.length > 0) {\n      return matches[0];\n    }\n\n    possibilities.push(desc);\n  }\n\n  return desc;\n}\n\nfunction* createPresetDescriptors(items, dirname, alias, passPerPreset) {\n  return yield* createDescriptors(\"preset\", items, dirname, alias, passPerPreset);\n}\n\nfunction* createPluginDescriptors(items, dirname, alias) {\n  return yield* createDescriptors(\"plugin\", items, dirname, alias);\n}\n\nfunction* createDescriptors(type, items, dirname, alias, ownPass) {\n  const descriptors = yield* _gensync().all(items.map((item, index) => createDescriptor(item, dirname, {\n    type,\n    alias: `${alias}$${index}`,\n    ownPass: !!ownPass\n  })));\n  assertNoDuplicates(descriptors);\n  return descriptors;\n}\n\nfunction* createDescriptor(pair, dirname, {\n  type,\n  alias,\n  ownPass\n}) {\n  const desc = (0, _item.getItemDescriptor)(pair);\n\n  if (desc) {\n    return desc;\n  }\n\n  let name;\n  let options;\n  let value = pair;\n\n  if (Array.isArray(value)) {\n    if (value.length === 3) {\n      [value, options, name] = value;\n    } else {\n      [value, options] = value;\n    }\n  }\n\n  let file = undefined;\n  let filepath = null;\n\n  if (typeof value === \"string\") {\n    if (typeof type !== \"string\") {\n      throw new Error(\"To resolve a string-based item, the type of item must be given\");\n    }\n\n    const resolver = type === \"plugin\" ? _files.loadPlugin : _files.loadPreset;\n    const request = value;\n    ({\n      filepath,\n      value\n    } = yield* resolver(value, dirname));\n    file = {\n      request,\n      resolved: filepath\n    };\n  }\n\n  if (!value) {\n    throw new Error(`Unexpected falsy value: ${String(value)}`);\n  }\n\n  if (typeof value === \"object\" && value.__esModule) {\n    if (value.default) {\n      value = value.default;\n    } else {\n      throw new Error(\"Must export a default export when using ES6 modules.\");\n    }\n  }\n\n  if (typeof value !== \"object\" && typeof value !== \"function\") {\n    throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);\n  }\n\n  if (filepath !== null && typeof value === \"object\" && value) {\n    throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);\n  }\n\n  return {\n    name,\n    alias: filepath || alias,\n    value,\n    options,\n    dirname,\n    ownPass,\n    file\n  };\n}\n\nfunction assertNoDuplicates(items) {\n  const map = new Map();\n\n  for (const item of items) {\n    if (typeof item.value !== \"function\") continue;\n    let nameMap = map.get(item.value);\n\n    if (!nameMap) {\n      nameMap = new Set();\n      map.set(item.value, nameMap);\n    }\n\n    if (nameMap.has(item.name)) {\n      const conflicts = items.filter(i => i.value === item.value);\n      throw new Error([`Duplicate plugin/preset detected.`, `If you'd like to use two separate instances of a plugin,`, `they need separate names, e.g.`, ``, `  plugins: [`, `    ['some-plugin', {}],`, `    ['some-plugin', {}, 'some unique name'],`, `  ]`, ``, `Duplicates detected are:`, `${JSON.stringify(conflicts, null, 2)}`].join(\"\\n\"));\n    }\n\n    nameMap.add(item.name);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveBrowserslistConfigFile = resolveBrowserslistConfigFile;\nexports.resolveTargets = resolveTargets;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _helperCompilationTargets() {\n  const data = require(\"@babel/helper-compilation-targets\");\n\n  _helperCompilationTargets = function () {\n    return data;\n  };\n\n  return data;\n}\n\n({});\n\nfunction resolveBrowserslistConfigFile(browserslistConfigFile, configFileDir) {\n  return _path().resolve(configFileDir, browserslistConfigFile);\n}\n\nfunction resolveTargets(options, root) {\n  let targets = options.targets;\n\n  if (typeof targets === \"string\" || Array.isArray(targets)) {\n    targets = {\n      browsers: targets\n    };\n  }\n\n  if (targets && targets.esmodules) {\n    targets = Object.assign({}, targets, {\n      esmodules: \"intersect\"\n    });\n  }\n\n  const {\n    browserslistConfigFile\n  } = options;\n  let configFile;\n  let ignoreBrowserslistConfig = false;\n\n  if (typeof browserslistConfigFile === \"string\") {\n    configFile = browserslistConfigFile;\n  } else {\n    ignoreBrowserslistConfig = browserslistConfigFile === false;\n  }\n\n  return (0, _helperCompilationTargets().default)(targets, {\n    ignoreBrowserslistConfig,\n    configFile,\n    configPath: root,\n    browserslistEnv: options.browserslistEnv\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildPresetChainWalker = void 0;\nexports.buildRootChain = buildRootChain;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./validation/options\");\n\nvar _patternToRegex = require(\"./pattern-to-regex\");\n\nvar _printer = require(\"./printer\");\n\nvar _files = require(\"./files\");\n\nvar _caching = require(\"./caching\");\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nconst debug = _debug()(\"babel:config:config-chain\");\n\nfunction* buildPresetChain(arg, context) {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    files: new Set()\n  };\n}\n\nconst buildPresetChainWalker = makeChainWalker({\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),\n  createLogger: () => () => {}\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCacheSync)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction* buildRootChain(opts, context) {\n  let configReport, babelRcReport;\n  const programmaticLogger = new _printer.ConfigPrinter();\n  const programmaticChain = yield* loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context, undefined, programmaticLogger);\n  if (!programmaticChain) return null;\n  const programmaticReport = yield* programmaticLogger.output();\n  let configFile;\n\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n  const configFileLogger = new _printer.ConfigPrinter();\n\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(validatedFile, context, undefined, configFileLogger);\n    if (!result) return null;\n    configReport = yield* configFileLogger.output();\n\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  let ignoreFile, babelrcFile;\n  let isIgnored = false;\n  const fileChain = emptyChain();\n\n  if ((babelrc === true || babelrc === undefined) && typeof context.filename === \"string\") {\n    const pkgData = yield* (0, _files.findPackageData)(context.filename);\n\n    if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n      ({\n        ignore: ignoreFile,\n        config: babelrcFile\n      } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));\n\n      if (ignoreFile) {\n        fileChain.files.add(ignoreFile.filepath);\n      }\n\n      if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n        isIgnored = true;\n      }\n\n      if (babelrcFile && !isIgnored) {\n        const validatedFile = validateBabelrcFile(babelrcFile);\n        const babelrcLogger = new _printer.ConfigPrinter();\n        const result = yield* loadFileChain(validatedFile, context, undefined, babelrcLogger);\n\n        if (!result) {\n          isIgnored = true;\n        } else {\n          babelRcReport = yield* babelrcLogger.output();\n          mergeChain(fileChain, result);\n        }\n      }\n\n      if (babelrcFile && isIgnored) {\n        fileChain.files.add(babelrcFile.filepath);\n      }\n    }\n  }\n\n  if (context.showConfig) {\n    console.log(`Babel configs on \"${context.filename}\" (ascending priority):\\n` + [configReport, babelRcReport, programmaticReport].filter(x => !!x).join(\"\\n\\n\") + \"\\n-----End Babel configs-----\");\n  }\n\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),\n    presets: isIgnored ? [] : dedupDescriptors(chain.presets),\n    options: isIgnored ? [] : chain.options.map(o => normalizeOptions(o)),\n    fileHandling: isIgnored ? \"ignored\" : \"transpile\",\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined,\n    files: chain.files\n  };\n}\n\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  let babelrcPatterns = babelrcRoots;\n\n  if (!Array.isArray(babelrcPatterns)) {\n    babelrcPatterns = [babelrcPatterns];\n  }\n\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().resolve(babelrcRootsDirectory, pat) : pat;\n  });\n\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nconst validateConfigFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName),\n  createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)\n});\nconst loadFileChainWalker = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),\n  createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)\n});\n\nfunction* loadFileChain(input, context, files, baseLogger) {\n  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);\n\n  if (chain) {\n    chain.files.add(input.filepath);\n  }\n\n  return chain;\n}\n\nconst loadFileDescriptors = (0, _caching.makeWeakCacheSync)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction buildFileLogger(filepath, context, baseLogger) {\n  if (!baseLogger) {\n    return () => {};\n  }\n\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {\n    filepath\n  });\n}\n\nfunction buildRootDescriptors({\n  dirname,\n  options\n}, alias, descriptors) {\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildProgrammaticLogger(_, context, baseLogger) {\n  var _context$caller;\n\n  if (!baseLogger) {\n    return () => {};\n  }\n\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {\n    callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name\n  });\n}\n\nfunction buildEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, envName) {\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\n\nfunction buildOverrideDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index) {\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\n\nfunction buildOverrideEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index, envName) {\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\n\nfunction makeChainWalker({\n  root,\n  env,\n  overrides,\n  overridesEnv,\n  createLogger\n}) {\n  return function* (input, context, files = new Set(), baseLogger) {\n    const {\n      dirname\n    } = input;\n    const flattenedConfigs = [];\n    const rootOpts = root(input);\n\n    if (configIsApplicable(rootOpts, dirname, context)) {\n      flattenedConfigs.push({\n        config: rootOpts,\n        envName: undefined,\n        index: undefined\n      });\n      const envOpts = env(input, context.envName);\n\n      if (envOpts && configIsApplicable(envOpts, dirname, context)) {\n        flattenedConfigs.push({\n          config: envOpts,\n          envName: context.envName,\n          index: undefined\n        });\n      }\n\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n\n        if (configIsApplicable(overrideOps, dirname, context)) {\n          flattenedConfigs.push({\n            config: overrideOps,\n            index,\n            envName: undefined\n          });\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {\n            flattenedConfigs.push({\n              config: overrideEnvOpts,\n              index,\n              envName: context.envName\n            });\n          }\n        }\n      });\n    }\n\n    if (flattenedConfigs.some(({\n      config: {\n        options: {\n          ignore,\n          only\n        }\n      }\n    }) => shouldIgnore(context, ignore, only, dirname))) {\n      return null;\n    }\n\n    const chain = emptyChain();\n    const logger = createLogger(input, context, baseLogger);\n\n    for (const {\n      config,\n      index,\n      envName\n    } of flattenedConfigs) {\n      if (!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger))) {\n        return null;\n      }\n\n      logger(config, index, envName);\n      yield* mergeChainOpts(chain, config);\n    }\n\n    return chain;\n  };\n}\n\nfunction* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {\n  if (opts.extends === undefined) return true;\n  const file = yield* (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n\n  files.add(file);\n  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\n\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n\n  return target;\n}\n\nfunction* mergeChainOpts(target, {\n  options,\n  plugins,\n  presets\n}) {\n  target.options.push(options);\n  target.plugins.push(...(yield* plugins()));\n  target.presets.push(...(yield* presets()));\n  return target;\n}\n\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set()\n  };\n}\n\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n\n  return options;\n}\n\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n\n      let desc = nameMap.get(item.name);\n\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable({\n  options\n}, dirname, context) {\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));\n}\n\nfunction configFieldIsApplicable(context, test, dirname) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname);\n}\n\nfunction ignoreListReplacer(_key, value) {\n  if (value instanceof RegExp) {\n    return String(value);\n  }\n\n  return value;\n}\n\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    var _context$filename;\n\n    const message = `No config is applied to \"${(_context$filename = context.filename) != null ? _context$filename : \"(unknown)\"}\" because it matches one of \\`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\\` from \"${dirname}\"`;\n    debug(message);\n\n    if (context.showConfig) {\n      console.log(message);\n    }\n\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    var _context$filename2;\n\n    const message = `No config is applied to \"${(_context$filename2 = context.filename) != null ? _context$filename2 : \"(unknown)\"}\" because it fails to match one of \\`only: ${JSON.stringify(only, ignoreListReplacer)}\\` from \"${dirname}\"`;\n    debug(message);\n\n    if (context.showConfig) {\n      console.log(message);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction matchesPatterns(context, patterns, dirname) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context));\n}\n\nfunction matchPattern(pattern, dirname, pathToTest, context) {\n  if (typeof pattern === \"function\") {\n    return !!pattern(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new Error(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`);\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n\n  return pattern.test(pathToTest);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assumptionsNames = void 0;\nexports.checkNoUnwrappedItemOptionPairs = checkNoUnwrappedItemOptionPairs;\nexports.validate = validate;\n\nvar _plugin = require(\"../plugin\");\n\nvar _removed = require(\"./removed\");\n\nvar _optionAssertions = require(\"./option-assertions\");\n\nconst ROOT_VALIDATORS = {\n  cwd: _optionAssertions.assertString,\n  root: _optionAssertions.assertString,\n  rootMode: _optionAssertions.assertRootMode,\n  configFile: _optionAssertions.assertConfigFileSearch,\n  caller: _optionAssertions.assertCallerMetadata,\n  filename: _optionAssertions.assertString,\n  filenameRelative: _optionAssertions.assertString,\n  code: _optionAssertions.assertBoolean,\n  ast: _optionAssertions.assertBoolean,\n  cloneInputAst: _optionAssertions.assertBoolean,\n  envName: _optionAssertions.assertString\n};\nconst BABELRC_VALIDATORS = {\n  babelrc: _optionAssertions.assertBoolean,\n  babelrcRoots: _optionAssertions.assertBabelrcSearch\n};\nconst NONPRESET_VALIDATORS = {\n  extends: _optionAssertions.assertString,\n  ignore: _optionAssertions.assertIgnoreList,\n  only: _optionAssertions.assertIgnoreList,\n  targets: _optionAssertions.assertTargets,\n  browserslistConfigFile: _optionAssertions.assertConfigFileSearch,\n  browserslistEnv: _optionAssertions.assertString\n};\nconst COMMON_VALIDATORS = {\n  inputSourceMap: _optionAssertions.assertInputSourceMap,\n  presets: _optionAssertions.assertPluginList,\n  plugins: _optionAssertions.assertPluginList,\n  passPerPreset: _optionAssertions.assertBoolean,\n  assumptions: _optionAssertions.assertAssumptions,\n  env: assertEnvSet,\n  overrides: assertOverridesList,\n  test: _optionAssertions.assertConfigApplicableTest,\n  include: _optionAssertions.assertConfigApplicableTest,\n  exclude: _optionAssertions.assertConfigApplicableTest,\n  retainLines: _optionAssertions.assertBoolean,\n  comments: _optionAssertions.assertBoolean,\n  shouldPrintComment: _optionAssertions.assertFunction,\n  compact: _optionAssertions.assertCompact,\n  minified: _optionAssertions.assertBoolean,\n  auxiliaryCommentBefore: _optionAssertions.assertString,\n  auxiliaryCommentAfter: _optionAssertions.assertString,\n  sourceType: _optionAssertions.assertSourceType,\n  wrapPluginVisitorMethod: _optionAssertions.assertFunction,\n  highlightCode: _optionAssertions.assertBoolean,\n  sourceMaps: _optionAssertions.assertSourceMaps,\n  sourceMap: _optionAssertions.assertSourceMaps,\n  sourceFileName: _optionAssertions.assertString,\n  sourceRoot: _optionAssertions.assertString,\n  parserOpts: _optionAssertions.assertObject,\n  generatorOpts: _optionAssertions.assertObject\n};\n{\n  Object.assign(COMMON_VALIDATORS, {\n    getModuleId: _optionAssertions.assertFunction,\n    moduleRoot: _optionAssertions.assertString,\n    moduleIds: _optionAssertions.assertBoolean,\n    moduleId: _optionAssertions.assertString\n  });\n}\nconst assumptionsNames = new Set([\"arrayLikeIsIterable\", \"constantReexports\", \"constantSuper\", \"enumerableModuleMeta\", \"ignoreFunctionLength\", \"ignoreToPrimitiveHint\", \"iterableIsArray\", \"mutableTemplateObject\", \"noClassCalls\", \"noDocumentAll\", \"noIncompleteNsImportDetection\", \"noNewArrows\", \"objectRestNoSymbols\", \"privateFieldsAsProperties\", \"pureGetters\", \"setClassMethods\", \"setComputedProperties\", \"setPublicClassFields\", \"setSpreadProperties\", \"skipForOfIteratorClosing\", \"superIsCallableConstructor\"]);\nexports.assumptionsNames = assumptionsNames;\n\nfunction getSource(loc) {\n  return loc.type === \"root\" ? loc.source : getSource(loc.parent);\n}\n\nfunction validate(type, opts) {\n  return validateNested({\n    type: \"root\",\n    source: type\n  }, opts);\n}\n\nfunction validateNested(loc, opts) {\n  const type = getSource(loc);\n  assertNoDuplicateSourcemap(opts);\n  Object.keys(opts).forEach(key => {\n    const optLoc = {\n      type: \"option\",\n      name: key,\n      parent: loc\n    };\n\n    if (type === \"preset\" && NONPRESET_VALIDATORS[key]) {\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);\n    }\n\n    if (type !== \"arguments\" && ROOT_VALIDATORS[key]) {\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);\n    }\n\n    if (type !== \"arguments\" && type !== \"configfile\" && BABELRC_VALIDATORS[key]) {\n      if (type === \"babelrcfile\" || type === \"extendsfile\") {\n        throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, ` + `or babel.config.js/config file options`);\n      }\n\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);\n    }\n\n    const validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;\n    validator(optLoc, opts[key]);\n  });\n  return opts;\n}\n\nfunction throwUnknownError(loc) {\n  const key = loc.name;\n\n  if (_removed.default[key]) {\n    const {\n      message,\n      version = 5\n    } = _removed.default[key];\n    throw new Error(`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);\n  } else {\n    const unknownOptErr = new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);\n    unknownOptErr.code = \"BABEL_UNKNOWN_OPTION\";\n    throw unknownOptErr;\n  }\n}\n\nfunction has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction assertNoDuplicateSourcemap(opts) {\n  if (has(opts, \"sourceMap\") && has(opts, \"sourceMaps\")) {\n    throw new Error(\".sourceMap is an alias for .sourceMaps, cannot use both\");\n  }\n}\n\nfunction assertEnvSet(loc, value) {\n  if (loc.parent.type === \"env\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);\n  }\n\n  const parent = loc.parent;\n  const obj = (0, _optionAssertions.assertObject)(loc, value);\n\n  if (obj) {\n    for (const envName of Object.keys(obj)) {\n      const env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);\n      if (!env) continue;\n      const envLoc = {\n        type: \"env\",\n        name: envName,\n        parent\n      };\n      validateNested(envLoc, env);\n    }\n  }\n\n  return obj;\n}\n\nfunction assertOverridesList(loc, value) {\n  if (loc.parent.type === \"env\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);\n  }\n\n  if (loc.parent.type === \"overrides\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);\n  }\n\n  const parent = loc.parent;\n  const arr = (0, _optionAssertions.assertArray)(loc, value);\n\n  if (arr) {\n    for (const [index, item] of arr.entries()) {\n      const objLoc = (0, _optionAssertions.access)(loc, index);\n      const env = (0, _optionAssertions.assertObject)(objLoc, item);\n      if (!env) throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);\n      const overridesLoc = {\n        type: \"overrides\",\n        index,\n        parent\n      };\n      validateNested(overridesLoc, env);\n    }\n  }\n\n  return arr;\n}\n\nfunction checkNoUnwrappedItemOptionPairs(items, index, type, e) {\n  if (index === 0) return;\n  const lastItem = items[index - 1];\n  const thisItem = items[index];\n\n  if (lastItem.file && lastItem.options === undefined && typeof thisItem.value === \"object\") {\n    e.message += `\\n- Maybe you meant to use\\n` + `\"${type}s\": [\\n  [\"${lastItem.file.request}\", ${JSON.stringify(thisItem.value, undefined, 2)}]\\n]\\n` + `To be a valid ${type}, its name and options should be wrapped in a pair of brackets`;\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  auxiliaryComment: {\n    message: \"Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`\"\n  },\n  blacklist: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  breakConfig: {\n    message: \"This is not a necessary option in Babel 6\"\n  },\n  experimental: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  externalHelpers: {\n    message: \"Use the `external-helpers` plugin instead. \" + \"Check out http://babeljs.io/docs/plugins/external-helpers/\"\n  },\n  extra: {\n    message: \"\"\n  },\n  jsxPragma: {\n    message: \"use the `pragma` option in the `react-jsx` plugin. \" + \"Check out http://babeljs.io/docs/plugins/transform-react-jsx/\"\n  },\n  loose: {\n    message: \"Specify the `loose` option for the relevant plugin you are using \" + \"or use a preset that sets the option.\"\n  },\n  metadataUsedHelpers: {\n    message: \"Not required anymore as this is enabled by default\"\n  },\n  modules: {\n    message: \"Use the corresponding module transform plugin in the `plugins` option. \" + \"Check out http://babeljs.io/docs/plugins/#modules\"\n  },\n  nonStandard: {\n    message: \"Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. \" + \"Also check out the react preset http://babeljs.io/docs/plugins/preset-react/\"\n  },\n  optional: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  sourceMapName: {\n    message: \"The `sourceMapName` option has been removed because it makes more sense for the \" + \"tooling that calls Babel to assign `map.file` themselves.\"\n  },\n  stage: {\n    message: \"Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets\"\n  },\n  whitelist: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  resolveModuleSource: {\n    version: 6,\n    message: \"Use `babel-plugin-module-resolver@3`'s 'resolvePath' options\"\n  },\n  metadata: {\n    version: 6,\n    message: \"Generated plugin metadata is always included in the output result\"\n  },\n  sourceMapTarget: {\n    version: 6,\n    message: \"The `sourceMapTarget` option has been removed because it makes more sense for the tooling \" + \"that calls Babel to assign `map.file` themselves.\"\n  }\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.access = access;\nexports.assertArray = assertArray;\nexports.assertAssumptions = assertAssumptions;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertBoolean = assertBoolean;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertCompact = assertCompact;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertFunction = assertFunction;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertObject = assertObject;\nexports.assertPluginList = assertPluginList;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertSourceType = assertSourceType;\nexports.assertString = assertString;\nexports.assertTargets = assertTargets;\nexports.msg = msg;\n\nfunction _helperCompilationTargets() {\n  const data = require(\"@babel/helper-compilation-targets\");\n\n  _helperCompilationTargets = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./options\");\n\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n\n    default:\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\n\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name,\n    parent: loc\n  };\n}\n\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(`${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(`${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCallerMetadata(loc, value) {\n  const obj = assertObject(loc, value);\n\n  if (obj) {\n    if (typeof obj.name !== \"string\") {\n      throw new Error(`${msg(loc)} set but does not contain \"name\" property string`);\n    }\n\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n\n      if (value != null && typeof value !== \"boolean\" && typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertIgnoreList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);\n  }\n\n  return value;\n}\n\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\n\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertPluginList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      const opts = value[1];\n\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);\n      }\n    }\n\n    if (value.length === 3) {\n      const name = value[2];\n\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  return value;\n}\n\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n\n  return value;\n}\n\nfunction assertTargets(loc, value) {\n  if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value)) return value;\n\n  if (typeof value !== \"object\" || !value || Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);\n  }\n\n  const browsersLoc = access(loc, \"browsers\");\n  const esmodulesLoc = access(loc, \"esmodules\");\n  assertBrowsersList(browsersLoc, value.browsers);\n  assertBoolean(esmodulesLoc, value.esmodules);\n\n  for (const key of Object.keys(value)) {\n    const val = value[key];\n    const subLoc = access(loc, key);\n    if (key === \"esmodules\") assertBoolean(subLoc, val);else if (key === \"browsers\") assertBrowsersList(subLoc, val);else if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {\n      const validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(\", \");\n      throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);\n    } else assertBrowserVersion(subLoc, val);\n  }\n\n  return value;\n}\n\nfunction assertBrowsersList(loc, value) {\n  if (value !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value)) {\n    throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);\n  }\n}\n\nfunction assertBrowserVersion(loc, value) {\n  if (typeof value === \"number\" && Math.round(value) === value) return;\n  if (typeof value === \"string\") return;\n  throw new Error(`${msg(loc)} must be a string or an integer number`);\n}\n\nfunction assertAssumptions(loc, value) {\n  if (value === undefined) return;\n\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(`${msg(loc)} must be an object or undefined.`);\n  }\n\n  let root = loc;\n\n  do {\n    root = root.parent;\n  } while (root.type !== \"root\");\n\n  const inPreset = root.source === \"preset\";\n\n  for (const name of Object.keys(value)) {\n    const subLoc = access(loc, name);\n\n    if (!_options.assumptionsNames.has(name)) {\n      throw new Error(`${msg(subLoc)} is not a supported assumption.`);\n    }\n\n    if (typeof value[name] !== \"boolean\") {\n      throw new Error(`${msg(subLoc)} must be a boolean.`);\n    }\n\n    if (inPreset && value[name] === false) {\n      throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);\n    }\n  }\n\n  return value;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConfigPrinter = exports.ChainFormatter = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nconst ChainFormatter = {\n  Programmatic: 0,\n  Config: 1\n};\nexports.ChainFormatter = ChainFormatter;\nconst Formatter = {\n  title(type, callerName, filepath) {\n    let title = \"\";\n\n    if (type === ChainFormatter.Programmatic) {\n      title = \"programmatic options\";\n\n      if (callerName) {\n        title += \" from \" + callerName;\n      }\n    } else {\n      title = \"config \" + filepath;\n    }\n\n    return title;\n  },\n\n  loc(index, envName) {\n    let loc = \"\";\n\n    if (index != null) {\n      loc += `.overrides[${index}]`;\n    }\n\n    if (envName != null) {\n      loc += `.env[\"${envName}\"]`;\n    }\n\n    return loc;\n  },\n\n  *optionsAndDescriptors(opt) {\n    const content = Object.assign({}, opt.options);\n    delete content.overrides;\n    delete content.env;\n    const pluginDescriptors = [...(yield* opt.plugins())];\n\n    if (pluginDescriptors.length) {\n      content.plugins = pluginDescriptors.map(d => descriptorToConfig(d));\n    }\n\n    const presetDescriptors = [...(yield* opt.presets())];\n\n    if (presetDescriptors.length) {\n      content.presets = [...presetDescriptors].map(d => descriptorToConfig(d));\n    }\n\n    return JSON.stringify(content, undefined, 2);\n  }\n\n};\n\nfunction descriptorToConfig(d) {\n  var _d$file;\n\n  let name = (_d$file = d.file) == null ? void 0 : _d$file.request;\n\n  if (name == null) {\n    if (typeof d.value === \"object\") {\n      name = d.value;\n    } else if (typeof d.value === \"function\") {\n      name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`;\n    }\n  }\n\n  if (name == null) {\n    name = \"[Unknown]\";\n  }\n\n  if (d.options === undefined) {\n    return name;\n  } else if (d.name == null) {\n    return [name, d.options];\n  } else {\n    return [name, d.options, d.name];\n  }\n}\n\nclass ConfigPrinter {\n  constructor() {\n    this._stack = [];\n  }\n\n  configure(enabled, type, {\n    callerName,\n    filepath\n  }) {\n    if (!enabled) return () => {};\n    return (content, index, envName) => {\n      this._stack.push({\n        type,\n        callerName,\n        filepath,\n        content,\n        index,\n        envName\n      });\n    };\n  }\n\n  static *format(config) {\n    let title = Formatter.title(config.type, config.callerName, config.filepath);\n    const loc = Formatter.loc(config.index, config.envName);\n    if (loc) title += ` ${loc}`;\n    const content = yield* Formatter.optionsAndDescriptors(config.content);\n    return `${title}\\n${content}`;\n  }\n\n  *output() {\n    if (this._stack.length === 0) return \"\";\n    const configs = yield* _gensync().all(this._stack.map(s => ConfigPrinter.format(s)));\n    return configs.join(\"\\n\\n\");\n  }\n\n}\n\nexports.ConfigPrinter = ConfigPrinter;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePluginObject = validatePluginObject;\n\nvar _optionAssertions = require(\"./option-assertions\");\n\nconst VALIDATORS = {\n  name: _optionAssertions.assertString,\n  manipulateOptions: _optionAssertions.assertFunction,\n  pre: _optionAssertions.assertFunction,\n  post: _optionAssertions.assertFunction,\n  inherits: _optionAssertions.assertFunction,\n  visitor: assertVisitorMap,\n  parserOverride: _optionAssertions.assertFunction,\n  generatorOverride: _optionAssertions.assertFunction\n};\n\nfunction assertVisitorMap(loc, value) {\n  const obj = (0, _optionAssertions.assertObject)(loc, value);\n\n  if (obj) {\n    Object.keys(obj).forEach(prop => assertVisitorHandler(prop, obj[prop]));\n\n    if (obj.enter || obj.exit) {\n      throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.`);\n    }\n  }\n\n  return obj;\n}\n\nfunction assertVisitorHandler(key, value) {\n  if (value && typeof value === \"object\") {\n    Object.keys(value).forEach(handler => {\n      if (handler !== \"enter\" && handler !== \"exit\") {\n        throw new Error(`.visitor[\"${key}\"] may only have .enter and/or .exit handlers.`);\n      }\n    });\n  } else if (typeof value !== \"function\") {\n    throw new Error(`.visitor[\"${key}\"] must be a function`);\n  }\n\n  return value;\n}\n\nfunction validatePluginObject(obj) {\n  const rootPath = {\n    type: \"root\",\n    source: \"plugin\"\n  };\n  Object.keys(obj).forEach(key => {\n    const validator = VALIDATORS[key];\n\n    if (validator) {\n      const optLoc = {\n        type: \"option\",\n        name: key,\n        parent: rootPath\n      };\n      validator(optLoc, obj[key]);\n    } else {\n      const invalidPluginPropertyError = new Error(`.${key} is not a valid Plugin property`);\n      invalidPluginPropertyError.code = \"BABEL_UNKNOWN_PLUGIN_PROPERTY\";\n      throw invalidPluginPropertyError;\n    }\n  });\n  return obj;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadPrivatePartialConfig;\nexports.loadPartialConfig = void 0;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _plugin = require(\"./plugin\");\n\nvar _util = require(\"./util\");\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nvar _environment = require(\"./helpers/environment\");\n\nvar _options = require(\"./validation/options\");\n\nvar _files = require(\"./files\");\n\nvar _resolveTargets = require(\"./resolve-targets\");\n\nconst _excluded = [\"showIgnoredFiles\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction resolveRootMode(rootDir, rootMode) {\n  switch (rootMode) {\n    case \"root\":\n      return rootDir;\n\n    case \"upward-optional\":\n      {\n        const upwardRootDir = (0, _files.findConfigUpwards)(rootDir);\n        return upwardRootDir === null ? rootDir : upwardRootDir;\n      }\n\n    case \"upward\":\n      {\n        const upwardRootDir = (0, _files.findConfigUpwards)(rootDir);\n        if (upwardRootDir !== null) return upwardRootDir;\n        throw Object.assign(new Error(`Babel was run with rootMode:\"upward\" but a root could not ` + `be found when searching upward from \"${rootDir}\".\\n` + `One of the following config files must be in the directory tree: ` + `\"${_files.ROOT_CONFIG_FILENAMES.join(\", \")}\".`), {\n          code: \"BABEL_ROOT_NOT_FOUND\",\n          dirname: rootDir\n        });\n      }\n\n    default:\n      throw new Error(`Assertion failure - unknown rootMode value.`);\n  }\n}\n\nfunction* loadPrivatePartialConfig(inputOpts) {\n  if (inputOpts != null && (typeof inputOpts !== \"object\" || Array.isArray(inputOpts))) {\n    throw new Error(\"Babel options must be an object, null, or undefined\");\n  }\n\n  const args = inputOpts ? (0, _options.validate)(\"arguments\", inputOpts) : {};\n  const {\n    envName = (0, _environment.getEnv)(),\n    cwd = \".\",\n    root: rootDir = \".\",\n    rootMode = \"root\",\n    caller,\n    cloneInputAst = true\n  } = args;\n\n  const absoluteCwd = _path().resolve(cwd);\n\n  const absoluteRootDir = resolveRootMode(_path().resolve(absoluteCwd, rootDir), rootMode);\n  const filename = typeof args.filename === \"string\" ? _path().resolve(cwd, args.filename) : undefined;\n  const showConfigPath = yield* (0, _files.resolveShowConfigPath)(absoluteCwd);\n  const context = {\n    filename,\n    cwd: absoluteCwd,\n    root: absoluteRootDir,\n    envName,\n    caller,\n    showConfig: showConfigPath === filename\n  };\n  const configChain = yield* (0, _configChain.buildRootChain)(args, context);\n  if (!configChain) return null;\n  const merged = {\n    assumptions: {}\n  };\n  configChain.options.forEach(opts => {\n    (0, _util.mergeOptions)(merged, opts);\n  });\n  const options = Object.assign({}, merged, {\n    targets: (0, _resolveTargets.resolveTargets)(merged, absoluteRootDir),\n    cloneInputAst,\n    babelrc: false,\n    configFile: false,\n    browserslistConfigFile: false,\n    passPerPreset: false,\n    envName: context.envName,\n    cwd: context.cwd,\n    root: context.root,\n    rootMode: \"root\",\n    filename: typeof context.filename === \"string\" ? context.filename : undefined,\n    plugins: configChain.plugins.map(descriptor => (0, _item.createItemFromDescriptor)(descriptor)),\n    presets: configChain.presets.map(descriptor => (0, _item.createItemFromDescriptor)(descriptor))\n  });\n  return {\n    options,\n    context,\n    fileHandling: configChain.fileHandling,\n    ignore: configChain.ignore,\n    babelrc: configChain.babelrc,\n    config: configChain.config,\n    files: configChain.files\n  };\n}\n\nconst loadPartialConfig = _gensync()(function* (opts) {\n  let showIgnoredFiles = false;\n\n  if (typeof opts === \"object\" && opts !== null && !Array.isArray(opts)) {\n    var _opts = opts;\n    ({\n      showIgnoredFiles\n    } = _opts);\n    opts = _objectWithoutPropertiesLoose(_opts, _excluded);\n    _opts;\n  }\n\n  const result = yield* loadPrivatePartialConfig(opts);\n  if (!result) return null;\n  const {\n    options,\n    babelrc,\n    ignore,\n    config,\n    fileHandling,\n    files\n  } = result;\n\n  if (fileHandling === \"ignored\" && !showIgnoredFiles) {\n    return null;\n  }\n\n  (options.plugins || []).forEach(item => {\n    if (item.value instanceof _plugin.default) {\n      throw new Error(\"Passing cached plugin instances is not supported in \" + \"babel.loadPartialConfig()\");\n    }\n  });\n  return new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined, fileHandling, files);\n});\n\nexports.loadPartialConfig = loadPartialConfig;\n\nclass PartialConfig {\n  constructor(options, babelrc, ignore, config, fileHandling, files) {\n    this.options = void 0;\n    this.babelrc = void 0;\n    this.babelignore = void 0;\n    this.config = void 0;\n    this.fileHandling = void 0;\n    this.files = void 0;\n    this.options = options;\n    this.babelignore = ignore;\n    this.babelrc = babelrc;\n    this.config = config;\n    this.fileHandling = fileHandling;\n    this.files = files;\n    Object.freeze(this);\n  }\n\n  hasFilesystemConfig() {\n    return this.babelrc !== undefined || this.config !== undefined;\n  }\n\n}\n\nObject.freeze(PartialConfig.prototype);","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformSync = exports.transformAsync = exports.transform = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _config = require(\"./config\");\n\nvar _transformation = require(\"./transformation\");\n\nconst transformRunner = _gensync()(function* transform(code, opts) {\n  const config = yield* (0, _config.default)(opts);\n  if (config === null) return null;\n  return yield* (0, _transformation.run)(config, code);\n});\n\nconst transform = function transform(code, opts, callback) {\n  if (typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n\n  if (callback === undefined) return transformRunner.sync(code, opts);\n  transformRunner.errback(code, opts, callback);\n};\n\nexports.transform = transform;\nconst transformSync = transformRunner.sync;\nexports.transformSync = transformSync;\nconst transformAsync = transformRunner.async;\nexports.transformAsync = transformAsync;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = run;\n\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _pluginPass = require(\"./plugin-pass\");\n\nvar _blockHoistPlugin = require(\"./block-hoist-plugin\");\n\nvar _normalizeOpts = require(\"./normalize-opts\");\n\nvar _normalizeFile = require(\"./normalize-file\");\n\nvar _generate = require(\"./file/generate\");\n\nvar _deepArray = require(\"../config/helpers/deep-array\");\n\nfunction* run(config, code, ast) {\n  const file = yield* (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast);\n  const opts = file.opts;\n\n  try {\n    yield* transformFile(file, config.passes);\n  } catch (e) {\n    var _opts$filename;\n\n    e.message = `${(_opts$filename = opts.filename) != null ? _opts$filename : \"unknown\"}: ${e.message}`;\n\n    if (!e.code) {\n      e.code = \"BABEL_TRANSFORM_ERROR\";\n    }\n\n    throw e;\n  }\n\n  let outputCode, outputMap;\n\n  try {\n    if (opts.code !== false) {\n      ({\n        outputCode,\n        outputMap\n      } = (0, _generate.default)(config.passes, file));\n    }\n  } catch (e) {\n    var _opts$filename2;\n\n    e.message = `${(_opts$filename2 = opts.filename) != null ? _opts$filename2 : \"unknown\"}: ${e.message}`;\n\n    if (!e.code) {\n      e.code = \"BABEL_GENERATE_ERROR\";\n    }\n\n    throw e;\n  }\n\n  return {\n    metadata: file.metadata,\n    options: opts,\n    ast: opts.ast === true ? file.ast : null,\n    code: outputCode === undefined ? null : outputCode,\n    map: outputMap === undefined ? null : outputMap,\n    sourceType: file.ast.program.sourceType,\n    externalDependencies: (0, _deepArray.flattenToSet)(config.externalDependencies)\n  };\n}\n\nfunction* transformFile(file, pluginPasses) {\n  for (const pluginPairs of pluginPasses) {\n    const passPairs = [];\n    const passes = [];\n    const visitors = [];\n\n    for (const plugin of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {\n      const pass = new _pluginPass.default(file, plugin.key, plugin.options);\n      passPairs.push([plugin, pass]);\n      passes.push(pass);\n      visitors.push(plugin.visitor);\n    }\n\n    for (const [plugin, pass] of passPairs) {\n      const fn = plugin.pre;\n\n      if (fn) {\n        const result = fn.call(pass, file);\n        yield* [];\n\n        if (isThenable(result)) {\n          throw new Error(`You appear to be using an plugin with an async .pre, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n        }\n      }\n    }\n\n    const visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);\n\n    (0, _traverse().default)(file.ast, visitor, file.scope);\n\n    for (const [plugin, pass] of passPairs) {\n      const fn = plugin.post;\n\n      if (fn) {\n        const result = fn.call(pass, file);\n        yield* [];\n\n        if (isThenable(result)) {\n          throw new Error(`You appear to be using an plugin with an async .post, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n        }\n      }\n    }\n  }\n}\n\nfunction isThenable(val) {\n  return !!val && (typeof val === \"object\" || typeof val === \"function\") && !!val.then && typeof val.then === \"function\";\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass PluginPass {\n  constructor(file, key, options) {\n    this._map = new Map();\n    this.key = void 0;\n    this.file = void 0;\n    this.opts = void 0;\n    this.cwd = void 0;\n    this.filename = void 0;\n    this.key = key;\n    this.file = file;\n    this.opts = options || {};\n    this.cwd = file.opts.cwd;\n    this.filename = file.opts.filename;\n  }\n\n  set(key, val) {\n    this._map.set(key, val);\n  }\n\n  get(key) {\n    return this._map.get(key);\n  }\n\n  availableHelper(name, versionRange) {\n    return this.file.availableHelper(name, versionRange);\n  }\n\n  addHelper(name) {\n    return this.file.addHelper(name);\n  }\n\n  addImport() {\n    return this.file.addImport();\n  }\n\n  buildCodeFrameError(node, msg, _Error) {\n    return this.file.buildCodeFrameError(node, msg, _Error);\n  }\n\n}\n\nexports.default = PluginPass;\n{\n  PluginPass.prototype.getModuleName = function getModuleName() {\n    return this.file.getModuleName();\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadBlockHoistPlugin;\n\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _plugin = require(\"../config/plugin\");\n\nlet LOADED_PLUGIN;\n\nfunction loadBlockHoistPlugin() {\n  if (!LOADED_PLUGIN) {\n    LOADED_PLUGIN = new _plugin.default(Object.assign({}, blockHoistPlugin, {\n      visitor: _traverse().default.explode(blockHoistPlugin.visitor)\n    }), {});\n  }\n\n  return LOADED_PLUGIN;\n}\n\nfunction priority(bodyNode) {\n  const priority = bodyNode == null ? void 0 : bodyNode._blockHoist;\n  if (priority == null) return 1;\n  if (priority === true) return 2;\n  return priority;\n}\n\nfunction stableSort(body) {\n  const buckets = Object.create(null);\n\n  for (let i = 0; i < body.length; i++) {\n    const n = body[i];\n    const p = priority(n);\n    const bucket = buckets[p] || (buckets[p] = []);\n    bucket.push(n);\n  }\n\n  const keys = Object.keys(buckets).map(k => +k).sort((a, b) => b - a);\n  let index = 0;\n\n  for (const key of keys) {\n    const bucket = buckets[key];\n\n    for (const n of bucket) {\n      body[index++] = n;\n    }\n  }\n\n  return body;\n}\n\nconst blockHoistPlugin = {\n  name: \"internal.blockHoist\",\n  visitor: {\n    Block: {\n      exit({\n        node\n      }) {\n        const {\n          body\n        } = node;\n        let max = Math.pow(2, 30) - 1;\n        let hasChange = false;\n\n        for (let i = 0; i < body.length; i++) {\n          const n = body[i];\n          const p = priority(n);\n\n          if (p > max) {\n            hasChange = true;\n            break;\n          }\n\n          max = p;\n        }\n\n        if (!hasChange) return;\n        node.body = stableSort(body.slice());\n      }\n\n    }\n  }\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeOptions;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction normalizeOptions(config) {\n  const {\n    filename,\n    cwd,\n    filenameRelative = typeof filename === \"string\" ? _path().relative(cwd, filename) : \"unknown\",\n    sourceType = \"module\",\n    inputSourceMap,\n    sourceMaps = !!inputSourceMap,\n    sourceRoot = config.options.moduleRoot,\n    sourceFileName = _path().basename(filenameRelative),\n    comments = true,\n    compact = \"auto\"\n  } = config.options;\n  const opts = config.options;\n  const options = Object.assign({}, opts, {\n    parserOpts: Object.assign({\n      sourceType: _path().extname(filenameRelative) === \".mjs\" ? \"module\" : sourceType,\n      sourceFileName: filename,\n      plugins: []\n    }, opts.parserOpts),\n    generatorOpts: Object.assign({\n      filename,\n      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n      retainLines: opts.retainLines,\n      comments,\n      shouldPrintComment: opts.shouldPrintComment,\n      compact,\n      minified: opts.minified,\n      sourceMaps,\n      sourceRoot,\n      sourceFileName\n    }, opts.generatorOpts)\n  });\n\n  for (const plugins of config.passes) {\n    for (const plugin of plugins) {\n      if (plugin.manipulateOptions) {\n        plugin.manipulateOptions(options, options.parserOpts);\n      }\n    }\n  }\n\n  return options;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _fs() {\n  const data = require(\"fs\");\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _t() {\n  const data = require(\"@babel/types\");\n\n  _t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require(\"convert-source-map\");\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = require(\"./file/file\");\n\nvar _parser = require(\"../parser\");\n\nvar _cloneDeep = require(\"./util/clone-deep\");\n\nconst {\n  file,\n  traverseFast\n} = _t();\n\nconst debug = _debug()(\"babel:transform:file\");\n\nconst LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;\n\nfunction* normalizeFile(pluginPasses, options, code, ast) {\n  code = `${code || \"\"}`;\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    if (options.cloneInputAst) {\n      ast = (0, _cloneDeep.default)(ast);\n    }\n  } else {\n    ast = yield* (0, _parser.default)(pluginPasses, options, code);\n  }\n\n  let inputMap = null;\n\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n\n      if (lastComment) {\n        try {\n          inputMap = _convertSourceMap().fromComment(lastComment);\n        } catch (err) {\n          debug(\"discarding unknown inline input sourcemap\", err);\n        }\n      }\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n\n      if (typeof options.filename === \"string\" && lastComment) {\n        try {\n          const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment);\n\n          const inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]));\n\n          if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {\n            debug(\"skip merging input map > 1 MB\");\n          } else {\n            inputMap = _convertSourceMap().fromJSON(inputMapContent);\n          }\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n\n  return new _file.default(options, {\n    code,\n    ast,\n    inputMap\n  });\n}\n\nconst INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nconst EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+)[ \\t]*$/;\n\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(({\n      value\n    }) => {\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex, ast) {\n  let lastComment = null;\n  traverseFast(ast, node => {\n    [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment);\n    [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment);\n    [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);\n  });\n  return lastComment;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\n\nfunction _parser() {\n  const data = require(\"@babel/parser\");\n\n  _parser = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _codeFrame() {\n  const data = require(\"@babel/code-frame\");\n\n  _codeFrame = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _missingPluginHelper = require(\"./util/missing-plugin-helper\");\n\nfunction* parser(pluginPasses, {\n  parserOpts,\n  highlightCode = true,\n  filename = \"unknown\"\n}, code) {\n  try {\n    const results = [];\n\n    for (const plugins of pluginPasses) {\n      for (const plugin of plugins) {\n        const {\n          parserOverride\n        } = plugin;\n\n        if (parserOverride) {\n          const ast = parserOverride(code, parserOpts, _parser().parse);\n          if (ast !== undefined) results.push(ast);\n        }\n      }\n    }\n\n    if (results.length === 0) {\n      return (0, _parser().parse)(code, parserOpts);\n    } else if (results.length === 1) {\n      yield* [];\n\n      if (typeof results[0].then === \"function\") {\n        throw new Error(`You appear to be using an async parser plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n      }\n\n      return results[0];\n    }\n\n    throw new Error(\"More than one plugin attempted to override parsing.\");\n  } catch (err) {\n    if (err.code === \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\") {\n      err.message += \"\\nConsider renaming the file to '.mjs', or setting sourceType:module \" + \"or sourceType:unambiguous in your Babel config for this file.\";\n    }\n\n    const {\n      loc,\n      missingPlugin\n    } = err;\n\n    if (loc) {\n      const codeFrame = (0, _codeFrame().codeFrameColumns)(code, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      }, {\n        highlightCode\n      });\n\n      if (missingPlugin) {\n        err.message = `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);\n      } else {\n        err.message = `${filename}: ${err.message}\\n\\n` + codeFrame;\n      }\n\n      err.code = \"BABEL_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = generateMissingPluginMessage;\nconst pluginNameMap = {\n  asyncDoExpressions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-async-do-expressions\",\n      url: \"https://git.io/JYer8\"\n    }\n  },\n  classProperties: {\n    syntax: {\n      name: \"@babel/plugin-syntax-class-properties\",\n      url: \"https://git.io/vb4yQ\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-class-properties\",\n      url: \"https://git.io/vb4SL\"\n    }\n  },\n  classPrivateProperties: {\n    syntax: {\n      name: \"@babel/plugin-syntax-class-properties\",\n      url: \"https://git.io/vb4yQ\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-class-properties\",\n      url: \"https://git.io/vb4SL\"\n    }\n  },\n  classPrivateMethods: {\n    syntax: {\n      name: \"@babel/plugin-syntax-class-properties\",\n      url: \"https://git.io/vb4yQ\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-private-methods\",\n      url: \"https://git.io/JvpRG\"\n    }\n  },\n  classStaticBlock: {\n    syntax: {\n      name: \"@babel/plugin-syntax-class-static-block\",\n      url: \"https://git.io/JTLB6\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-class-static-block\",\n      url: \"https://git.io/JTLBP\"\n    }\n  },\n  decimal: {\n    syntax: {\n      name: \"@babel/plugin-syntax-decimal\",\n      url: \"https://git.io/JfKOH\"\n    }\n  },\n  decorators: {\n    syntax: {\n      name: \"@babel/plugin-syntax-decorators\",\n      url: \"https://git.io/vb4y9\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-decorators\",\n      url: \"https://git.io/vb4ST\"\n    }\n  },\n  doExpressions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-do-expressions\",\n      url: \"https://git.io/vb4yh\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-do-expressions\",\n      url: \"https://git.io/vb4S3\"\n    }\n  },\n  dynamicImport: {\n    syntax: {\n      name: \"@babel/plugin-syntax-dynamic-import\",\n      url: \"https://git.io/vb4Sv\"\n    }\n  },\n  exportDefaultFrom: {\n    syntax: {\n      name: \"@babel/plugin-syntax-export-default-from\",\n      url: \"https://git.io/vb4SO\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-export-default-from\",\n      url: \"https://git.io/vb4yH\"\n    }\n  },\n  exportNamespaceFrom: {\n    syntax: {\n      name: \"@babel/plugin-syntax-export-namespace-from\",\n      url: \"https://git.io/vb4Sf\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-export-namespace-from\",\n      url: \"https://git.io/vb4SG\"\n    }\n  },\n  flow: {\n    syntax: {\n      name: \"@babel/plugin-syntax-flow\",\n      url: \"https://git.io/vb4yb\"\n    },\n    transform: {\n      name: \"@babel/preset-flow\",\n      url: \"https://git.io/JfeDn\"\n    }\n  },\n  functionBind: {\n    syntax: {\n      name: \"@babel/plugin-syntax-function-bind\",\n      url: \"https://git.io/vb4y7\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-function-bind\",\n      url: \"https://git.io/vb4St\"\n    }\n  },\n  functionSent: {\n    syntax: {\n      name: \"@babel/plugin-syntax-function-sent\",\n      url: \"https://git.io/vb4yN\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-function-sent\",\n      url: \"https://git.io/vb4SZ\"\n    }\n  },\n  importMeta: {\n    syntax: {\n      name: \"@babel/plugin-syntax-import-meta\",\n      url: \"https://git.io/vbKK6\"\n    }\n  },\n  jsx: {\n    syntax: {\n      name: \"@babel/plugin-syntax-jsx\",\n      url: \"https://git.io/vb4yA\"\n    },\n    transform: {\n      name: \"@babel/preset-react\",\n      url: \"https://git.io/JfeDR\"\n    }\n  },\n  importAssertions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-import-assertions\",\n      url: \"https://git.io/JUbkv\"\n    }\n  },\n  moduleStringNames: {\n    syntax: {\n      name: \"@babel/plugin-syntax-module-string-names\",\n      url: \"https://git.io/JTL8G\"\n    }\n  },\n  numericSeparator: {\n    syntax: {\n      name: \"@babel/plugin-syntax-numeric-separator\",\n      url: \"https://git.io/vb4Sq\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-numeric-separator\",\n      url: \"https://git.io/vb4yS\"\n    }\n  },\n  optionalChaining: {\n    syntax: {\n      name: \"@babel/plugin-syntax-optional-chaining\",\n      url: \"https://git.io/vb4Sc\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-optional-chaining\",\n      url: \"https://git.io/vb4Sk\"\n    }\n  },\n  pipelineOperator: {\n    syntax: {\n      name: \"@babel/plugin-syntax-pipeline-operator\",\n      url: \"https://git.io/vb4yj\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-pipeline-operator\",\n      url: \"https://git.io/vb4SU\"\n    }\n  },\n  privateIn: {\n    syntax: {\n      name: \"@babel/plugin-syntax-private-property-in-object\",\n      url: \"https://git.io/JfK3q\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-private-property-in-object\",\n      url: \"https://git.io/JfK3O\"\n    }\n  },\n  recordAndTuple: {\n    syntax: {\n      name: \"@babel/plugin-syntax-record-and-tuple\",\n      url: \"https://git.io/JvKp3\"\n    }\n  },\n  regexpUnicodeSets: {\n    syntax: {\n      name: \"@babel/plugin-syntax-unicode-sets-regex\",\n      url: \"https://git.io/J9GTd\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-unicode-sets-regex\",\n      url: \"https://git.io/J9GTQ\"\n    }\n  },\n  throwExpressions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-throw-expressions\",\n      url: \"https://git.io/vb4SJ\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-throw-expressions\",\n      url: \"https://git.io/vb4yF\"\n    }\n  },\n  typescript: {\n    syntax: {\n      name: \"@babel/plugin-syntax-typescript\",\n      url: \"https://git.io/vb4SC\"\n    },\n    transform: {\n      name: \"@babel/preset-typescript\",\n      url: \"https://git.io/JfeDz\"\n    }\n  },\n  asyncGenerators: {\n    syntax: {\n      name: \"@babel/plugin-syntax-async-generators\",\n      url: \"https://git.io/vb4SY\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-async-generator-functions\",\n      url: \"https://git.io/vb4yp\"\n    }\n  },\n  logicalAssignment: {\n    syntax: {\n      name: \"@babel/plugin-syntax-logical-assignment-operators\",\n      url: \"https://git.io/vAlBp\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-logical-assignment-operators\",\n      url: \"https://git.io/vAlRe\"\n    }\n  },\n  nullishCoalescingOperator: {\n    syntax: {\n      name: \"@babel/plugin-syntax-nullish-coalescing-operator\",\n      url: \"https://git.io/vb4yx\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-nullish-coalescing-operator\",\n      url: \"https://git.io/vb4Se\"\n    }\n  },\n  objectRestSpread: {\n    syntax: {\n      name: \"@babel/plugin-syntax-object-rest-spread\",\n      url: \"https://git.io/vb4y5\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-object-rest-spread\",\n      url: \"https://git.io/vb4Ss\"\n    }\n  },\n  optionalCatchBinding: {\n    syntax: {\n      name: \"@babel/plugin-syntax-optional-catch-binding\",\n      url: \"https://git.io/vb4Sn\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-optional-catch-binding\",\n      url: \"https://git.io/vb4SI\"\n    }\n  }\n};\npluginNameMap.privateIn.syntax = pluginNameMap.privateIn.transform;\n\nconst getNameURLCombination = ({\n  name,\n  url\n}) => `${name} (${url})`;\n\nfunction generateMissingPluginMessage(missingPluginName, loc, codeFrame) {\n  let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled ` + `(${loc.line}:${loc.column + 1}):\\n\\n` + codeFrame;\n  const pluginInfo = pluginNameMap[missingPluginName];\n\n  if (pluginInfo) {\n    const {\n      syntax: syntaxPlugin,\n      transform: transformPlugin\n    } = pluginInfo;\n\n    if (syntaxPlugin) {\n      const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);\n\n      if (transformPlugin) {\n        const transformPluginInfo = getNameURLCombination(transformPlugin);\n        const sectionType = transformPlugin.name.startsWith(\"@babel/plugin\") ? \"plugins\" : \"presets\";\n        helpMessage += `\\n\\nAdd ${transformPluginInfo} to the '${sectionType}' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;\n      } else {\n        helpMessage += `\\n\\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config ` + `to enable parsing.`;\n      }\n    }\n  }\n\n  return helpMessage;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nfunction _v() {\n  const data = require(\"v8\");\n\n  _v = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _cloneDeepBrowser = require(\"./clone-deep-browser\");\n\nfunction _default(value) {\n  if (_v().deserialize && _v().serialize) {\n    return _v().deserialize(_v().serialize(value));\n  }\n\n  return (0, _cloneDeepBrowser.default)(value);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nconst serialized = \"$$ babel internal serialized type\" + Math.random();\n\nfunction serialize(key, value) {\n  if (typeof value !== \"bigint\") return value;\n  return {\n    [serialized]: \"BigInt\",\n    value: value.toString()\n  };\n}\n\nfunction revive(key, value) {\n  if (!value || typeof value !== \"object\") return value;\n  if (value[serialized] !== \"BigInt\") return value;\n  return BigInt(value.value);\n}\n\nfunction _default(value) {\n  return JSON.parse(JSON.stringify(value, serialize), revive);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = generateCode;\n\nfunction _convertSourceMap() {\n  const data = require(\"convert-source-map\");\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _generator() {\n  const data = require(\"@babel/generator\");\n\n  _generator = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _mergeMap = require(\"./merge-map\");\n\nfunction generateCode(pluginPasses, file) {\n  const {\n    opts,\n    ast,\n    code,\n    inputMap\n  } = file;\n  const {\n    generatorOpts\n  } = opts;\n  const results = [];\n\n  for (const plugins of pluginPasses) {\n    for (const plugin of plugins) {\n      const {\n        generatorOverride\n      } = plugin;\n\n      if (generatorOverride) {\n        const result = generatorOverride(ast, generatorOpts, code, _generator().default);\n        if (result !== undefined) results.push(result);\n      }\n    }\n  }\n\n  let result;\n\n  if (results.length === 0) {\n    result = (0, _generator().default)(ast, generatorOpts, code);\n  } else if (results.length === 1) {\n    result = results[0];\n\n    if (typeof result.then === \"function\") {\n      throw new Error(`You appear to be using an async codegen plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version.`);\n    }\n  } else {\n    throw new Error(\"More than one plugin attempted to override codegen.\");\n  }\n\n  let {\n    code: outputCode,\n    map: outputMap\n  } = result;\n\n  if (outputMap && inputMap) {\n    outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap, generatorOpts.sourceFileName);\n  }\n\n  if (opts.sourceMaps === \"inline\" || opts.sourceMaps === \"both\") {\n    outputCode += \"\\n\" + _convertSourceMap().fromObject(outputMap).toComment();\n  }\n\n  if (opts.sourceMaps === \"inline\") {\n    outputMap = null;\n  }\n\n  return {\n    outputCode,\n    outputMap\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mergeSourceMap;\n\nfunction _remapping() {\n  const data = require(\"@ampproject/remapping\");\n\n  _remapping = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction mergeSourceMap(inputMap, map, sourceFileName) {\n  const source = sourceFileName.replace(/\\\\/g, \"/\");\n  let found = false;\n\n  const result = _remapping()(rootless(map), (s, ctx) => {\n    if (s === source && !found) {\n      found = true;\n      ctx.source = \"\";\n      return rootless(inputMap);\n    }\n\n    return null;\n  });\n\n  if (typeof inputMap.sourceRoot === \"string\") {\n    result.sourceRoot = inputMap.sourceRoot;\n  }\n\n  return Object.assign({}, result);\n}\n\nfunction rootless(map) {\n  return Object.assign({}, map, {\n    sourceRoot: null\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformFileSync = exports.transformFileAsync = exports.transformFile = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _config = require(\"./config\");\n\nvar _transformation = require(\"./transformation\");\n\nvar fs = require(\"./gensync-utils/fs\");\n\n({});\n\nconst transformFileRunner = _gensync()(function* (filename, opts) {\n  const options = Object.assign({}, opts, {\n    filename\n  });\n  const config = yield* (0, _config.default)(options);\n  if (config === null) return null;\n  const code = yield* fs.readFile(filename, \"utf8\");\n  return yield* (0, _transformation.run)(config, code);\n});\n\nconst transformFile = transformFileRunner.errback;\nexports.transformFile = transformFile;\nconst transformFileSync = transformFileRunner.sync;\nexports.transformFileSync = transformFileSync;\nconst transformFileAsync = transformFileRunner.async;\nexports.transformFileAsync = transformFileAsync;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformFromAstSync = exports.transformFromAstAsync = exports.transformFromAst = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _config = require(\"./config\");\n\nvar _transformation = require(\"./transformation\");\n\nconst transformFromAstRunner = _gensync()(function* (ast, code, opts) {\n  const config = yield* (0, _config.default)(opts);\n  if (config === null) return null;\n  if (!ast) throw new Error(\"No AST given\");\n  return yield* (0, _transformation.run)(config, code, ast);\n});\n\nconst transformFromAst = function transformFromAst(ast, code, opts, callback) {\n  if (typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n\n  if (callback === undefined) {\n    return transformFromAstRunner.sync(ast, code, opts);\n  }\n\n  transformFromAstRunner.errback(ast, code, opts, callback);\n};\n\nexports.transformFromAst = transformFromAst;\nconst transformFromAstSync = transformFromAstRunner.sync;\nexports.transformFromAstSync = transformFromAstSync;\nconst transformFromAstAsync = transformFromAstRunner.async;\nexports.transformFromAstAsync = transformFromAstAsync;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseSync = exports.parseAsync = exports.parse = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _config = require(\"./config\");\n\nvar _parser = require(\"./parser\");\n\nvar _normalizeOpts = require(\"./transformation/normalize-opts\");\n\nconst parseRunner = _gensync()(function* parse(code, opts) {\n  const config = yield* (0, _config.default)(opts);\n\n  if (config === null) {\n    return null;\n  }\n\n  return yield* (0, _parser.default)(config.passes, (0, _normalizeOpts.default)(config), code);\n});\n\nconst parse = function parse(code, opts, callback) {\n  if (typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n\n  if (callback === undefined) return parseRunner.sync(code, opts);\n  parseRunner.errback(code, opts, callback);\n};\n\nexports.parse = parse;\nconst parseSync = parseRunner.sync;\nexports.parseSync = parseSync;\nconst parseAsync = parseRunner.async;\nexports.parseAsync = parseAsync;"]}