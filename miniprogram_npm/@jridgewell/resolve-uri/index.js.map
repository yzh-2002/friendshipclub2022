{"version":3,"sources":["resolve-uri.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, (function () { \n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?/;\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return {\n            scheme: match[1],\n            user: match[2] || '',\n            host: match[3],\n            port: match[4] || '',\n            path: match[5] || '/',\n            relativePath: false,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            return url;\n        }\n        if (!isAbsoluteUrl(input)) {\n            const url = parseAbsoluteUrl('http://foo.com/' + input);\n            url.scheme = '';\n            url.host = '';\n            url.relativePath = true;\n            return url;\n        }\n        return parseAbsoluteUrl(input);\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.\n        if (!url.relativePath)\n            return;\n        normalizePath(base);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n        // If the base path is absolute, then our path is now absolute too.\n        url.relativePath = base.relativePath;\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url) {\n        const { relativePath } = url;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (relativePath) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        // If we have a base, and the input isn't already an absolute URL, then we need to merge.\n        if (base && !url.scheme) {\n            const baseUrl = parseUrl(base);\n            url.scheme = baseUrl.scheme;\n            // If there's no host, then we were just a path.\n            if (!url.host || baseUrl.scheme === 'file:') {\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            }\n            mergePaths(url, baseUrl);\n        }\n        normalizePath(url);\n        // If the input (and base, if there was one) are both relative, then we need to output a relative.\n        if (url.relativePath) {\n            // The first char is always a \"/\".\n            const path = url.path.slice(1);\n            if (!path)\n                return '.';\n            // If base started with a leading \".\", or there is no base and input started with a \".\", then we\n            // need to ensure that the relative path starts with a \".\". We don't know if relative starts\n            // with a \"..\", though, so check before prepending.\n            const keepRelative = (base || input).startsWith('.');\n            return !keepRelative || path.startsWith('.') ? path : './' + path;\n        }\n        // If there's no host (and no scheme/user/port), then we need to output an absolute path.\n        if (!url.scheme && !url.host)\n            return url.path;\n        // We're outputting either an absolute URL, or a protocol relative one.\n        return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;\n    }\n\n    return resolve;\n\n}));\n//# sourceMappingURL=resolve-uri.umd.js.map\n"]}