{"version":3,"sources":["index.js","../package.json","cache.js","transform.js","Error.js","injectCaller.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,AGTA,AFMA,AFMA,AGTA;AFOA,AGTA,AFMA,AFMA,AGTA;AFOA,AGTA,AFMA,AFMA,AGTA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,AGTA,AFMA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AKfA,AFMA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nlet babel;\n\ntry {\n  babel = require(\"@babel/core\");\n} catch (err) {\n  if (err.code === \"MODULE_NOT_FOUND\") {\n    err.message += \"\\n babel-loader@8 requires Babel 7.x (the package '@babel/core'). \" + \"If you'd like to use Babel 6.x ('babel-core'), you should install 'babel-loader@7'.\";\n  }\n\n  throw err;\n} // Since we've got the reverse bridge package at @babel/core@6.x, give\n// people useful feedback if they try to use it alongside babel-loader.\n\n\nif (/^6\\./.test(babel.version)) {\n  throw new Error(\"\\n babel-loader@8 will not work with the '@babel/core@6' bridge package. \" + \"If you want to use Babel 6.x, install 'babel-loader@7'.\");\n}\n\nconst {\n  version\n} = require(\"../package.json\");\n\nconst cache = require(\"./cache\");\n\nconst transform = require(\"./transform\");\n\nconst injectCaller = require(\"./injectCaller\");\n\nconst schema = require(\"./schema\");\n\nconst {\n  isAbsolute\n} = require(\"path\");\n\nconst loaderUtils = require(\"loader-utils\");\n\nconst validateOptions = require(\"schema-utils\");\n\nfunction subscribe(subscriber, metadata, context) {\n  if (context[subscriber]) {\n    context[subscriber](metadata);\n  }\n}\n\nmodule.exports = makeLoader();\nmodule.exports.custom = makeLoader;\n\nfunction makeLoader(callback) {\n  const overrides = callback ? callback(babel) : undefined;\n  return function (source, inputSourceMap) {\n    // Make the loader async\n    const callback = this.async();\n    loader.call(this, source, inputSourceMap, overrides).then(args => callback(null, ...args), err => callback(err));\n  };\n}\n\nfunction loader(_x, _x2, _x3) {\n  return _loader.apply(this, arguments);\n}\n\nfunction _loader() {\n  _loader = _asyncToGenerator(function* (source, inputSourceMap, overrides) {\n    const filename = this.resourcePath;\n    let loaderOptions = loaderUtils.getOptions(this);\n    validateOptions(schema, loaderOptions, {\n      name: \"Babel loader\"\n    });\n\n    if (loaderOptions.customize != null) {\n      if (typeof loaderOptions.customize !== \"string\") {\n        throw new Error(\"Customized loaders must be implemented as standalone modules.\");\n      }\n\n      if (!isAbsolute(loaderOptions.customize)) {\n        throw new Error(\"Customized loaders must be passed as absolute paths, since \" + \"babel-loader has no way to know what they would be relative to.\");\n      }\n\n      if (overrides) {\n        throw new Error(\"babel-loader's 'customize' option is not available when already \" + \"using a customized babel-loader wrapper.\");\n      }\n\n      let override = require(loaderOptions.customize);\n\n      if (override.__esModule) override = override.default;\n\n      if (typeof override !== \"function\") {\n        throw new Error(\"Custom overrides must be functions.\");\n      }\n\n      overrides = override(babel);\n    }\n\n    let customOptions;\n\n    if (overrides && overrides.customOptions) {\n      const result = yield overrides.customOptions.call(this, loaderOptions, {\n        source,\n        map: inputSourceMap\n      });\n      customOptions = result.custom;\n      loaderOptions = result.loader;\n    } // Deprecation handling\n\n\n    if (\"forceEnv\" in loaderOptions) {\n      console.warn(\"The option `forceEnv` has been removed in favor of `envName` in Babel 7.\");\n    }\n\n    if (typeof loaderOptions.babelrc === \"string\") {\n      console.warn(\"The option `babelrc` should not be set to a string anymore in the babel-loader config. \" + \"Please update your configuration and set `babelrc` to true or false.\\n\" + \"If you want to specify a specific babel config file to inherit config from \" + \"please use the `extends` option.\\nFor more information about this options see \" + \"https://babeljs.io/docs/core-packages/#options\");\n    } // Standardize on 'sourceMaps' as the key passed through to Webpack, so that\n    // users may safely use either one alongside our default use of\n    // 'this.sourceMap' below without getting error about conflicting aliases.\n\n\n    if (Object.prototype.hasOwnProperty.call(loaderOptions, \"sourceMap\") && !Object.prototype.hasOwnProperty.call(loaderOptions, \"sourceMaps\")) {\n      loaderOptions = Object.assign({}, loaderOptions, {\n        sourceMaps: loaderOptions.sourceMap\n      });\n      delete loaderOptions.sourceMap;\n    }\n\n    const programmaticOptions = Object.assign({}, loaderOptions, {\n      filename,\n      inputSourceMap: inputSourceMap || undefined,\n      // Set the default sourcemap behavior based on Webpack's mapping flag,\n      // but allow users to override if they want.\n      sourceMaps: loaderOptions.sourceMaps === undefined ? this.sourceMap : loaderOptions.sourceMaps,\n      // Ensure that Webpack will get a full absolute path in the sourcemap\n      // so that it can properly map the module back to its internal cached\n      // modules.\n      sourceFileName: filename\n    }); // Remove loader related options\n\n    delete programmaticOptions.customize;\n    delete programmaticOptions.cacheDirectory;\n    delete programmaticOptions.cacheIdentifier;\n    delete programmaticOptions.cacheCompression;\n    delete programmaticOptions.metadataSubscribers;\n\n    if (!babel.loadPartialConfig) {\n      throw new Error(`babel-loader ^8.0.0-beta.3 requires @babel/core@7.0.0-beta.41, but ` + `you appear to be using \"${babel.version}\". Either update your ` + `@babel/core version, or pin you babel-loader version to 8.0.0-beta.2`);\n    } // babel.loadPartialConfigAsync is available in v7.8.0+\n\n\n    const {\n      loadPartialConfigAsync = babel.loadPartialConfig\n    } = babel;\n    const config = yield loadPartialConfigAsync(injectCaller(programmaticOptions, this.target));\n\n    if (config) {\n      let options = config.options;\n\n      if (overrides && overrides.config) {\n        options = yield overrides.config.call(this, config, {\n          source,\n          map: inputSourceMap,\n          customOptions\n        });\n      }\n\n      if (options.sourceMaps === \"inline\") {\n        // Babel has this weird behavior where if you set \"inline\", we\n        // inline the sourcemap, and set 'result.map = null'. This results\n        // in bad behavior from Babel since the maps get put into the code,\n        // which Webpack does not expect, and because the map we return to\n        // Webpack is null, which is also bad. To avoid that, we override the\n        // behavior here so \"inline\" just behaves like 'true'.\n        options.sourceMaps = true;\n      }\n\n      const {\n        cacheDirectory = null,\n        cacheIdentifier = JSON.stringify({\n          options,\n          \"@babel/core\": transform.version,\n          \"@babel/loader\": version\n        }),\n        cacheCompression = true,\n        metadataSubscribers = []\n      } = loaderOptions;\n      let result;\n\n      if (cacheDirectory) {\n        result = yield cache({\n          source,\n          options,\n          transform,\n          cacheDirectory,\n          cacheIdentifier,\n          cacheCompression\n        });\n      } else {\n        result = yield transform(source, options);\n      } // Availabe since Babel 7.12\n      // https://github.com/babel/babel/pull/11907\n\n\n      if (config.files) {\n        config.files.forEach(configFile => this.addDependency(configFile));\n      } else {\n        // .babelrc.json\n        if (typeof config.babelrc === \"string\") {\n          this.addDependency(config.babelrc);\n        } // babel.config.js\n\n\n        if (config.config) {\n          this.addDependency(config.config);\n        }\n      }\n\n      if (result) {\n        if (overrides && overrides.result) {\n          result = yield overrides.result.call(this, result, {\n            source,\n            map: inputSourceMap,\n            customOptions,\n            config,\n            options\n          });\n        }\n\n        const {\n          code,\n          map,\n          metadata\n        } = result;\n        metadataSubscribers.forEach(subscriber => {\n          subscribe(subscriber, metadata, this);\n        });\n        return [code, map];\n      }\n    } // If the file was ignored, pass through the original content.\n\n\n    return [source, inputSourceMap];\n  });\n  return _loader.apply(this, arguments);\n}","module.exports = {\n  \"_args\": [\n    [\n      \"babel-loader@8.2.4\",\n      \"C:\\\\Users\\\\87002\\\\Desktop\\\\friendshipclub2022\"\n    ]\n  ],\n  \"_from\": \"babel-loader@8.2.4\",\n  \"_id\": \"babel-loader@8.2.4\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha512-8dytA3gcvPPPv4Grjhnt8b5IIiTcq/zeXOPk4iTYI0SVXcsmuGg7JtBRDp8S9X+gJfhQ8ektjXZlDu1Bb33U8A==\",\n  \"_location\": \"/babel-loader\",\n  \"_phantomChildren\": {\n    \"@types/json-schema\": \"7.0.11\",\n    \"ajv\": \"6.12.6\",\n    \"ajv-keywords\": \"3.5.2\",\n    \"big.js\": \"5.2.2\",\n    \"commondir\": \"1.0.1\",\n    \"emojis-list\": \"3.0.0\",\n    \"p-limit\": \"2.3.0\"\n  },\n  \"_requested\": {\n    \"type\": \"version\",\n    \"registry\": true,\n    \"raw\": \"babel-loader@8.2.4\",\n    \"name\": \"babel-loader\",\n    \"escapedName\": \"babel-loader\",\n    \"rawSpec\": \"8.2.4\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"8.2.4\"\n  },\n  \"_requiredBy\": [\n    \"/@hap-toolkit/packager\",\n    \"/@vue/cli-plugin-babel\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/babel-loader/-/babel-loader-8.2.4.tgz\",\n  \"_spec\": \"8.2.4\",\n  \"_where\": \"C:\\\\Users\\\\87002\\\\Desktop\\\\friendshipclub2022\",\n  \"author\": {\n    \"name\": \"Luis Couto\",\n    \"email\": \"hello@luiscouto.pt\"\n  },\n  \"ava\": {\n    \"files\": [\n      \"test/**/*.test.js\",\n      \"!test/fixtures/**/*\",\n      \"!test/helpers/**/*\"\n    ],\n    \"babel\": {\n      \"compileAsTests\": [\n        \"test/helpers/**/*\"\n      ]\n    }\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/babel/babel-loader/issues\"\n  },\n  \"dependencies\": {\n    \"find-cache-dir\": \"^3.3.1\",\n    \"loader-utils\": \"^2.0.0\",\n    \"make-dir\": \"^3.1.0\",\n    \"schema-utils\": \"^2.6.5\"\n  },\n  \"description\": \"babel module loader for webpack\",\n  \"devDependencies\": {\n    \"@ava/babel\": \"^1.0.1\",\n    \"@babel/cli\": \"^7.12.1\",\n    \"@babel/core\": \"^7.12.3\",\n    \"@babel/preset-env\": \"^7.12.1\",\n    \"ava\": \"^3.13.0\",\n    \"babel-eslint\": \"^10.0.1\",\n    \"babel-plugin-istanbul\": \"^6.0.0\",\n    \"babel-plugin-react-intl\": \"^8.2.15\",\n    \"cross-env\": \"^7.0.2\",\n    \"eslint\": \"^7.13.0\",\n    \"eslint-config-babel\": \"^9.0.0\",\n    \"eslint-config-prettier\": \"^6.3.0\",\n    \"eslint-plugin-flowtype\": \"^5.2.0\",\n    \"eslint-plugin-prettier\": \"^3.0.0\",\n    \"husky\": \"^4.3.0\",\n    \"lint-staged\": \"^10.5.1\",\n    \"nyc\": \"^15.1.0\",\n    \"pnp-webpack-plugin\": \"^1.6.4\",\n    \"prettier\": \"^2.1.2\",\n    \"react\": \"^17.0.1\",\n    \"react-intl\": \"^5.9.4\",\n    \"react-intl-webpack-plugin\": \"^0.3.0\",\n    \"rimraf\": \"^3.0.0\",\n    \"semver\": \"7.3.2\",\n    \"webpack\": \"^5.34.0\"\n  },\n  \"engines\": {\n    \"node\": \">= 8.9\"\n  },\n  \"files\": [\n    \"lib\"\n  ],\n  \"homepage\": \"https://github.com/babel/babel-loader\",\n  \"keywords\": [\n    \"webpack\",\n    \"loader\",\n    \"babel\",\n    \"es6\",\n    \"transpiler\",\n    \"module\"\n  ],\n  \"license\": \"MIT\",\n  \"lint-staged\": {\n    \"scripts/*.js\": [\n      \"prettier --trailing-comma es5 --write\",\n      \"git add\"\n    ],\n    \"src/**/*.js\": [\n      \"prettier --trailing-comma all --write\",\n      \"git add\"\n    ],\n    \"test/**/*.test.js\": [\n      \"prettier --trailing-comma all --write\",\n      \"git add\"\n    ],\n    \"test/helpers/*.js\": [\n      \"prettier --trailing-comma all --write\",\n      \"git add\"\n    ],\n    \"package.json\": [\n      \"node ./scripts/yarn-install.js\",\n      \"git add yarn.lock\"\n    ]\n  },\n  \"main\": \"lib/index.js\",\n  \"name\": \"babel-loader\",\n  \"nyc\": {\n    \"all\": true,\n    \"include\": [\n      \"src/**/*.js\"\n    ],\n    \"reporter\": [\n      \"text\",\n      \"json\"\n    ],\n    \"sourceMap\": false,\n    \"instrument\": false\n  },\n  \"peerDependencies\": {\n    \"@babel/core\": \"^7.0.0\",\n    \"webpack\": \">=2\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/babel/babel-loader.git\"\n  },\n  \"scripts\": {\n    \"build\": \"babel src/ --out-dir lib/ --copy-files\",\n    \"clean\": \"rimraf lib/\",\n    \"format\": \"prettier --write --trailing-comma all 'src/**/*.js' 'test/**/*.test.js' 'test/helpers/*.js' && prettier --write --trailing-comma es5 'scripts/*.js'\",\n    \"lint\": \"eslint src test\",\n    \"precommit\": \"lint-staged\",\n    \"prepublish\": \"yarn run clean && yarn run build\",\n    \"preversion\": \"yarn run test\",\n    \"test\": \"yarn run lint && cross-env BABEL_ENV=test yarn run build && yarn run test-only\",\n    \"test-only\": \"nyc ava\"\n  },\n  \"version\": \"8.2.4\"\n}\n","\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * Filesystem Cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n */\nconst fs = require(\"fs\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst zlib = require(\"zlib\");\n\nconst crypto = require(\"crypto\");\n\nconst findCacheDir = require(\"find-cache-dir\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nconst transform = require(\"./transform\"); // Lazily instantiated when needed\n\n\nlet defaultCacheDirectory = null;\nlet hashType = \"md4\"; // use md5 hashing if md4 is not available\n\ntry {\n  crypto.createHash(hashType);\n} catch (err) {\n  hashType = \"md5\";\n}\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst gunzip = promisify(zlib.gunzip);\nconst gzip = promisify(zlib.gzip);\n\nconst makeDir = require(\"make-dir\");\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n */\n\n\nconst read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (filename, compress) {\n    const data = yield readFile(filename + (compress ? \".gz\" : \"\"));\n    const content = compress ? yield gunzip(data) : data;\n    return JSON.parse(content.toString());\n  });\n\n  return function read(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n * @params {String} result\n */\n\n\nconst write = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (filename, compress, result) {\n    const content = JSON.stringify(result);\n    const data = compress ? yield gzip(content) : content;\n    return yield writeFile(filename + (compress ? \".gz\" : \"\"), data);\n  });\n\n  return function write(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\n\n\nconst filename = function (source, identifier, options) {\n  const hash = crypto.createHash(hashType);\n  const contents = JSON.stringify({\n    source,\n    options,\n    identifier\n  });\n  hash.update(contents);\n  return hash.digest(\"hex\") + \".json\";\n};\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n */\n\n\nconst handleCache = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (directory, params) {\n    const {\n      source,\n      options = {},\n      cacheIdentifier,\n      cacheDirectory,\n      cacheCompression\n    } = params;\n    const file = path.join(directory, filename(source, cacheIdentifier, options));\n\n    try {\n      // No errors mean that the file was previously cached\n      // we just need to return it\n      return yield read(file, cacheCompression);\n    } catch (err) {}\n\n    const fallback = typeof cacheDirectory !== \"string\" && directory !== os.tmpdir(); // Make sure the directory exists.\n\n    try {\n      yield makeDir(directory);\n    } catch (err) {\n      if (fallback) {\n        return handleCache(os.tmpdir(), params);\n      }\n\n      throw err;\n    } // Otherwise just transform the file\n    // return it to the user asap and write it in cache\n\n\n    const result = yield transform(source, options);\n\n    try {\n      yield write(file, cacheCompression, result);\n    } catch (err) {\n      if (fallback) {\n        // Fallback to tmpdir if node_modules folder not writable\n        return handleCache(os.tmpdir(), params);\n      }\n\n      throw err;\n    }\n\n    return result;\n  });\n\n  return function handleCache(_x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.cacheDirectory   Directory to store cached files\n * @param  {String}   params.cacheIdentifier  Unique identifier to bust cache\n * @param  {Boolean}  params.cacheCompression Whether compressing cached files\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n *\n * @example\n *\n *   const result = await cache({\n *     cacheDirectory: '.tmp/cache',\n *     cacheIdentifier: 'babel-loader-cachefile',\n *     cacheCompression: false,\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *   });\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (params) {\n    let directory;\n\n    if (typeof params.cacheDirectory === \"string\") {\n      directory = params.cacheDirectory;\n    } else {\n      if (defaultCacheDirectory === null) {\n        defaultCacheDirectory = findCacheDir({\n          name: \"babel-loader\"\n        }) || os.tmpdir();\n      }\n\n      directory = defaultCacheDirectory;\n    }\n\n    return yield handleCache(directory, params);\n  });\n\n  return function (_x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();","\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nconst babel = require(\"@babel/core\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nconst LoaderError = require(\"./Error\");\n\nconst transform = promisify(babel.transform);\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (source, options) {\n    let result;\n\n    try {\n      result = yield transform(source, options);\n    } catch (err) {\n      throw err.message && err.codeFrame ? new LoaderError(err) : err;\n    }\n\n    if (!result) return null; // We don't return the full result here because some entries are not\n    // really serializable. For a full list of properties see here:\n    // https://github.com/babel/babel/blob/main/packages/babel-core/src/transformation/index.js\n    // For discussion on this topic see here:\n    // https://github.com/babel/babel-loader/pull/629\n\n    const {\n      ast,\n      code,\n      map,\n      metadata,\n      sourceType\n    } = result;\n\n    if (map && (!map.sourcesContent || !map.sourcesContent.length)) {\n      map.sourcesContent = [source];\n    }\n\n    return {\n      ast,\n      code,\n      map,\n      metadata,\n      sourceType\n    };\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports.version = babel.version;","\n\nconst STRIP_FILENAME_RE = /^[^:]+: /;\n\nconst format = err => {\n  if (err instanceof SyntaxError) {\n    err.name = \"SyntaxError\";\n    err.message = err.message.replace(STRIP_FILENAME_RE, \"\");\n    err.hideStack = true;\n  } else if (err instanceof TypeError) {\n    err.name = null;\n    err.message = err.message.replace(STRIP_FILENAME_RE, \"\");\n    err.hideStack = true;\n  }\n\n  return err;\n};\n\nclass LoaderError extends Error {\n  constructor(err) {\n    super();\n    const {\n      name,\n      message,\n      codeFrame,\n      hideStack\n    } = format(err);\n    this.name = \"BabelLoaderError\";\n    this.message = `${name ? `${name}: ` : \"\"}${message}\\n\\n${codeFrame}\\n`;\n    this.hideStack = hideStack;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n}\n\nmodule.exports = LoaderError;","\n\nconst babel = require(\"@babel/core\");\n\nmodule.exports = function injectCaller(opts, target) {\n  if (!supportsCallerOption()) return opts;\n  return Object.assign({}, opts, {\n    caller: Object.assign({\n      name: \"babel-loader\",\n      // Provide plugins with insight into webpack target.\n      // https://github.com/babel/babel-loader/issues/787\n      target,\n      // Webpack >= 2 supports ESM and dynamic import.\n      supportsStaticESM: true,\n      supportsDynamicImport: true,\n      // Webpack 5 supports TLA behind a flag. We enable it by default\n      // for Babel, and then webpack will throw an error if the experimental\n      // flag isn't enabled.\n      supportsTopLevelAwait: true\n    }, opts.caller)\n  });\n}; // TODO: We can remove this eventually, I'm just adding it so that people have\n// a little time to migrate to the newer RCs of @babel/core without getting\n// hard-to-diagnose errors about unknown 'caller' options.\n\n\nlet supportsCallerOptionFlag = undefined;\n\nfunction supportsCallerOption() {\n  if (supportsCallerOptionFlag === undefined) {\n    try {\n      // Rather than try to match the Babel version, we just see if it throws\n      // when passed a 'caller' flag, and use that to decide if it is supported.\n      babel.loadPartialConfig({\n        caller: undefined,\n        babelrc: false,\n        configFile: false\n      });\n      supportsCallerOptionFlag = true;\n    } catch (err) {\n      supportsCallerOptionFlag = false;\n    }\n  }\n\n  return supportsCallerOptionFlag;\n}"]}