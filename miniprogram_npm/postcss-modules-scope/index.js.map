{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst postcss = require('postcss');\nconst selectorParser = require('postcss-selector-parser');\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map(node => {\n    if (node.type !== 'selector' || node.nodes.length !== 1) {\n      throw new Error(\n        `composition is only allowed when selector is single :local class name not in \"${root}\"`\n      );\n    }\n\n    node = node.nodes[0];\n\n    if (\n      node.type !== 'pseudo' ||\n      node.value !== ':local' ||\n      node.nodes.length !== 1\n    ) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== 'selector' || node.length !== 1) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== 'class') {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]';\nconst unescapeRegExp = new RegExp(\n  '\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)',\n  'ig'\n);\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = '0x' + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace\n      ? escaped\n      : high < 0\n        ? // BMP codepoint\n          String.fromCharCode(high + 0x10000)\n        : // Supplemental Plane codepoint (surrogate pair)\n          String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n  });\n}\n\nconst processor = postcss.plugin('postcss-modules-scope', function(options) {\n  return css => {\n    const generateScopedName =\n      (options && options.generateScopedName) || processor.generateScopedName;\n    const generateExportEntry =\n      (options && options.generateExportEntry) || processor.generateExportEntry;\n    const exportGlobals = options && options.exportGlobals;\n\n    const exports = Object.create(null);\n\n    function exportScopedName(name, rawName) {\n      const scopedName = generateScopedName(\n        rawName ? rawName : name,\n        css.source.input.from,\n        css.source.input.css\n      );\n      const exportEntry = generateExportEntry(\n        rawName ? rawName : name,\n        scopedName,\n        css.source.input.from,\n        css.source.input.css\n      );\n      const { key, value } = exportEntry;\n\n      exports[key] = exports[key] || [];\n\n      if (exports[key].indexOf(value) < 0) {\n        exports[key].push(value);\n      }\n\n      return scopedName;\n    }\n\n    function localizeNode(node) {\n      switch (node.type) {\n        case 'selector':\n          node.nodes = node.map(localizeNode);\n          return node;\n        case 'class':\n          return selectorParser.className({\n            value: exportScopedName(\n              node.value,\n              node.raws && node.raws.value ? node.raws.value : null\n            ),\n          });\n        case 'id': {\n          return selectorParser.id({\n            value: exportScopedName(\n              node.value,\n              node.raws && node.raws.value ? node.raws.value : null\n            ),\n          });\n        }\n      }\n\n      throw new Error(\n        `${node.type} (\"${node}\") is not allowed in a :local block`\n      );\n    }\n\n    function traverseNode(node) {\n      switch (node.type) {\n        case 'pseudo':\n          if (node.value === ':local') {\n            if (node.nodes.length !== 1) {\n              throw new Error('Unexpected comma (\",\") in :local block');\n            }\n\n            const selector = localizeNode(node.first, node.spaces);\n            // move the spaces that were around the psuedo selector to the first\n            // non-container node\n            selector.first.spaces = node.spaces;\n\n            const nextNode = node.next();\n\n            if (\n              nextNode &&\n              nextNode.type === 'combinator' &&\n              nextNode.value === ' ' &&\n              /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)\n            ) {\n              selector.last.spaces.after = ' ';\n            }\n\n            node.replaceWith(selector);\n\n            return;\n          }\n        /* falls through */\n        case 'root':\n        case 'selector': {\n          node.each(traverseNode);\n          break;\n        }\n        case 'id':\n        case 'class': \n          if (exportGlobals) {\n            exports[node.value] = [node.value];\n          }\n          break;\n      }\n      return node;\n    }\n\n    // Find any :import and remember imported names\n    const importedNames = {};\n\n    css.walkRules(rule => {\n      if (/^:import\\(.+\\)$/.test(rule.selector)) {\n        rule.walkDecls(decl => {\n          importedNames[decl.prop] = true;\n        });\n      }\n    });\n\n    // Find any :local classes\n    css.walkRules(rule => {\n      if (\n        rule.nodes &&\n        rule.selector.slice(0, 2) === '--' &&\n        rule.selector.slice(-1) === ':'\n      ) {\n        // ignore custom property set\n        return;\n      }\n\n      let parsedSelector = selectorParser().astSync(rule);\n\n      rule.selector = traverseNode(parsedSelector.clone()).toString();\n\n      rule.walkDecls(/composes|compose-with/, decl => {\n        const localNames = getSingleLocalNamesForComposes(parsedSelector);\n        const classes = decl.value.split(/\\s+/);\n\n        classes.forEach(className => {\n          const global = /^global\\(([^\\)]+)\\)$/.exec(className);\n\n          if (global) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(global[1]);\n            });\n          } else if (hasOwnProperty.call(importedNames, className)) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(className);\n            });\n          } else if (hasOwnProperty.call(exports, className)) {\n            localNames.forEach(exportedName => {\n              exports[className].forEach(item => {\n                exports[exportedName].push(item);\n              });\n            });\n          } else {\n            throw decl.error(\n              `referenced class name \"${className}\" in ${decl.prop} not found`\n            );\n          }\n        });\n\n        decl.remove();\n      });\n\n      rule.walkDecls(decl => {\n        let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n\n        tokens = tokens.map((token, idx) => {\n          if (idx === 0 || tokens[idx - 1] === ',') {\n            const localMatch = /^(\\s*):local\\s*\\((.+?)\\)/.exec(token);\n\n            if (localMatch) {\n              return (\n                localMatch[1] +\n                exportScopedName(localMatch[2]) +\n                token.substr(localMatch[0].length)\n              );\n            } else {\n              return token;\n            }\n          } else {\n            return token;\n          }\n        });\n\n        decl.value = tokens.join('');\n      });\n    });\n\n    // Find any :local keyframes\n    css.walkAtRules(atrule => {\n      if (/keyframes$/i.test(atrule.name)) {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atrule.params);\n\n        if (localMatch) {\n          atrule.params = exportScopedName(localMatch[1]);\n        }\n      }\n    });\n\n    // If we found any :locals, insert an :export rule\n    const exportedNames = Object.keys(exports);\n\n    if (exportedNames.length > 0) {\n      const exportRule = postcss.rule({ selector: ':export' });\n\n      exportedNames.forEach(exportedName =>\n        exportRule.append({\n          prop: exportedName,\n          value: exports[exportedName].join(' '),\n          raws: { before: '\\n  ' },\n        })\n      );\n\n      css.append(exportRule);\n    }\n  };\n});\n\nprocessor.generateScopedName = function(name, path) {\n  const sanitisedPath = path\n    .replace(/\\.[^\\.\\/\\\\]+$/, '')\n    .replace(/[\\W_]+/g, '_')\n    .replace(/^_|_$/g, '');\n\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nprocessor.generateExportEntry = function(name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName),\n  };\n};\n\nmodule.exports = processor;\n"]}