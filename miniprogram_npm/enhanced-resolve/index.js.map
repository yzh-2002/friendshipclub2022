{"version":3,"sources":["node.js","ResolverFactory.js","Resolver.js","createInnerContext.js","SyncAsyncFileSystemDecorator.js","ParsePlugin.js","DescriptionFilePlugin.js","DescriptionFileUtils.js","forEachBail.js","NextPlugin.js","TryNextPlugin.js","ModuleKindPlugin.js","FileKindPlugin.js","JoinRequestPlugin.js","ModulesInHierachicDirectoriesPlugin.js","getPaths.js","ModulesInRootPlugin.js","AliasPlugin.js","AliasFieldPlugin.js","getInnerRequest.js","ConcordExtensionsPlugin.js","concord.js","globToRegExp.js","ConcordMainPlugin.js","ConcordModulesPlugin.js","DirectoryExistsPlugin.js","FileExistsPlugin.js","SymlinkPlugin.js","MainFieldPlugin.js","UseFilePlugin.js","AppendPlugin.js","RootPlugin.js","RestrictionsPlugin.js","ResultPlugin.js","ModuleAppendPlugin.js","UnsafeCachePlugin.js","NodeJsInputFileSystem.js","CachedInputFileSystem.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AKdA,AHSA,ADGA,AGTA,ADGA,AHSA;AKdA,AHSA,ADGA,AGTA,ADGA,AHSA;AKdA,AHSA,ADGA,AGTA,ADGA,AHSA;AMjBA,ADGA,AHSA,ADGA,AGTA,ADGA,AHSA;AMjBA,ADGA,AHSA,ADGA,AGTA,ADGA,AHSA;AMjBA,ADGA,AHSA,ADGA,AGTA,ADGA,AHSA;AMjBA,ACHA,AFMA,AHSA,ADGA,AGTA,ADGA,AHSA;AMjBA,ACHA,AFMA,AHSA,ADGA,AGTA,ADGA,AHSA;AMjBA,ACHA,AFMA,AHSA,ADGA,AGTA,ADGA,AHSA;AMjBA,ACHA,AFMA,AHSA,ADGA,AGTA,ADGA,AKfA,ARwBA;AMjBA,ACHA,AFMA,AHSA,ADGA,AGTA,ADGA,AKfA,ARwBA;AMjBA,ACHA,AFMA,AHSA,ADGA,AGTA,ADGA,AKfA,ARwBA;AMjBA,ACHA,AENA,AJYA,AHSA,ADGA,AGTA,ADGA,AKfA,ARwBA;AMjBA,ACHA,AENA,AJYA,AHSA,ADGA,AGTA,ADGA,AKfA,ARwBA;AMjBA,ACHA,AENA,AJYA,AHSA,ADGA,AGTA,ADGA,AKfA,ARwBA;AMjBA,ACHA,AENA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AENA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AENA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AIZA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AIZA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AIZA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AKfA,ADGA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AKfA,ADGA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AKfA,ADGA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AKfA,ACHA,AFMA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,APqBA,AKfA,ARwBA;AMjBA,ACHA,AKfA,ACHA,AFMA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,AFMA,ARwBA;AMjBA,ACHA,AKfA,ACHA,AFMA,AFMA,AJYA,AHSA,ADGA,AGTA,AMlBA,AFMA,ARwBA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,ALeA,AJYA,AHSA,ADGA,AGTA,AMlBA,AFMA,ARwBA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,ALeA,AJYA,AHSA,ADGA,AGTA,AMlBA,AFMA,ARwBA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,ALeA,AJYA,AHSA,ADGA,AGTA,AMlBA,AFMA,ARwBA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,ALeA,AJYA,AHSA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,ALeA,AJYA,AHSA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,ALeA,APqBA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,APqBA,APqBA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AMjBA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AiBlDA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AiBlDA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AiBlDA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AkBrDA,ADGA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AkBrDA,ADGA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AkBrDA,ADGA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AOrBA,Af6CA;AkBrDA,ADGA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AMlBA,AFMA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AXiCA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AIZA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AKfA,ACHA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AIZA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AMlBA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AIZA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AMlBA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AIZA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AMlBA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AMlBA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AMlBA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,Af6CA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AMlBA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AMlBA,AFMA,AGTA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,Ad0CA,ACHA,AIZA,AGTA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,AjBmDA,ACHA,AIZA,AGTA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,AjBmDA,ACHA,AOrBA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,AjBmDA,ACHA,AOrBA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AOrBA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AOrBA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AOrBA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,AXiCA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,AXiCA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,AXiCA,AENA,Ad0CA,ADGA,AGTA,AiBnDA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AZoCA,AENA,Ad0CA,ADGA,AoB5DA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AZoCA,AENA,Ad0CA,ADGA,AoB5DA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AZoCA,AENA,Ad0CA,ADGA,AoB5DA,AbuCA,AWjCA,AJYA,AOrBA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AZoCA,AZoCA,ADGA,A0B9EA,ANkBA,AbuCA,AWjCA,AGTA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AZoCA,AZoCA,ADGA,A0B9EA,ANkBA,AbuCA,AWjCA,AGTA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AZoCA,AZoCA,ADGA,A0B9EA,ANkBA,AbuCA,AWjCA,AGTA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,ANkBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,ANkBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,ANkBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,AENA,ARwBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,AENA,ARwBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AGTA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,AENA,ARwBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,AENA,ARwBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,AENA,ARwBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A0B9EA,AENA,ARwBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A8B1FA,AJYA,AENA,ARwBA,AbuCA,Ac1CA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AlBsDA,ACHA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A8B1FA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A8B1FA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A+B7FA,ADGA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A+B7FA,ADGA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A+B7FA,ADGA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,Ad0CA,AZoCA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,ApB4DA,AZoCA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,ApB4DA,AZoCA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,ApB4DA,AZoCA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AENA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,ApB4DA,AZoCA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,ApB4DA,AZoCA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AhCgGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AV8BA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AGTA,ACHA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AkBtDA,ACHA,AENA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AkBtDA,AGTA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AkBtDA,AGTA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AjBmDA,AIZA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,ANkBA,ARwBA,ACHA,AtBkEA;AkBrDA,ADGA,AavCA,AOrBA,AbuCA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AkBrDA,ADGA,AoB5DA,AbuCA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AkBrDA,ADGA,AoB5DA,AbuCA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ACHA,AFMA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AkBrDA,ADGA,AoB5DA,AbuCA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AkBrDA,ADGA,AoB5DA,AbuCA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AkBrDA,ADGA,AoB5DA,AbuCA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AjBmDA,AqB/DA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AbuCA,AIZA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AJYA,AQxBA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AMlBA,AENA,AlCsGA,ADGA,A+B7FA,ADGA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AQxBA,AlCsGA,ADGA,A+B7FA,ADGA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AQxBA,AlCsGA,ADGA,A+B7FA,ADGA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AQxBA,AlCsGA,ADGA,A+B7FA,ADGA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,AT2BA,AQxBA,AlCsGA,ADGA,A+B7FA,ADGA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,ADGA,AlCsGA,ADGA,A+B7FA,ADGA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,ADGA,AlCsGA,ADGA,A+B7FA,ADGA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,ADGA,AlCsGA,ADGA,A8B1FA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,ADGA,AlCsGA,ADGA,A8B1FA,AIZA,Ad0CA,ACHA,AtBkEA;AqC9GA,ADGA,AlCsGA,ADGA,A8B1FA,AV8BA,ACHA,AtBkEA;AqC9GA,ADGA,AlCsGA,ADGA,A8B1FA,AV8BA,ACHA,AtBkEA;AqC9GA,ADGA,AlCsGA,ADGA,A8B1FA,AV8BA,ACHA,AtBkEA;AqC9GA,ADGA,AlCsGA,ADGA,A8B1FA,AV8BA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,A8B1FA,AV8BA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,A8B1FA,AV8BA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,A8B1FA,AV8BA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA,AtBkEA;AqC9GA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA,ACHA;Ae5CA,AnCyGA,ADGA,AoB5DA;AgB/CA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,AnCyGA,ADGA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA,ApC4GA;AoC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst ResolverFactory = require(\"./ResolverFactory\");\n\nconst NodeJsInputFileSystem = require(\"./NodeJsInputFileSystem\");\nconst CachedInputFileSystem = require(\"./CachedInputFileSystem\");\n\nconst nodeFileSystem = new CachedInputFileSystem(\n\tnew NodeJsInputFileSystem(),\n\t4000\n);\n\nconst nodeContext = {\n\tenvironments: [\"node+es3+es5+process+native\"]\n};\n\nconst asyncResolver = ResolverFactory.createResolver({\n\textensions: [\".js\", \".json\", \".node\"],\n\tfileSystem: nodeFileSystem\n});\nmodule.exports = function resolve(\n\tcontext,\n\tpath,\n\trequest,\n\tresolveContext,\n\tcallback\n) {\n\tif (typeof context === \"string\") {\n\t\tcallback = resolveContext;\n\t\tresolveContext = request;\n\t\trequest = path;\n\t\tpath = context;\n\t\tcontext = nodeContext;\n\t}\n\tif (typeof callback !== \"function\") {\n\t\tcallback = resolveContext;\n\t}\n\tasyncResolver.resolve(context, path, request, resolveContext, callback);\n};\n\nconst syncResolver = ResolverFactory.createResolver({\n\textensions: [\".js\", \".json\", \".node\"],\n\tuseSyncFileSystemCalls: true,\n\tfileSystem: nodeFileSystem\n});\nmodule.exports.sync = function resolveSync(context, path, request) {\n\tif (typeof context === \"string\") {\n\t\trequest = path;\n\t\tpath = context;\n\t\tcontext = nodeContext;\n\t}\n\treturn syncResolver.resolveSync(context, path, request);\n};\n\nconst asyncContextResolver = ResolverFactory.createResolver({\n\textensions: [\".js\", \".json\", \".node\"],\n\tresolveToContext: true,\n\tfileSystem: nodeFileSystem\n});\nmodule.exports.context = function resolveContext(\n\tcontext,\n\tpath,\n\trequest,\n\tresolveContext,\n\tcallback\n) {\n\tif (typeof context === \"string\") {\n\t\tcallback = resolveContext;\n\t\tresolveContext = request;\n\t\trequest = path;\n\t\tpath = context;\n\t\tcontext = nodeContext;\n\t}\n\tif (typeof callback !== \"function\") {\n\t\tcallback = resolveContext;\n\t}\n\tasyncContextResolver.resolve(\n\t\tcontext,\n\t\tpath,\n\t\trequest,\n\t\tresolveContext,\n\t\tcallback\n\t);\n};\n\nconst syncContextResolver = ResolverFactory.createResolver({\n\textensions: [\".js\", \".json\", \".node\"],\n\tresolveToContext: true,\n\tuseSyncFileSystemCalls: true,\n\tfileSystem: nodeFileSystem\n});\nmodule.exports.context.sync = function resolveContextSync(\n\tcontext,\n\tpath,\n\trequest\n) {\n\tif (typeof context === \"string\") {\n\t\trequest = path;\n\t\tpath = context;\n\t\tcontext = nodeContext;\n\t}\n\treturn syncContextResolver.resolveSync(context, path, request);\n};\n\nconst asyncLoaderResolver = ResolverFactory.createResolver({\n\textensions: [\".js\", \".json\", \".node\"],\n\tmoduleExtensions: [\"-loader\"],\n\tmainFields: [\"loader\", \"main\"],\n\tfileSystem: nodeFileSystem\n});\nmodule.exports.loader = function resolveLoader(\n\tcontext,\n\tpath,\n\trequest,\n\tresolveContext,\n\tcallback\n) {\n\tif (typeof context === \"string\") {\n\t\tcallback = resolveContext;\n\t\tresolveContext = request;\n\t\trequest = path;\n\t\tpath = context;\n\t\tcontext = nodeContext;\n\t}\n\tif (typeof callback !== \"function\") {\n\t\tcallback = resolveContext;\n\t}\n\tasyncLoaderResolver.resolve(context, path, request, resolveContext, callback);\n};\n\nconst syncLoaderResolver = ResolverFactory.createResolver({\n\textensions: [\".js\", \".json\", \".node\"],\n\tmoduleExtensions: [\"-loader\"],\n\tmainFields: [\"loader\", \"main\"],\n\tuseSyncFileSystemCalls: true,\n\tfileSystem: nodeFileSystem\n});\nmodule.exports.loader.sync = function resolveLoaderSync(\n\tcontext,\n\tpath,\n\trequest\n) {\n\tif (typeof context === \"string\") {\n\t\trequest = path;\n\t\tpath = context;\n\t\tcontext = nodeContext;\n\t}\n\treturn syncLoaderResolver.resolveSync(context, path, request);\n};\n\nmodule.exports.create = function create(options) {\n\toptions = Object.assign(\n\t\t{\n\t\t\tfileSystem: nodeFileSystem\n\t\t},\n\t\toptions\n\t);\n\tconst resolver = ResolverFactory.createResolver(options);\n\treturn function(context, path, request, resolveContext, callback) {\n\t\tif (typeof context === \"string\") {\n\t\t\tcallback = resolveContext;\n\t\t\tresolveContext = request;\n\t\t\trequest = path;\n\t\t\tpath = context;\n\t\t\tcontext = nodeContext;\n\t\t}\n\t\tif (typeof callback !== \"function\") {\n\t\t\tcallback = resolveContext;\n\t\t}\n\t\tresolver.resolve(context, path, request, resolveContext, callback);\n\t};\n};\n\nmodule.exports.create.sync = function createSync(options) {\n\toptions = Object.assign(\n\t\t{\n\t\t\tuseSyncFileSystemCalls: true,\n\t\t\tfileSystem: nodeFileSystem\n\t\t},\n\t\toptions\n\t);\n\tconst resolver = ResolverFactory.createResolver(options);\n\treturn function(context, path, request) {\n\t\tif (typeof context === \"string\") {\n\t\t\trequest = path;\n\t\t\tpath = context;\n\t\t\tcontext = nodeContext;\n\t\t}\n\t\treturn resolver.resolveSync(context, path, request);\n\t};\n};\n\n// Export Resolver, FileSystems and Plugins\nmodule.exports.ResolverFactory = ResolverFactory;\n\nmodule.exports.NodeJsInputFileSystem = NodeJsInputFileSystem;\nmodule.exports.CachedInputFileSystem = CachedInputFileSystem;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Resolver = require(\"./Resolver\");\n\nconst SyncAsyncFileSystemDecorator = require(\"./SyncAsyncFileSystemDecorator\");\n\nconst ParsePlugin = require(\"./ParsePlugin\");\nconst DescriptionFilePlugin = require(\"./DescriptionFilePlugin\");\nconst NextPlugin = require(\"./NextPlugin\");\nconst TryNextPlugin = require(\"./TryNextPlugin\");\nconst ModuleKindPlugin = require(\"./ModuleKindPlugin\");\nconst FileKindPlugin = require(\"./FileKindPlugin\");\nconst JoinRequestPlugin = require(\"./JoinRequestPlugin\");\nconst ModulesInHierachicDirectoriesPlugin = require(\"./ModulesInHierachicDirectoriesPlugin\");\nconst ModulesInRootPlugin = require(\"./ModulesInRootPlugin\");\nconst AliasPlugin = require(\"./AliasPlugin\");\nconst AliasFieldPlugin = require(\"./AliasFieldPlugin\");\nconst ConcordExtensionsPlugin = require(\"./ConcordExtensionsPlugin\");\nconst ConcordMainPlugin = require(\"./ConcordMainPlugin\");\nconst ConcordModulesPlugin = require(\"./ConcordModulesPlugin\");\nconst DirectoryExistsPlugin = require(\"./DirectoryExistsPlugin\");\nconst FileExistsPlugin = require(\"./FileExistsPlugin\");\nconst SymlinkPlugin = require(\"./SymlinkPlugin\");\nconst MainFieldPlugin = require(\"./MainFieldPlugin\");\nconst UseFilePlugin = require(\"./UseFilePlugin\");\nconst AppendPlugin = require(\"./AppendPlugin\");\nconst RootPlugin = require(\"./RootPlugin\");\nconst RestrictionsPlugin = require(\"./RestrictionsPlugin\");\nconst ResultPlugin = require(\"./ResultPlugin\");\nconst ModuleAppendPlugin = require(\"./ModuleAppendPlugin\");\nconst UnsafeCachePlugin = require(\"./UnsafeCachePlugin\");\n\nexports.createResolver = function(options) {\n\t//// OPTIONS ////\n\n\t// A list of directories to resolve modules from, can be absolute path or folder name\n\tlet modules = options.modules || [\"node_modules\"];\n\n\t// A list of description files to read from\n\tconst descriptionFiles = options.descriptionFiles || [\"package.json\"];\n\n\t// A list of additional resolve plugins which should be applied\n\t// The slice is there to create a copy, because otherwise pushing into plugins\n\t// changes the original options.plugins array, causing duplicate plugins\n\tconst plugins = (options.plugins && options.plugins.slice()) || [];\n\n\t// A list of main fields in description files\n\tlet mainFields = options.mainFields || [\"main\"];\n\n\t// A list of alias fields in description files\n\tconst aliasFields = options.aliasFields || [];\n\n\t// A list of main files in directories\n\tconst mainFiles = options.mainFiles || [\"index\"];\n\n\t// A list of extensions which should be tried for files\n\tlet extensions = options.extensions || [\".js\", \".json\", \".node\"];\n\n\t// Enforce that a extension from extensions must be used\n\tconst enforceExtension = options.enforceExtension || false;\n\n\t// A list of module extensions which should be tried for modules\n\tlet moduleExtensions = options.moduleExtensions || [];\n\n\t// Enforce that a extension from moduleExtensions must be used\n\tconst enforceModuleExtension = options.enforceModuleExtension || false;\n\n\t// A list of module alias configurations or an object which maps key to value\n\tlet alias = options.alias || [];\n\n\t// Resolve symlinks to their symlinked location\n\tconst symlinks =\n\t\ttypeof options.symlinks !== \"undefined\" ? options.symlinks : true;\n\n\t// Resolve to a context instead of a file\n\tconst resolveToContext = options.resolveToContext || false;\n\n\t// A list of root paths\n\tconst roots = options.roots || [];\n\n\t// Ignore errors happening when resolving roots\n\tconst ignoreRootsErrors = options.ignoreRootsErrors || false;\n\n\t// Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots\n\tconst preferAbsolute = options.preferAbsolute || false;\n\n\tconst restrictions = options.restrictions || [];\n\n\t// Use this cache object to unsafely cache the successful requests\n\tlet unsafeCache = options.unsafeCache || false;\n\n\t// Whether or not the unsafeCache should include request context as part of the cache key.\n\tconst cacheWithContext =\n\t\ttypeof options.cacheWithContext !== \"undefined\"\n\t\t\t? options.cacheWithContext\n\t\t\t: true;\n\n\t// Enable concord description file instructions\n\tconst enableConcord = options.concord || false;\n\n\t// A function which decides whether a request should be cached or not.\n\t// an object is passed with `path` and `request` properties.\n\tconst cachePredicate =\n\t\toptions.cachePredicate ||\n\t\tfunction() {\n\t\t\treturn true;\n\t\t};\n\n\t// The file system which should be used\n\tconst fileSystem = options.fileSystem;\n\n\t// Use only the sync constiants of the file system calls\n\tconst useSyncFileSystemCalls = options.useSyncFileSystemCalls;\n\n\t// A prepared Resolver to which the plugins are attached\n\tlet resolver = options.resolver;\n\n\t//// options processing ////\n\n\tif (!resolver) {\n\t\tresolver = new Resolver(\n\t\t\tuseSyncFileSystemCalls\n\t\t\t\t? new SyncAsyncFileSystemDecorator(fileSystem)\n\t\t\t\t: fileSystem\n\t\t);\n\t}\n\n\textensions = [].concat(extensions);\n\tmoduleExtensions = [].concat(moduleExtensions);\n\n\tmodules = mergeFilteredToArray([].concat(modules), item => {\n\t\treturn !isAbsolutePath(item);\n\t});\n\n\tmainFields = mainFields.map(item => {\n\t\tif (typeof item === \"string\" || Array.isArray(item)) {\n\t\t\titem = {\n\t\t\t\tname: item,\n\t\t\t\tforceRelative: true\n\t\t\t};\n\t\t}\n\t\treturn item;\n\t});\n\n\tif (typeof alias === \"object\" && !Array.isArray(alias)) {\n\t\talias = Object.keys(alias).map(key => {\n\t\t\tlet onlyModule = false;\n\t\t\tlet obj = alias[key];\n\t\t\tif (/\\$$/.test(key)) {\n\t\t\t\tonlyModule = true;\n\t\t\t\tkey = key.substr(0, key.length - 1);\n\t\t\t}\n\t\t\tif (typeof obj === \"string\") {\n\t\t\t\tobj = {\n\t\t\t\t\talias: obj\n\t\t\t\t};\n\t\t\t}\n\t\t\tobj = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tname: key,\n\t\t\t\t\tonlyModule: onlyModule\n\t\t\t\t},\n\t\t\t\tobj\n\t\t\t);\n\t\t\treturn obj;\n\t\t});\n\t}\n\n\tif (unsafeCache && typeof unsafeCache !== \"object\") {\n\t\tunsafeCache = {};\n\t}\n\n\t//// pipeline ////\n\n\tresolver.ensureHook(\"resolve\");\n\tresolver.ensureHook(\"parsedResolve\");\n\tresolver.ensureHook(\"describedResolve\");\n\tresolver.ensureHook(\"rawModule\");\n\tresolver.ensureHook(\"module\");\n\tresolver.ensureHook(\"relative\");\n\tresolver.ensureHook(\"describedRelative\");\n\tresolver.ensureHook(\"directory\");\n\tresolver.ensureHook(\"existingDirectory\");\n\tresolver.ensureHook(\"undescribedRawFile\");\n\tresolver.ensureHook(\"rawFile\");\n\tresolver.ensureHook(\"file\");\n\tresolver.ensureHook(\"existingFile\");\n\tresolver.ensureHook(\"resolved\");\n\n\t// resolve\n\tif (unsafeCache) {\n\t\tplugins.push(\n\t\t\tnew UnsafeCachePlugin(\n\t\t\t\t\"resolve\",\n\t\t\t\tcachePredicate,\n\t\t\t\tunsafeCache,\n\t\t\t\tcacheWithContext,\n\t\t\t\t\"new-resolve\"\n\t\t\t)\n\t\t);\n\t\tplugins.push(new ParsePlugin(\"new-resolve\", \"parsed-resolve\"));\n\t} else {\n\t\tplugins.push(new ParsePlugin(\"resolve\", \"parsed-resolve\"));\n\t}\n\n\t// parsed-resolve\n\tplugins.push(\n\t\tnew DescriptionFilePlugin(\n\t\t\t\"parsed-resolve\",\n\t\t\tdescriptionFiles,\n\t\t\t\"described-resolve\"\n\t\t)\n\t);\n\tplugins.push(new NextPlugin(\"after-parsed-resolve\", \"described-resolve\"));\n\n\t// described-resolve\n\tif (alias.length > 0)\n\t\tplugins.push(new AliasPlugin(\"described-resolve\", alias, \"resolve\"));\n\tif (enableConcord) {\n\t\tplugins.push(new ConcordModulesPlugin(\"described-resolve\", {}, \"resolve\"));\n\t}\n\taliasFields.forEach(item => {\n\t\tplugins.push(new AliasFieldPlugin(\"described-resolve\", item, \"resolve\"));\n\t});\n\tplugins.push(new ModuleKindPlugin(\"after-described-resolve\", \"raw-module\"));\n\tif (preferAbsolute) {\n\t\tplugins.push(new JoinRequestPlugin(\"after-described-resolve\", \"relative\"));\n\t}\n\troots.forEach(root => {\n\t\tplugins.push(\n\t\t\tnew RootPlugin(\n\t\t\t\t\"after-described-resolve\",\n\t\t\t\troot,\n\t\t\t\t\"relative\",\n\t\t\t\tignoreRootsErrors\n\t\t\t)\n\t\t);\n\t});\n\tif (!preferAbsolute) {\n\t\tplugins.push(new JoinRequestPlugin(\"after-described-resolve\", \"relative\"));\n\t}\n\n\t// raw-module\n\tmoduleExtensions.forEach(item => {\n\t\tplugins.push(new ModuleAppendPlugin(\"raw-module\", item, \"module\"));\n\t});\n\tif (!enforceModuleExtension)\n\t\tplugins.push(new TryNextPlugin(\"raw-module\", null, \"module\"));\n\n\t// module\n\tmodules.forEach(item => {\n\t\tif (Array.isArray(item))\n\t\t\tplugins.push(\n\t\t\t\tnew ModulesInHierachicDirectoriesPlugin(\"module\", item, \"resolve\")\n\t\t\t);\n\t\telse plugins.push(new ModulesInRootPlugin(\"module\", item, \"resolve\"));\n\t});\n\n\t// relative\n\tplugins.push(\n\t\tnew DescriptionFilePlugin(\n\t\t\t\"relative\",\n\t\t\tdescriptionFiles,\n\t\t\t\"described-relative\"\n\t\t)\n\t);\n\tplugins.push(new NextPlugin(\"after-relative\", \"described-relative\"));\n\n\t// described-relative\n\tplugins.push(new FileKindPlugin(\"described-relative\", \"raw-file\"));\n\tplugins.push(\n\t\tnew TryNextPlugin(\"described-relative\", \"as directory\", \"directory\")\n\t);\n\n\t// directory\n\tplugins.push(new DirectoryExistsPlugin(\"directory\", \"existing-directory\"));\n\n\tif (resolveToContext) {\n\t\t// existing-directory\n\t\tplugins.push(new NextPlugin(\"existing-directory\", \"resolved\"));\n\t} else {\n\t\t// existing-directory\n\t\tif (enableConcord) {\n\t\t\tplugins.push(new ConcordMainPlugin(\"existing-directory\", {}, \"resolve\"));\n\t\t}\n\t\tmainFields.forEach(item => {\n\t\t\tplugins.push(new MainFieldPlugin(\"existing-directory\", item, \"resolve\"));\n\t\t});\n\t\tmainFiles.forEach(item => {\n\t\t\tplugins.push(\n\t\t\t\tnew UseFilePlugin(\"existing-directory\", item, \"undescribed-raw-file\")\n\t\t\t);\n\t\t});\n\n\t\t// undescribed-raw-file\n\t\tplugins.push(\n\t\t\tnew DescriptionFilePlugin(\n\t\t\t\t\"undescribed-raw-file\",\n\t\t\t\tdescriptionFiles,\n\t\t\t\t\"raw-file\"\n\t\t\t)\n\t\t);\n\t\tplugins.push(new NextPlugin(\"after-undescribed-raw-file\", \"raw-file\"));\n\n\t\t// raw-file\n\t\tif (!enforceExtension) {\n\t\t\tplugins.push(new TryNextPlugin(\"raw-file\", \"no extension\", \"file\"));\n\t\t}\n\t\tif (enableConcord) {\n\t\t\tplugins.push(new ConcordExtensionsPlugin(\"raw-file\", {}, \"file\"));\n\t\t}\n\t\textensions.forEach(item => {\n\t\t\tplugins.push(new AppendPlugin(\"raw-file\", item, \"file\"));\n\t\t});\n\n\t\t// file\n\t\tif (alias.length > 0)\n\t\t\tplugins.push(new AliasPlugin(\"file\", alias, \"resolve\"));\n\t\tif (enableConcord) {\n\t\t\tplugins.push(new ConcordModulesPlugin(\"file\", {}, \"resolve\"));\n\t\t}\n\t\taliasFields.forEach(item => {\n\t\t\tplugins.push(new AliasFieldPlugin(\"file\", item, \"resolve\"));\n\t\t});\n\t\tif (symlinks) plugins.push(new SymlinkPlugin(\"file\", \"relative\"));\n\t\tplugins.push(new FileExistsPlugin(\"file\", \"existing-file\"));\n\n\t\t// existing-file\n\t\tplugins.push(new NextPlugin(\"existing-file\", \"resolved\"));\n\t}\n\n\t// resolved\n\tif (restrictions.length > 0) {\n\t\tplugins.push(new RestrictionsPlugin(resolver.hooks.resolved, restrictions));\n\t}\n\tplugins.push(new ResultPlugin(resolver.hooks.resolved));\n\n\t//// RESOLVER ////\n\n\tplugins.forEach(plugin => {\n\t\tplugin.apply(resolver);\n\t});\n\n\treturn resolver;\n};\n\nfunction mergeFilteredToArray(array, filter) {\n\treturn array.reduce((array, item) => {\n\t\tif (filter(item)) {\n\t\t\tconst lastElement = array[array.length - 1];\n\t\t\tif (Array.isArray(lastElement)) {\n\t\t\t\tlastElement.push(item);\n\t\t\t} else {\n\t\t\t\tarray.push([item]);\n\t\t\t}\n\t\t\treturn array;\n\t\t} else {\n\t\t\tarray.push(item);\n\t\t\treturn array;\n\t\t}\n\t}, []);\n}\n\nfunction isAbsolutePath(path) {\n\treturn /^[A-Z]:|^\\//.test(path);\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst util = require(\"util\");\n\nconst Tapable = require(\"tapable/lib/Tapable\");\nconst SyncHook = require(\"tapable/lib/SyncHook\");\nconst AsyncSeriesBailHook = require(\"tapable/lib/AsyncSeriesBailHook\");\nconst AsyncSeriesHook = require(\"tapable/lib/AsyncSeriesHook\");\nconst createInnerContext = require(\"./createInnerContext\");\n\nconst REGEXP_NOT_MODULE = /^\\.$|^\\.[\\\\/]|^\\.\\.$|^\\.\\.[\\\\/]|^\\/|^[A-Z]:[\\\\/]/i;\nconst REGEXP_DIRECTORY = /[\\\\/]$/i;\n\nconst memoryFsJoin = require(\"memory-fs/lib/join\");\nconst memoizedJoin = new Map();\nconst memoryFsNormalize = require(\"memory-fs/lib/normalize\");\n\nfunction withName(name, hook) {\n\thook.name = name;\n\treturn hook;\n}\n\nfunction toCamelCase(str) {\n\treturn str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());\n}\n\nconst deprecatedPushToMissing = util.deprecate((set, item) => {\n\tset.add(item);\n}, \"Resolver: 'missing' is now a Set. Use add instead of push.\");\n\nconst deprecatedResolveContextInCallback = util.deprecate(x => {\n\treturn x;\n}, \"Resolver: The callback argument was splitted into resolveContext and callback.\");\n\nconst deprecatedHookAsString = util.deprecate(x => {\n\treturn x;\n}, \"Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.\");\n\nclass Resolver extends Tapable {\n\tconstructor(fileSystem) {\n\t\tsuper();\n\t\tthis.fileSystem = fileSystem;\n\t\tthis.hooks = {\n\t\t\tresolveStep: withName(\"resolveStep\", new SyncHook([\"hook\", \"request\"])),\n\t\t\tnoResolve: withName(\"noResolve\", new SyncHook([\"request\", \"error\"])),\n\t\t\tresolve: withName(\n\t\t\t\t\"resolve\",\n\t\t\t\tnew AsyncSeriesBailHook([\"request\", \"resolveContext\"])\n\t\t\t),\n\t\t\tresult: new AsyncSeriesHook([\"result\", \"resolveContext\"])\n\t\t};\n\t\tthis._pluginCompat.tap(\"Resolver: before/after\", options => {\n\t\t\tif (/^before-/.test(options.name)) {\n\t\t\t\toptions.name = options.name.substr(7);\n\t\t\t\toptions.stage = -10;\n\t\t\t} else if (/^after-/.test(options.name)) {\n\t\t\t\toptions.name = options.name.substr(6);\n\t\t\t\toptions.stage = 10;\n\t\t\t}\n\t\t});\n\t\tthis._pluginCompat.tap(\"Resolver: step hooks\", options => {\n\t\t\tconst name = options.name;\n\t\t\tconst stepHook = !/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name);\n\t\t\tif (stepHook) {\n\t\t\t\toptions.async = true;\n\t\t\t\tthis.ensureHook(name);\n\t\t\t\tconst fn = options.fn;\n\t\t\t\toptions.fn = (request, resolverContext, callback) => {\n\t\t\t\t\tconst innerCallback = (err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tif (result !== undefined) return callback(null, result);\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t};\n\t\t\t\t\tfor (const key in resolverContext) {\n\t\t\t\t\t\tinnerCallback[key] = resolverContext[key];\n\t\t\t\t\t}\n\t\t\t\t\tfn.call(this, request, innerCallback);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n\n\tensureHook(name) {\n\t\tif (typeof name !== \"string\") return name;\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn this.ensureHook(\n\t\t\t\tname[6].toLowerCase() + name.substr(7)\n\t\t\t).withOptions({\n\t\t\t\tstage: -10\n\t\t\t});\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn this.ensureHook(\n\t\t\t\tname[5].toLowerCase() + name.substr(6)\n\t\t\t).withOptions({\n\t\t\t\tstage: 10\n\t\t\t});\n\t\t}\n\t\tconst hook = this.hooks[name];\n\t\tif (!hook) {\n\t\t\treturn (this.hooks[name] = withName(\n\t\t\t\tname,\n\t\t\t\tnew AsyncSeriesBailHook([\"request\", \"resolveContext\"])\n\t\t\t));\n\t\t}\n\t\treturn hook;\n\t}\n\n\tgetHook(name) {\n\t\tif (typeof name !== \"string\") return name;\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n\t\t\t\tstage: -10\n\t\t\t});\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n\t\t\t\tstage: 10\n\t\t\t});\n\t\t}\n\t\tconst hook = this.hooks[name];\n\t\tif (!hook) {\n\t\t\tthrow new Error(`Hook ${name} doesn't exist`);\n\t\t}\n\t\treturn hook;\n\t}\n\n\tresolveSync(context, path, request) {\n\t\tlet err,\n\t\t\tresult,\n\t\t\tsync = false;\n\t\tthis.resolve(context, path, request, {}, (e, r) => {\n\t\t\terr = e;\n\t\t\tresult = r;\n\t\t\tsync = true;\n\t\t});\n\t\tif (!sync)\n\t\t\tthrow new Error(\n\t\t\t\t\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\"\n\t\t\t);\n\t\tif (err) throw err;\n\t\treturn result;\n\t}\n\n\tresolve(context, path, request, resolveContext, callback) {\n\t\t// TODO remove in enhanced-resolve 5\n\t\t// For backward compatiblity START\n\t\tif (typeof callback !== \"function\") {\n\t\t\tcallback = deprecatedResolveContextInCallback(resolveContext);\n\t\t\t// resolveContext is a function containing additional properties\n\t\t\t// It's now used for resolveContext and callback\n\t\t}\n\t\t// END\n\t\tconst obj = {\n\t\t\tcontext: context,\n\t\t\tpath: path,\n\t\t\trequest: request\n\t\t};\n\n\t\tconst message = \"resolve '\" + request + \"' in '\" + path + \"'\";\n\n\t\t// Try to resolve assuming there is no error\n\t\t// We don't log stuff in this case\n\t\treturn this.doResolve(\n\t\t\tthis.hooks.resolve,\n\t\t\tobj,\n\t\t\tmessage,\n\t\t\t{\n\t\t\t\tmissing: resolveContext.missing,\n\t\t\t\tstack: resolveContext.stack\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (!err && result) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tresult.path === false ? false : result.path + (result.query || \"\"),\n\t\t\t\t\t\tresult\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst localMissing = new Set();\n\t\t\t\t// TODO remove in enhanced-resolve 5\n\t\t\t\tlocalMissing.push = item => deprecatedPushToMissing(localMissing, item);\n\t\t\t\tconst log = [];\n\n\t\t\t\treturn this.doResolve(\n\t\t\t\t\tthis.hooks.resolve,\n\t\t\t\t\tobj,\n\t\t\t\t\tmessage,\n\t\t\t\t\t{\n\t\t\t\t\t\tlog: msg => {\n\t\t\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\t\t\tresolveContext.log(msg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlog.push(msg);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmissing: localMissing,\n\t\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tconst error = new Error(\"Can't \" + message);\n\t\t\t\t\t\terror.details = log.join(\"\\n\");\n\t\t\t\t\t\terror.missing = Array.from(localMissing);\n\t\t\t\t\t\tthis.hooks.noResolve.call(obj, error);\n\t\t\t\t\t\treturn callback(error);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\tdoResolve(hook, request, message, resolveContext, callback) {\n\t\t// TODO remove in enhanced-resolve 5\n\t\t// For backward compatiblity START\n\t\tif (typeof callback !== \"function\") {\n\t\t\tcallback = deprecatedResolveContextInCallback(resolveContext);\n\t\t\t// resolveContext is a function containing additional properties\n\t\t\t// It's now used for resolveContext and callback\n\t\t}\n\t\tif (typeof hook === \"string\") {\n\t\t\tconst name = toCamelCase(hook);\n\t\t\thook = deprecatedHookAsString(this.hooks[name]);\n\t\t\tif (!hook) {\n\t\t\t\tthrow new Error(`Hook \"${name}\" doesn't exist`);\n\t\t\t}\n\t\t}\n\t\t// END\n\t\tif (typeof callback !== \"function\")\n\t\t\tthrow new Error(\"callback is not a function \" + Array.from(arguments));\n\t\tif (!resolveContext)\n\t\t\tthrow new Error(\n\t\t\t\t\"resolveContext is not an object \" + Array.from(arguments)\n\t\t\t);\n\n\t\tconst stackLine =\n\t\t\thook.name +\n\t\t\t\": (\" +\n\t\t\trequest.path +\n\t\t\t\") \" +\n\t\t\t(request.request || \"\") +\n\t\t\t(request.query || \"\") +\n\t\t\t(request.directory ? \" directory\" : \"\") +\n\t\t\t(request.module ? \" module\" : \"\");\n\n\t\tlet newStack;\n\t\tif (resolveContext.stack) {\n\t\t\tnewStack = new Set(resolveContext.stack);\n\t\t\tif (resolveContext.stack.has(stackLine)) {\n\t\t\t\t// Prevent recursion\n\t\t\t\tconst recursionError = new Error(\n\t\t\t\t\t\"Recursion in resolving\\nStack:\\n  \" +\n\t\t\t\t\t\tArray.from(newStack).join(\"\\n  \")\n\t\t\t\t);\n\t\t\t\trecursionError.recursion = true;\n\t\t\t\tif (resolveContext.log)\n\t\t\t\t\tresolveContext.log(\"abort resolving because of recursion\");\n\t\t\t\treturn callback(recursionError);\n\t\t\t}\n\t\t\tnewStack.add(stackLine);\n\t\t} else {\n\t\t\tnewStack = new Set([stackLine]);\n\t\t}\n\t\tthis.hooks.resolveStep.call(hook, request);\n\n\t\tif (hook.isUsed()) {\n\t\t\tconst innerContext = createInnerContext(\n\t\t\t\t{\n\t\t\t\t\tlog: resolveContext.log,\n\t\t\t\t\tmissing: resolveContext.missing,\n\t\t\t\t\tstack: newStack\n\t\t\t\t},\n\t\t\t\tmessage\n\t\t\t);\n\t\t\treturn hook.callAsync(request, innerContext, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result) return callback(null, result);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\tparse(identifier) {\n\t\tif (identifier === \"\") return null;\n\t\tconst part = {\n\t\t\trequest: \"\",\n\t\t\tquery: \"\",\n\t\t\tmodule: false,\n\t\t\tdirectory: false,\n\t\t\tfile: false\n\t\t};\n\t\tconst idxQuery = identifier.indexOf(\"?\");\n\t\tif (idxQuery === 0) {\n\t\t\tpart.query = identifier;\n\t\t} else if (idxQuery > 0) {\n\t\t\tpart.request = identifier.slice(0, idxQuery);\n\t\t\tpart.query = identifier.slice(idxQuery);\n\t\t} else {\n\t\t\tpart.request = identifier;\n\t\t}\n\t\tif (part.request) {\n\t\t\tpart.module = this.isModule(part.request);\n\t\t\tpart.directory = this.isDirectory(part.request);\n\t\t\tif (part.directory) {\n\t\t\t\tpart.request = part.request.substr(0, part.request.length - 1);\n\t\t\t}\n\t\t}\n\t\treturn part;\n\t}\n\n\tisModule(path) {\n\t\treturn !REGEXP_NOT_MODULE.test(path);\n\t}\n\n\tisDirectory(path) {\n\t\treturn REGEXP_DIRECTORY.test(path);\n\t}\n\n\tjoin(path, request) {\n\t\tlet cacheEntry;\n\t\tlet pathCache = memoizedJoin.get(path);\n\t\tif (typeof pathCache === \"undefined\") {\n\t\t\tmemoizedJoin.set(path, (pathCache = new Map()));\n\t\t} else {\n\t\t\tcacheEntry = pathCache.get(request);\n\t\t\tif (typeof cacheEntry !== \"undefined\") return cacheEntry;\n\t\t}\n\t\tcacheEntry = memoryFsJoin(path, request);\n\t\tpathCache.set(request, cacheEntry);\n\t\treturn cacheEntry;\n\t}\n\n\tnormalize(path) {\n\t\treturn memoryFsNormalize(path);\n\t}\n}\n\nmodule.exports = Resolver;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = function createInnerContext(\n\toptions,\n\tmessage,\n\tmessageOptional\n) {\n\tlet messageReported = false;\n\tconst childContext = {\n\t\tlog: (() => {\n\t\t\tif (!options.log) return undefined;\n\t\t\tif (!message) return options.log;\n\t\t\tconst logFunction = msg => {\n\t\t\t\tif (!messageReported) {\n\t\t\t\t\toptions.log(message);\n\t\t\t\t\tmessageReported = true;\n\t\t\t\t}\n\t\t\t\toptions.log(\"  \" + msg);\n\t\t\t};\n\t\t\treturn logFunction;\n\t\t})(),\n\t\tstack: options.stack,\n\t\tmissing: options.missing\n\t};\n\treturn childContext;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nfunction SyncAsyncFileSystemDecorator(fs) {\n\tthis.fs = fs;\n\tif (fs.statSync) {\n\t\tthis.stat = function(arg, callback) {\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tresult = fs.statSync(arg);\n\t\t\t} catch (e) {\n\t\t\t\treturn callback(e);\n\t\t\t}\n\t\t\tcallback(null, result);\n\t\t};\n\t}\n\tif (fs.readdirSync) {\n\t\tthis.readdir = function(arg, callback) {\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tresult = fs.readdirSync(arg);\n\t\t\t} catch (e) {\n\t\t\t\treturn callback(e);\n\t\t\t}\n\t\t\tcallback(null, result);\n\t\t};\n\t}\n\tif (fs.readFileSync) {\n\t\tthis.readFile = function(arg, callback) {\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tresult = fs.readFileSync(arg);\n\t\t\t} catch (e) {\n\t\t\t\treturn callback(e);\n\t\t\t}\n\t\t\tcallback(null, result);\n\t\t};\n\t}\n\tif (fs.readlinkSync) {\n\t\tthis.readlink = function(arg, callback) {\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tresult = fs.readlinkSync(arg);\n\t\t\t} catch (e) {\n\t\t\t\treturn callback(e);\n\t\t\t}\n\t\t\tcallback(null, result);\n\t\t};\n\t}\n\tif (fs.readJsonSync) {\n\t\tthis.readJson = function(arg, callback) {\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tresult = fs.readJsonSync(arg);\n\t\t\t} catch (e) {\n\t\t\t\treturn callback(e);\n\t\t\t}\n\t\t\tcallback(null, result);\n\t\t};\n\t}\n}\nmodule.exports = SyncAsyncFileSystemDecorator;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class ParsePlugin {\n\tconstructor(source, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ParsePlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst parsed = resolver.parse(request.request);\n\t\t\t\tconst obj = Object.assign({}, request, parsed);\n\t\t\t\tif (request.query && !parsed.query) {\n\t\t\t\t\tobj.query = request.query;\n\t\t\t\t}\n\t\t\t\tif (parsed && resolveContext.log) {\n\t\t\t\t\tif (parsed.module) resolveContext.log(\"Parsed request is a module\");\n\t\t\t\t\tif (parsed.directory)\n\t\t\t\t\t\tresolveContext.log(\"Parsed request is a directory\");\n\t\t\t\t}\n\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t});\n\t}\n};\n","/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\n\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\n\nmodule.exports = class DescriptionFilePlugin {\n\tconstructor(source, filenames, target) {\n\t\tthis.source = source;\n\t\tthis.filenames = [].concat(filenames);\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\n\t\t\t\t\"DescriptionFilePlugin\",\n\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\tconst directory = request.path;\n\t\t\t\t\tDescriptionFileUtils.loadDescriptionFile(\n\t\t\t\t\t\tresolver,\n\t\t\t\t\t\tdirectory,\n\t\t\t\t\t\tthis.filenames,\n\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\t\tif (resolveContext.missing) {\n\t\t\t\t\t\t\t\t\tthis.filenames.forEach(filename => {\n\t\t\t\t\t\t\t\t\t\tresolveContext.missing.add(\n\t\t\t\t\t\t\t\t\t\t\tresolver.join(directory, filename)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (resolveContext.log)\n\t\t\t\t\t\t\t\t\tresolveContext.log(\"No description file found\");\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst relativePath =\n\t\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\t\trequest.path\n\t\t\t\t\t\t\t\t\t.substr(result.directory.length)\n\t\t\t\t\t\t\t\t\t.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\t\t\t\tdescriptionFilePath: result.path,\n\t\t\t\t\t\t\t\tdescriptionFileData: result.content,\n\t\t\t\t\t\t\t\tdescriptionFileRoot: result.directory,\n\t\t\t\t\t\t\t\trelativePath: relativePath\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\"using description file: \" +\n\t\t\t\t\t\t\t\t\tresult.path +\n\t\t\t\t\t\t\t\t\t\" (relative path: \" +\n\t\t\t\t\t\t\t\t\trelativePath +\n\t\t\t\t\t\t\t\t\t\")\",\n\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\t// Don't allow other processing\n\t\t\t\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst forEachBail = require(\"./forEachBail\");\n\nfunction loadDescriptionFile(\n\tresolver,\n\tdirectory,\n\tfilenames,\n\tresolveContext,\n\tcallback\n) {\n\t(function findDescriptionFile() {\n\t\tforEachBail(\n\t\t\tfilenames,\n\t\t\t(filename, callback) => {\n\t\t\t\tconst descriptionFilePath = resolver.join(directory, filename);\n\t\t\t\tif (resolver.fileSystem.readJson) {\n\t\t\t\t\tresolver.fileSystem.readJson(descriptionFilePath, (err, content) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (typeof err.code !== \"undefined\") return callback();\n\t\t\t\t\t\t\treturn onJson(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonJson(null, content);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolver.fileSystem.readFile(descriptionFilePath, (err, content) => {\n\t\t\t\t\t\tif (err) return callback();\n\t\t\t\t\t\tlet json;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tjson = JSON.parse(content);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tonJson(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonJson(null, json);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction onJson(err, content) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (resolveContext.log)\n\t\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\tdescriptionFilePath + \" (directory description file): \" + err\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\terr.message =\n\t\t\t\t\t\t\t\tdescriptionFilePath + \" (directory description file): \" + err;\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\tcontent: content,\n\t\t\t\t\t\tdirectory: directory,\n\t\t\t\t\t\tpath: descriptionFilePath\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn callback(null, result);\n\t\t\t\t} else {\n\t\t\t\t\tdirectory = cdUp(directory);\n\t\t\t\t\tif (!directory) {\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn findDescriptionFile();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t})();\n}\n\nfunction getField(content, field) {\n\tif (!content) return undefined;\n\tif (Array.isArray(field)) {\n\t\tlet current = content;\n\t\tfor (let j = 0; j < field.length; j++) {\n\t\t\tif (current === null || typeof current !== \"object\") {\n\t\t\t\tcurrent = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent = current[field[j]];\n\t\t}\n\t\tif (typeof current === \"object\") {\n\t\t\treturn current;\n\t\t}\n\t} else {\n\t\tif (typeof content[field] === \"object\") {\n\t\t\treturn content[field];\n\t\t}\n\t}\n}\n\nfunction cdUp(directory) {\n\tif (directory === \"/\") return null;\n\tconst i = directory.lastIndexOf(\"/\"),\n\t\tj = directory.lastIndexOf(\"\\\\\");\n\tconst p = i < 0 ? j : j < 0 ? i : i < j ? j : i;\n\tif (p < 0) return null;\n\treturn directory.substr(0, p || 1);\n}\n\nexports.loadDescriptionFile = loadDescriptionFile;\nexports.getField = getField;\nexports.cdUp = cdUp;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = function forEachBail(array, iterator, callback) {\n\tif (array.length === 0) return callback();\n\tlet currentPos = array.length;\n\tlet currentResult;\n\tlet done = [];\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst itCb = createIteratorCallback(i);\n\t\titerator(array[i], itCb);\n\t\tif (currentPos === 0) break;\n\t}\n\n\tfunction createIteratorCallback(i) {\n\t\treturn (...args) => {\n\t\t\tif (i >= currentPos) return; // ignore\n\t\t\tdone.push(i);\n\t\t\tif (args.length > 0) {\n\t\t\t\tcurrentPos = i + 1;\n\t\t\t\tdone = done.filter(item => {\n\t\t\t\t\treturn item <= i;\n\t\t\t\t});\n\t\t\t\tcurrentResult = args;\n\t\t\t}\n\t\t\tif (done.length === currentPos) {\n\t\t\t\tcallback.apply(null, currentResult);\n\t\t\t\tcurrentPos = 0;\n\t\t\t}\n\t\t};\n\t}\n};\n\nmodule.exports.withIndex = function forEachBailWithIndex(\n\tarray,\n\titerator,\n\tcallback\n) {\n\tif (array.length === 0) return callback();\n\tlet currentPos = array.length;\n\tlet currentResult;\n\tlet done = [];\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst itCb = createIteratorCallback(i);\n\t\titerator(array[i], i, itCb);\n\t\tif (currentPos === 0) break;\n\t}\n\n\tfunction createIteratorCallback(i) {\n\t\treturn (...args) => {\n\t\t\tif (i >= currentPos) return; // ignore\n\t\t\tdone.push(i);\n\t\t\tif (args.length > 0) {\n\t\t\t\tcurrentPos = i + 1;\n\t\t\t\tdone = done.filter(item => {\n\t\t\t\t\treturn item <= i;\n\t\t\t\t});\n\t\t\t\tcurrentResult = args;\n\t\t\t}\n\t\t\tif (done.length === currentPos) {\n\t\t\t\tcallback.apply(null, currentResult);\n\t\t\t\tcurrentPos = 0;\n\t\t\t}\n\t\t};\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class NextPlugin {\n\tconstructor(source, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"NextPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tresolver.doResolve(target, request, null, resolveContext, callback);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class TryNextPlugin {\n\tconstructor(source, message, target) {\n\t\tthis.source = source;\n\t\tthis.message = message;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"TryNextPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\trequest,\n\t\t\t\t\tthis.message,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class ModuleKindPlugin {\n\tconstructor(source, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ModuleKindPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tif (!request.module) return callback();\n\t\t\t\tconst obj = Object.assign({}, request);\n\t\t\t\tdelete obj.module;\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t\"resolve as module\",\n\t\t\t\t\tresolveContext,\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t// Don't allow other alternatives\n\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class FileKindPlugin {\n\tconstructor(source, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"FileKindPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tif (request.directory) return callback();\n\t\t\t\tconst obj = Object.assign({}, request);\n\t\t\t\tdelete obj.directory;\n\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class JoinRequestPlugin {\n\tconstructor(source, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"JoinRequestPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\tpath: resolver.join(request.path, request.request),\n\t\t\t\t\trelativePath:\n\t\t\t\t\t\trequest.relativePath &&\n\t\t\t\t\t\tresolver.join(request.relativePath, request.request),\n\t\t\t\t\trequest: undefined\n\t\t\t\t});\n\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst forEachBail = require(\"./forEachBail\");\nconst getPaths = require(\"./getPaths\");\n\nmodule.exports = class ModulesInHierachicDirectoriesPlugin {\n\tconstructor(source, directories, target) {\n\t\tthis.source = source;\n\t\tthis.directories = [].concat(directories);\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\n\t\t\t\t\"ModulesInHierachicDirectoriesPlugin\",\n\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\tconst fs = resolver.fileSystem;\n\t\t\t\t\tconst addrs = getPaths(request.path)\n\t\t\t\t\t\t.paths.map(p => {\n\t\t\t\t\t\t\treturn this.directories.map(d => resolver.join(p, d));\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.reduce((array, p) => {\n\t\t\t\t\t\t\tarray.push.apply(array, p);\n\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t}, []);\n\t\t\t\t\tforEachBail(\n\t\t\t\t\t\taddrs,\n\t\t\t\t\t\t(addr, callback) => {\n\t\t\t\t\t\t\tfs.stat(addr, (err, stat) => {\n\t\t\t\t\t\t\t\tif (!err && stat && stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\t\t\t\t\t\tpath: addr,\n\t\t\t\t\t\t\t\t\t\trequest: \"./\" + request.request\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tconst message = \"looking for modules in \" + addr;\n\t\t\t\t\t\t\t\t\treturn resolver.doResolve(\n\t\t\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (resolveContext.log)\n\t\t\t\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\t\t\taddr + \" doesn't exist or is not a directory\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (resolveContext.missing) resolveContext.missing.add(addr);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcallback\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = function getPaths(path) {\n\tconst parts = path.split(/(.*?[\\\\/]+)/);\n\tconst paths = [path];\n\tconst seqments = [parts[parts.length - 1]];\n\tlet part = parts[parts.length - 1];\n\tpath = path.substr(0, path.length - part.length - 1);\n\tfor (let i = parts.length - 2; i > 2; i -= 2) {\n\t\tpaths.push(path);\n\t\tpart = parts[i];\n\t\tpath = path.substr(0, path.length - part.length) || \"/\";\n\t\tseqments.push(part.substr(0, part.length - 1));\n\t}\n\tpart = parts[1];\n\tseqments.push(part);\n\tpaths.push(part);\n\treturn {\n\t\tpaths: paths,\n\t\tseqments: seqments\n\t};\n};\n\nmodule.exports.basename = function basename(path) {\n\tconst i = path.lastIndexOf(\"/\"),\n\t\tj = path.lastIndexOf(\"\\\\\");\n\tconst p = i < 0 ? j : j < 0 ? i : i < j ? j : i;\n\tif (p < 0) return null;\n\tconst s = path.substr(p + 1);\n\treturn s;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class ModulesInRootPlugin {\n\tconstructor(source, path, target) {\n\t\tthis.source = source;\n\t\tthis.path = path;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ModulesInRootPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\tpath: this.path,\n\t\t\t\t\trequest: \"./\" + request.request\n\t\t\t\t});\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t\"looking for modules in \" + this.path,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nfunction startsWith(string, searchString) {\n\tconst stringLength = string.length;\n\tconst searchLength = searchString.length;\n\n\t// early out if the search length is greater than the search string\n\tif (searchLength > stringLength) {\n\t\treturn false;\n\t}\n\tlet index = -1;\n\twhile (++index < searchLength) {\n\t\tif (string.charCodeAt(index) !== searchString.charCodeAt(index)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nmodule.exports = class AliasPlugin {\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = Array.isArray(options) ? options : [options];\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"AliasPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst innerRequest = request.request || request.path;\n\t\t\t\tif (!innerRequest) return callback();\n\t\t\t\tfor (const item of this.options) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinnerRequest === item.name ||\n\t\t\t\t\t\t(!item.onlyModule && startsWith(innerRequest, item.name + \"/\"))\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinnerRequest !== item.alias &&\n\t\t\t\t\t\t\t!startsWith(innerRequest, item.alias + \"/\")\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst newRequestStr =\n\t\t\t\t\t\t\t\titem.alias + innerRequest.substr(item.name.length);\n\t\t\t\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\t\t\t\trequest: newRequestStr\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn resolver.doResolve(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\"aliased with mapping '\" +\n\t\t\t\t\t\t\t\t\titem.name +\n\t\t\t\t\t\t\t\t\t\"': '\" +\n\t\t\t\t\t\t\t\t\titem.alias +\n\t\t\t\t\t\t\t\t\t\"' to '\" +\n\t\t\t\t\t\t\t\t\tnewRequestStr +\n\t\t\t\t\t\t\t\t\t\"'\",\n\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\t// Don't allow other aliasing or raw request\n\t\t\t\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn callback();\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst getInnerRequest = require(\"./getInnerRequest\");\n\nmodule.exports = class AliasFieldPlugin {\n\tconstructor(source, field, target) {\n\t\tthis.source = source;\n\t\tthis.field = field;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"AliasFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tif (!request.descriptionFileData) return callback();\n\t\t\t\tconst innerRequest = getInnerRequest(resolver, request);\n\t\t\t\tif (!innerRequest) return callback();\n\t\t\t\tconst fieldData = DescriptionFileUtils.getField(\n\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\tthis.field\n\t\t\t\t);\n\t\t\t\tif (typeof fieldData !== \"object\") {\n\t\t\t\t\tif (resolveContext.log)\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\"Field '\" +\n\t\t\t\t\t\t\t\tthis.field +\n\t\t\t\t\t\t\t\t\"' doesn't contain a valid alias configuration\"\n\t\t\t\t\t\t);\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t\tconst data1 = fieldData[innerRequest];\n\t\t\t\tconst data2 = fieldData[innerRequest.replace(/^\\.\\//, \"\")];\n\t\t\t\tconst data = typeof data1 !== \"undefined\" ? data1 : data2;\n\t\t\t\tif (data === innerRequest) return callback();\n\t\t\t\tif (data === undefined) return callback();\n\t\t\t\tif (data === false) {\n\t\t\t\t\tconst ignoreObj = Object.assign({}, request, {\n\t\t\t\t\t\tpath: false\n\t\t\t\t\t});\n\t\t\t\t\treturn callback(null, ignoreObj);\n\t\t\t\t}\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\tpath: request.descriptionFileRoot,\n\t\t\t\t\trequest: data\n\t\t\t\t});\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t\"aliased from description file \" +\n\t\t\t\t\t\trequest.descriptionFilePath +\n\t\t\t\t\t\t\" with mapping '\" +\n\t\t\t\t\t\tinnerRequest +\n\t\t\t\t\t\t\"' to '\" +\n\t\t\t\t\t\tdata +\n\t\t\t\t\t\t\"'\",\n\t\t\t\t\tresolveContext,\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t// Don't allow other aliasing or raw request\n\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = function getInnerRequest(resolver, request) {\n\tif (\n\t\ttypeof request.__innerRequest === \"string\" &&\n\t\trequest.__innerRequest_request === request.request &&\n\t\trequest.__innerRequest_relativePath === request.relativePath\n\t)\n\t\treturn request.__innerRequest;\n\tlet innerRequest;\n\tif (request.request) {\n\t\tinnerRequest = request.request;\n\t\tif (/^\\.\\.?\\//.test(innerRequest) && request.relativePath) {\n\t\t\tinnerRequest = resolver.join(request.relativePath, innerRequest);\n\t\t}\n\t} else {\n\t\tinnerRequest = request.relativePath;\n\t}\n\trequest.__innerRequest_request = request.request;\n\trequest.__innerRequest_relativePath = request.relativePath;\n\treturn (request.__innerRequest = innerRequest);\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst concord = require(\"./concord\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\n\nmodule.exports = class ConcordExtensionsPlugin {\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = options;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\n\t\t\t\t\"ConcordExtensionsPlugin\",\n\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\tconst concordField = DescriptionFileUtils.getField(\n\t\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\t\t\"concord\"\n\t\t\t\t\t);\n\t\t\t\t\tif (!concordField) return callback();\n\t\t\t\t\tconst extensions = concord.getExtensions(\n\t\t\t\t\t\trequest.context,\n\t\t\t\t\t\tconcordField\n\t\t\t\t\t);\n\t\t\t\t\tif (!extensions) return callback();\n\t\t\t\t\tforEachBail(\n\t\t\t\t\t\textensions,\n\t\t\t\t\t\t(appending, callback) => {\n\t\t\t\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\t\t\t\tpath: request.path + appending,\n\t\t\t\t\t\t\t\trelativePath:\n\t\t\t\t\t\t\t\t\trequest.relativePath && request.relativePath + appending\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\"concord extension: \" + appending,\n\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t// Don't allow other processing\n\t\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst globToRegExp = require(\"./globToRegExp\").globToRegExp;\n\nfunction parseType(type) {\n\tconst items = type.split(\"+\");\n\tconst t = items.shift();\n\treturn {\n\t\ttype: t === \"*\" ? null : t,\n\t\tfeatures: items\n\t};\n}\n\nfunction isTypeMatched(baseType, testedType) {\n\tif (typeof baseType === \"string\") baseType = parseType(baseType);\n\tif (typeof testedType === \"string\") testedType = parseType(testedType);\n\tif (testedType.type && testedType.type !== baseType.type) return false;\n\treturn testedType.features.every(requiredFeature => {\n\t\treturn baseType.features.indexOf(requiredFeature) >= 0;\n\t});\n}\n\nfunction isResourceTypeMatched(baseType, testedType) {\n\tbaseType = baseType.split(\"/\");\n\ttestedType = testedType.split(\"/\");\n\tif (baseType.length !== testedType.length) return false;\n\tfor (let i = 0; i < baseType.length; i++) {\n\t\tif (!isTypeMatched(baseType[i], testedType[i])) return false;\n\t}\n\treturn true;\n}\n\nfunction isResourceTypeSupported(context, type) {\n\treturn (\n\t\tcontext.supportedResourceTypes &&\n\t\tcontext.supportedResourceTypes.some(supportedType => {\n\t\t\treturn isResourceTypeMatched(supportedType, type);\n\t\t})\n\t);\n}\n\nfunction isEnvironment(context, env) {\n\treturn (\n\t\tcontext.environments &&\n\t\tcontext.environments.every(environment => {\n\t\t\treturn isTypeMatched(environment, env);\n\t\t})\n\t);\n}\n\nconst globCache = {};\n\nfunction getGlobRegExp(glob) {\n\tconst regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));\n\treturn regExp;\n}\n\nfunction matchGlob(glob, relativePath) {\n\tconst regExp = getGlobRegExp(glob);\n\treturn regExp.exec(relativePath);\n}\n\nfunction isGlobMatched(glob, relativePath) {\n\treturn !!matchGlob(glob, relativePath);\n}\n\nfunction isConditionMatched(context, condition) {\n\tconst items = condition.split(\"|\");\n\treturn items.some(function testFn(item) {\n\t\titem = item.trim();\n\t\tconst inverted = /^!/.test(item);\n\t\tif (inverted) return !testFn(item.substr(1));\n\t\tif (/^[a-z]+:/.test(item)) {\n\t\t\t// match named condition\n\t\t\tconst match = /^([a-z]+):\\s*/.exec(item);\n\t\t\tconst value = item.substr(match[0].length);\n\t\t\tconst name = match[1];\n\t\t\tswitch (name) {\n\t\t\t\tcase \"referrer\":\n\t\t\t\t\treturn isGlobMatched(value, context.referrer);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (item.indexOf(\"/\") >= 0) {\n\t\t\t// match supported type\n\t\t\treturn isResourceTypeSupported(context, item);\n\t\t} else {\n\t\t\t// match environment\n\t\t\treturn isEnvironment(context, item);\n\t\t}\n\t});\n}\n\nfunction isKeyMatched(context, key) {\n\tfor (;;) {\n\t\tconst match = /^\\[([^\\]]+)\\]\\s*/.exec(key);\n\t\tif (!match) return key;\n\t\tkey = key.substr(match[0].length);\n\t\tconst condition = match[1];\n\t\tif (!isConditionMatched(context, condition)) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nfunction getField(context, configuration, field) {\n\tlet value;\n\tObject.keys(configuration).forEach(key => {\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tif (pureKey === field) {\n\t\t\tvalue = configuration[key];\n\t\t}\n\t});\n\treturn value;\n}\n\nfunction getMain(context, configuration) {\n\treturn getField(context, configuration, \"main\");\n}\n\nfunction getExtensions(context, configuration) {\n\treturn getField(context, configuration, \"extensions\");\n}\n\nfunction matchModule(context, configuration, request) {\n\tconst modulesField = getField(context, configuration, \"modules\");\n\tif (!modulesField) return request;\n\tlet newRequest = request;\n\tconst keys = Object.keys(modulesField);\n\tlet iteration = 0;\n\tlet match;\n\tlet index;\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tmatch = matchGlob(pureKey, newRequest);\n\t\tif (match) {\n\t\t\tconst value = modulesField[key];\n\t\t\tif (typeof value !== \"string\") {\n\t\t\t\treturn value;\n\t\t\t} else if (/^\\(.+\\)$/.test(pureKey)) {\n\t\t\t\tnewRequest = newRequest.replace(getGlobRegExp(pureKey), value);\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\tnewRequest = value.replace(/(\\/?\\*)?\\*/g, replaceMatcher);\n\t\t\t}\n\t\t\ti = -1;\n\t\t\tif (iteration++ > keys.length) {\n\t\t\t\tthrow new Error(\"Request '\" + request + \"' matches recursively\");\n\t\t\t}\n\t\t}\n\t}\n\treturn newRequest;\n\n\tfunction replaceMatcher(find) {\n\t\tswitch (find) {\n\t\t\tcase \"/**\": {\n\t\t\t\tconst m = match[index++];\n\t\t\t\treturn m ? \"/\" + m : \"\";\n\t\t\t}\n\t\t\tcase \"**\":\n\t\t\tcase \"*\":\n\t\t\t\treturn match[index++];\n\t\t}\n\t}\n}\n\nfunction matchType(context, configuration, relativePath) {\n\tconst typesField = getField(context, configuration, \"types\");\n\tif (!typesField) return undefined;\n\tlet type;\n\tObject.keys(typesField).forEach(key => {\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tif (isGlobMatched(pureKey, relativePath)) {\n\t\t\tconst value = typesField[key];\n\t\t\tif (!type && /\\/\\*$/.test(value))\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"value ('\" +\n\t\t\t\t\t\tvalue +\n\t\t\t\t\t\t\"') of key '\" +\n\t\t\t\t\t\tkey +\n\t\t\t\t\t\t\"' contains '*', but there is no previous value defined\"\n\t\t\t\t);\n\t\t\ttype = value.replace(/\\/\\*$/, \"/\" + type);\n\t\t}\n\t});\n\treturn type;\n}\n\nexports.parseType = parseType;\nexports.isTypeMatched = isTypeMatched;\nexports.isResourceTypeSupported = isResourceTypeSupported;\nexports.isEnvironment = isEnvironment;\nexports.isGlobMatched = isGlobMatched;\nexports.isConditionMatched = isConditionMatched;\nexports.isKeyMatched = isKeyMatched;\nexports.getField = getField;\nexports.getMain = getMain;\nexports.getExtensions = getExtensions;\nexports.matchModule = matchModule;\nexports.matchType = matchType;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nfunction globToRegExp(glob) {\n\t// * [^\\\\\\/]*\n\t// /**/ /.+/\n\t// ^* \\./.+ (concord special)\n\t// ? [^\\\\\\/]\n\t// [!...] [^...]\n\t// [^...] [^...]\n\t// / [\\\\\\/]\n\t// {...,...} (...|...)\n\t// ?(...|...) (...|...)?\n\t// +(...|...) (...|...)+\n\t// *(...|...) (...|...)*\n\t// @(...|...) (...|...)\n\tif (/^\\(.+\\)$/.test(glob)) {\n\t\t// allow to pass an RegExp in brackets\n\t\treturn new RegExp(glob.substr(1, glob.length - 2));\n\t}\n\tconst tokens = tokenize(glob);\n\tconst process = createRoot();\n\tconst regExpStr = tokens.map(process).join(\"\");\n\treturn new RegExp(\"^\" + regExpStr + \"$\");\n}\n\nconst SIMPLE_TOKENS = {\n\t\"@(\": \"one\",\n\t\"?(\": \"zero-one\",\n\t\"+(\": \"one-many\",\n\t\"*(\": \"zero-many\",\n\t\"|\": \"segment-sep\",\n\t\"/**/\": \"any-path-segments\",\n\t\"**\": \"any-path\",\n\t\"*\": \"any-path-segment\",\n\t\"?\": \"any-char\",\n\t\"{\": \"or\",\n\t\"/\": \"path-sep\",\n\t\",\": \"comma\",\n\t\")\": \"closing-segment\",\n\t\"}\": \"closing-or\"\n};\n\nfunction tokenize(glob) {\n\treturn glob\n\t\t.split(\n\t\t\t/([@?+*]\\(|\\/\\*\\*\\/|\\*\\*|[?*]|\\[[!^]?(?:[^\\]\\\\]|\\\\.)+\\]|\\{|,|\\/|[|)}])/g\n\t\t)\n\t\t.map(item => {\n\t\t\tif (!item) return null;\n\t\t\tconst t = SIMPLE_TOKENS[item];\n\t\t\tif (t) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: t\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (item[0] === \"[\") {\n\t\t\t\tif (item[1] === \"^\" || item[1] === \"!\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"inverted-char-set\",\n\t\t\t\t\t\tvalue: item.substr(2, item.length - 3)\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"char-set\",\n\t\t\t\t\t\tvalue: item.substr(1, item.length - 2)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: \"string\",\n\t\t\t\tvalue: item\n\t\t\t};\n\t\t})\n\t\t.filter(Boolean)\n\t\t.concat({\n\t\t\ttype: \"end\"\n\t\t});\n}\n\nfunction createRoot() {\n\tconst inOr = [];\n\tconst process = createSeqment();\n\tlet initial = true;\n\treturn function(token) {\n\t\tswitch (token.type) {\n\t\t\tcase \"or\":\n\t\t\t\tinOr.push(initial);\n\t\t\t\treturn \"(\";\n\t\t\tcase \"comma\":\n\t\t\t\tif (inOr.length) {\n\t\t\t\t\tinitial = inOr[inOr.length - 1];\n\t\t\t\t\treturn \"|\";\n\t\t\t\t} else {\n\t\t\t\t\treturn process(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tvalue: \",\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinitial\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\tcase \"closing-or\":\n\t\t\t\tif (inOr.length === 0) throw new Error(\"Unmatched '}'\");\n\t\t\t\tinOr.pop();\n\t\t\t\treturn \")\";\n\t\t\tcase \"end\":\n\t\t\t\tif (inOr.length) throw new Error(\"Unmatched '{'\");\n\t\t\t\treturn process(token, initial);\n\t\t\tdefault: {\n\t\t\t\tconst result = process(token, initial);\n\t\t\t\tinitial = false;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction createSeqment() {\n\tconst inSeqment = [];\n\tconst process = createSimple();\n\treturn function(token, initial) {\n\t\tswitch (token.type) {\n\t\t\tcase \"one\":\n\t\t\tcase \"one-many\":\n\t\t\tcase \"zero-many\":\n\t\t\tcase \"zero-one\":\n\t\t\t\tinSeqment.push(token.type);\n\t\t\t\treturn \"(\";\n\t\t\tcase \"segment-sep\":\n\t\t\t\tif (inSeqment.length) {\n\t\t\t\t\treturn \"|\";\n\t\t\t\t} else {\n\t\t\t\t\treturn process(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tvalue: \"|\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinitial\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\tcase \"closing-segment\": {\n\t\t\t\tconst segment = inSeqment.pop();\n\t\t\t\tswitch (segment) {\n\t\t\t\t\tcase \"one\":\n\t\t\t\t\t\treturn \")\";\n\t\t\t\t\tcase \"one-many\":\n\t\t\t\t\t\treturn \")+\";\n\t\t\t\t\tcase \"zero-many\":\n\t\t\t\t\t\treturn \")*\";\n\t\t\t\t\tcase \"zero-one\":\n\t\t\t\t\t\treturn \")?\";\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Unexcepted segment \" + segment);\n\t\t\t}\n\t\t\tcase \"end\":\n\t\t\t\tif (inSeqment.length > 0) {\n\t\t\t\t\tthrow new Error(\"Unmatched segment, missing ')'\");\n\t\t\t\t}\n\t\t\t\treturn process(token, initial);\n\t\t\tdefault:\n\t\t\t\treturn process(token, initial);\n\t\t}\n\t};\n}\n\nfunction createSimple() {\n\treturn function(token, initial) {\n\t\tswitch (token.type) {\n\t\t\tcase \"path-sep\":\n\t\t\t\treturn \"[\\\\\\\\/]+\";\n\t\t\tcase \"any-path-segments\":\n\t\t\t\treturn \"[\\\\\\\\/]+(?:(.+)[\\\\\\\\/]+)?\";\n\t\t\tcase \"any-path\":\n\t\t\t\treturn \"(.*)\";\n\t\t\tcase \"any-path-segment\":\n\t\t\t\tif (initial) {\n\t\t\t\t\treturn \"\\\\.[\\\\\\\\/]+(?:.*[\\\\\\\\/]+)?([^\\\\\\\\/]+)\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"([^\\\\\\\\/]*)\";\n\t\t\t\t}\n\t\t\tcase \"any-char\":\n\t\t\t\treturn \"[^\\\\\\\\/]\";\n\t\t\tcase \"inverted-char-set\":\n\t\t\t\treturn \"[^\" + token.value + \"]\";\n\t\t\tcase \"char-set\":\n\t\t\t\treturn \"[\" + token.value + \"]\";\n\t\t\tcase \"string\":\n\t\t\t\treturn token.value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n\t\t\tcase \"end\":\n\t\t\t\treturn \"\";\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported token '\" + token.type + \"'\");\n\t\t}\n\t};\n}\n\nexports.globToRegExp = globToRegExp;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst path = require(\"path\");\nconst concord = require(\"./concord\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\n\nmodule.exports = class ConcordMainPlugin {\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = options;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ConcordMainPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tif (request.path !== request.descriptionFileRoot) return callback();\n\t\t\t\tconst concordField = DescriptionFileUtils.getField(\n\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\t\"concord\"\n\t\t\t\t);\n\t\t\t\tif (!concordField) return callback();\n\t\t\t\tconst mainModule = concord.getMain(request.context, concordField);\n\t\t\t\tif (!mainModule) return callback();\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\trequest: mainModule\n\t\t\t\t});\n\t\t\t\tconst filename = path.basename(request.descriptionFilePath);\n\t\t\t\treturn resolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t\"use \" + mainModule + \" from \" + filename,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst concord = require(\"./concord\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst getInnerRequest = require(\"./getInnerRequest\");\n\nmodule.exports = class ConcordModulesPlugin {\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = options;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ConcordModulesPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst innerRequest = getInnerRequest(resolver, request);\n\t\t\t\tif (!innerRequest) return callback();\n\t\t\t\tconst concordField = DescriptionFileUtils.getField(\n\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\t\"concord\"\n\t\t\t\t);\n\t\t\t\tif (!concordField) return callback();\n\t\t\t\tconst data = concord.matchModule(\n\t\t\t\t\trequest.context,\n\t\t\t\t\tconcordField,\n\t\t\t\t\tinnerRequest\n\t\t\t\t);\n\t\t\t\tif (data === innerRequest) return callback();\n\t\t\t\tif (data === undefined) return callback();\n\t\t\t\tif (data === false) {\n\t\t\t\t\tconst ignoreObj = Object.assign({}, request, {\n\t\t\t\t\t\tpath: false\n\t\t\t\t\t});\n\t\t\t\t\treturn callback(null, ignoreObj);\n\t\t\t\t}\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\tpath: request.descriptionFileRoot,\n\t\t\t\t\trequest: data\n\t\t\t\t});\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t\"aliased from description file \" +\n\t\t\t\t\t\trequest.descriptionFilePath +\n\t\t\t\t\t\t\" with mapping '\" +\n\t\t\t\t\t\tinnerRequest +\n\t\t\t\t\t\t\"' to '\" +\n\t\t\t\t\t\tdata +\n\t\t\t\t\t\t\"'\",\n\t\t\t\t\tresolveContext,\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t// Don't allow other aliasing or raw request\n\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class DirectoryExistsPlugin {\n\tconstructor(source, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\n\t\t\t\t\"DirectoryExistsPlugin\",\n\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\tconst fs = resolver.fileSystem;\n\t\t\t\t\tconst directory = request.path;\n\t\t\t\t\tfs.stat(directory, (err, stat) => {\n\t\t\t\t\t\tif (err || !stat) {\n\t\t\t\t\t\t\tif (resolveContext.missing) resolveContext.missing.add(directory);\n\t\t\t\t\t\t\tif (resolveContext.log)\n\t\t\t\t\t\t\t\tresolveContext.log(directory + \" doesn't exist\");\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!stat.isDirectory()) {\n\t\t\t\t\t\t\tif (resolveContext.missing) resolveContext.missing.add(directory);\n\t\t\t\t\t\t\tif (resolveContext.log)\n\t\t\t\t\t\t\t\tresolveContext.log(directory + \" is not a directory\");\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\"existing directory\",\n\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class FileExistsPlugin {\n\tconstructor(source, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tconst fs = resolver.fileSystem;\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"FileExistsPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst file = request.path;\n\t\t\t\tfs.stat(file, (err, stat) => {\n\t\t\t\t\tif (err || !stat) {\n\t\t\t\t\t\tif (resolveContext.missing) resolveContext.missing.add(file);\n\t\t\t\t\t\tif (resolveContext.log) resolveContext.log(file + \" doesn't exist\");\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tif (!stat.isFile()) {\n\t\t\t\t\t\tif (resolveContext.missing) resolveContext.missing.add(file);\n\t\t\t\t\t\tif (resolveContext.log) resolveContext.log(file + \" is not a file\");\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\"existing file: \" + file,\n\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\tcallback\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst getPaths = require(\"./getPaths\");\nconst forEachBail = require(\"./forEachBail\");\n\nmodule.exports = class SymlinkPlugin {\n\tconstructor(source, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tconst fs = resolver.fileSystem;\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"SymlinkPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst pathsResult = getPaths(request.path);\n\t\t\t\tconst pathSeqments = pathsResult.seqments;\n\t\t\t\tconst paths = pathsResult.paths;\n\n\t\t\t\tlet containsSymlink = false;\n\t\t\t\tforEachBail.withIndex(\n\t\t\t\t\tpaths,\n\t\t\t\t\t(path, idx, callback) => {\n\t\t\t\t\t\tfs.readlink(path, (err, result) => {\n\t\t\t\t\t\t\tif (!err && result) {\n\t\t\t\t\t\t\t\tpathSeqments[idx] = result;\n\t\t\t\t\t\t\t\tcontainsSymlink = true;\n\t\t\t\t\t\t\t\t// Shortcut when absolute symlink found\n\t\t\t\t\t\t\t\tif (/^(\\/|[a-zA-Z]:($|\\\\))/.test(result))\n\t\t\t\t\t\t\t\t\treturn callback(null, idx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\t(err, idx) => {\n\t\t\t\t\t\tif (!containsSymlink) return callback();\n\t\t\t\t\t\tconst resultSeqments =\n\t\t\t\t\t\t\ttypeof idx === \"number\"\n\t\t\t\t\t\t\t\t? pathSeqments.slice(0, idx + 1)\n\t\t\t\t\t\t\t\t: pathSeqments.slice();\n\t\t\t\t\t\tconst result = resultSeqments.reverse().reduce((a, b) => {\n\t\t\t\t\t\t\treturn resolver.join(a, b);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\t\t\tpath: result\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\"resolved symlink to \" + result,\n\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst path = require(\"path\");\n\nmodule.exports = class MainFieldPlugin {\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = options;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"MainFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tif (request.path !== request.descriptionFileRoot) return callback();\n\t\t\t\tif (request.alreadyTriedMainField === request.descriptionFilePath)\n\t\t\t\t\treturn callback();\n\t\t\t\tconst content = request.descriptionFileData;\n\t\t\t\tconst filename = path.basename(request.descriptionFilePath);\n\t\t\t\tlet mainModule;\n\t\t\t\tconst field = this.options.name;\n\t\t\t\tif (Array.isArray(field)) {\n\t\t\t\t\tlet current = content;\n\t\t\t\t\tfor (let j = 0; j < field.length; j++) {\n\t\t\t\t\t\tif (current === null || typeof current !== \"object\") {\n\t\t\t\t\t\t\tcurrent = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrent = current[field[j]];\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof current === \"string\") {\n\t\t\t\t\t\tmainModule = current;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof content[field] === \"string\") {\n\t\t\t\t\t\tmainModule = content[field];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!mainModule) return callback();\n\t\t\t\tif (this.options.forceRelative && !/^\\.\\.?\\//.test(mainModule))\n\t\t\t\t\tmainModule = \"./\" + mainModule;\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\trequest: mainModule,\n\t\t\t\t\talreadyTriedMainField: request.descriptionFilePath\n\t\t\t\t});\n\t\t\t\treturn resolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t\"use \" +\n\t\t\t\t\t\tmainModule +\n\t\t\t\t\t\t\" from \" +\n\t\t\t\t\t\tthis.options.name +\n\t\t\t\t\t\t\" in \" +\n\t\t\t\t\t\tfilename,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class UseFilePlugin {\n\tconstructor(source, filename, target) {\n\t\tthis.source = source;\n\t\tthis.filename = filename;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"UseFilePlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst filePath = resolver.join(request.path, this.filename);\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\tpath: filePath,\n\t\t\t\t\trelativePath:\n\t\t\t\t\t\trequest.relativePath &&\n\t\t\t\t\t\tresolver.join(request.relativePath, this.filename)\n\t\t\t\t});\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t\"using path: \" + filePath,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class AppendPlugin {\n\tconstructor(source, appending, target) {\n\t\tthis.source = source;\n\t\tthis.appending = appending;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"AppendPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\tpath: request.path + this.appending,\n\t\t\t\t\trelativePath:\n\t\t\t\t\t\trequest.relativePath && request.relativePath + this.appending\n\t\t\t\t});\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\tthis.appending,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\nclass RootPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source hook\n\t * @param {Array<string>} root roots\n\t * @param {string | ResolveStepHook} target target hook\n\t * @param {boolean=} ignoreErrors ignore error during resolving of root paths\n\t */\n\tconstructor(source, root, target, ignoreErrors) {\n\t\tthis.root = root;\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t\tthis._ignoreErrors = ignoreErrors;\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"RootPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst req = request.request;\n\t\t\t\tif (!req) return callback();\n\t\t\t\tif (!req.startsWith(\"/\")) return callback();\n\n\t\t\t\tconst path = resolver.join(this.root, req.slice(1));\n\t\t\t\tconst obj = Object.assign(request, {\n\t\t\t\t\tpath,\n\t\t\t\t\trelativePath: request.relativePath && path\n\t\t\t\t});\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t`root path ${this.root}`,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\tthis._ignoreErrors\n\t\t\t\t\t\t? (err, result) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\t\t\t\t`Ignored fatal error while resolving root path:\\n${err}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: callback\n\t\t\t\t);\n\t\t\t});\n\t}\n}\n\nmodule.exports = RootPlugin;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\n\nconst slashCode = \"/\".charCodeAt(0);\nconst backslashCode = \"\\\\\".charCodeAt(0);\n\nconst isInside = (path, parent) => {\n\tif (!path.startsWith(parent)) return false;\n\tif (path.length === parent.length) return true;\n\tconst charCode = path.charCodeAt(parent.length);\n\treturn charCode === slashCode || charCode === backslashCode;\n};\n\nmodule.exports = class RestrictionsPlugin {\n\tconstructor(source, restrictions) {\n\t\tthis.source = source;\n\t\tthis.restrictions = restrictions;\n\t}\n\n\tapply(resolver) {\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"RestrictionsPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tif (typeof request.path === \"string\") {\n\t\t\t\t\tconst path = request.path;\n\n\t\t\t\t\tfor (let i = 0; i < this.restrictions.length; i++) {\n\t\t\t\t\t\tconst rule = this.restrictions[i];\n\t\t\t\t\t\tif (typeof rule === \"string\") {\n\t\t\t\t\t\t\tif (!isInside(path, rule)) {\n\t\t\t\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\t\t\t`${path} is not inside of the restriction ${rule}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(null, null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!rule.test(path)) {\n\t\t\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\t\t`${path} doesn't match the restriction ${rule}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn callback(null, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback();\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class ResultPlugin {\n\tconstructor(source) {\n\t\tthis.source = source;\n\t}\n\n\tapply(resolver) {\n\t\tthis.source.tapAsync(\n\t\t\t\"ResultPlugin\",\n\t\t\t(request, resolverContext, callback) => {\n\t\t\t\tconst obj = Object.assign({}, request);\n\t\t\t\tif (resolverContext.log)\n\t\t\t\t\tresolverContext.log(\"reporting result \" + obj.path);\n\t\t\t\tresolver.hooks.result.callAsync(obj, resolverContext, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, obj);\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nmodule.exports = class ModuleAppendPlugin {\n\tconstructor(source, appending, target) {\n\t\tthis.source = source;\n\t\tthis.appending = appending;\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ModuleAppendPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst i = request.request.indexOf(\"/\"),\n\t\t\t\t\tj = request.request.indexOf(\"\\\\\");\n\t\t\t\tconst p = i < 0 ? j : j < 0 ? i : i < j ? i : j;\n\t\t\t\tlet moduleName, remainingRequest;\n\t\t\t\tif (p < 0) {\n\t\t\t\t\tmoduleName = request.request;\n\t\t\t\t\tremainingRequest = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tmoduleName = request.request.substr(0, p);\n\t\t\t\t\tremainingRequest = request.request.substr(p);\n\t\t\t\t}\n\t\t\t\tif (moduleName === \".\" || moduleName === \"..\") return callback();\n\t\t\t\tconst moduleFinalName = moduleName + this.appending;\n\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\trequest: moduleFinalName + remainingRequest\n\t\t\t\t});\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\tobj,\n\t\t\t\t\t\"module variation \" + moduleFinalName,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nfunction getCacheId(request, withContext) {\n\treturn JSON.stringify({\n\t\tcontext: withContext ? request.context : \"\",\n\t\tpath: request.path,\n\t\tquery: request.query,\n\t\trequest: request.request\n\t});\n}\n\nmodule.exports = class UnsafeCachePlugin {\n\tconstructor(source, filterPredicate, cache, withContext, target) {\n\t\tthis.source = source;\n\t\tthis.filterPredicate = filterPredicate;\n\t\tthis.withContext = withContext;\n\t\tthis.cache = cache || {};\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"UnsafeCachePlugin\", (request, resolveContext, callback) => {\n\t\t\t\tif (!this.filterPredicate(request)) return callback();\n\t\t\t\tconst cacheId = getCacheId(request, this.withContext);\n\t\t\t\tconst cacheEntry = this.cache[cacheId];\n\t\t\t\tif (cacheEntry) {\n\t\t\t\t\treturn callback(null, cacheEntry);\n\t\t\t\t}\n\t\t\t\tresolver.doResolve(\n\t\t\t\t\ttarget,\n\t\t\t\t\trequest,\n\t\t\t\t\tnull,\n\t\t\t\t\tresolveContext,\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tif (result) return callback(null, (this.cache[cacheId] = result));\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst fs = require(\"graceful-fs\");\n\nclass NodeJsInputFileSystem {\n\treaddir(path, callback) {\n\t\tfs.readdir(path, (err, files) => {\n\t\t\tcallback(\n\t\t\t\terr,\n\t\t\t\tfiles &&\n\t\t\t\t\tfiles.map(file => {\n\t\t\t\t\t\treturn file.normalize ? file.normalize(\"NFC\") : file;\n\t\t\t\t\t})\n\t\t\t);\n\t\t});\n\t}\n\n\treaddirSync(path) {\n\t\tconst files = fs.readdirSync(path);\n\t\treturn (\n\t\t\tfiles &&\n\t\t\tfiles.map(file => {\n\t\t\t\treturn file.normalize ? file.normalize(\"NFC\") : file;\n\t\t\t})\n\t\t);\n\t}\n}\n\nconst fsMethods = [\n\t\"stat\",\n\t\"statSync\",\n\t\"readFile\",\n\t\"readFileSync\",\n\t\"readlink\",\n\t\"readlinkSync\"\n];\n\nfor (const key of fsMethods) {\n\tObject.defineProperty(NodeJsInputFileSystem.prototype, key, {\n\t\tconfigurable: true,\n\t\twritable: true,\n\t\tvalue: fs[key].bind(fs)\n\t});\n}\n\nmodule.exports = NodeJsInputFileSystem;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nclass Storage {\n\tconstructor(duration) {\n\t\tthis.duration = duration;\n\t\tthis.running = new Map();\n\t\tthis.data = new Map();\n\t\tthis.levels = [];\n\t\tif (duration > 0) {\n\t\t\tthis.levels.push(\n\t\t\t\tnew Set(),\n\t\t\t\tnew Set(),\n\t\t\t\tnew Set(),\n\t\t\t\tnew Set(),\n\t\t\t\tnew Set(),\n\t\t\t\tnew Set(),\n\t\t\t\tnew Set(),\n\t\t\t\tnew Set(),\n\t\t\t\tnew Set()\n\t\t\t);\n\t\t\tfor (let i = 8000; i < duration; i += 500) this.levels.push(new Set());\n\t\t}\n\t\tthis.count = 0;\n\t\tthis.interval = null;\n\t\tthis.needTickCheck = false;\n\t\tthis.nextTick = null;\n\t\tthis.passive = true;\n\t\tthis.tick = this.tick.bind(this);\n\t}\n\n\tensureTick() {\n\t\tif (!this.interval && this.duration > 0 && !this.nextTick)\n\t\t\tthis.interval = setInterval(\n\t\t\t\tthis.tick,\n\t\t\t\tMath.floor(this.duration / this.levels.length)\n\t\t\t);\n\t}\n\n\tfinished(name, err, result) {\n\t\tconst callbacks = this.running.get(name);\n\t\tthis.running.delete(name);\n\t\tif (this.duration > 0) {\n\t\t\tthis.data.set(name, [err, result]);\n\t\t\tconst levelData = this.levels[0];\n\t\t\tthis.count -= levelData.size;\n\t\t\tlevelData.add(name);\n\t\t\tthis.count += levelData.size;\n\t\t\tthis.ensureTick();\n\t\t}\n\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\tcallbacks[i](err, result);\n\t\t}\n\t}\n\n\tfinishedSync(name, err, result) {\n\t\tif (this.duration > 0) {\n\t\t\tthis.data.set(name, [err, result]);\n\t\t\tconst levelData = this.levels[0];\n\t\t\tthis.count -= levelData.size;\n\t\t\tlevelData.add(name);\n\t\t\tthis.count += levelData.size;\n\t\t\tthis.ensureTick();\n\t\t}\n\t}\n\n\tprovide(name, provider, callback) {\n\t\tif (typeof name !== \"string\") {\n\t\t\tcallback(new TypeError(\"path must be a string\"));\n\t\t\treturn;\n\t\t}\n\t\tlet running = this.running.get(name);\n\t\tif (running) {\n\t\t\trunning.push(callback);\n\t\t\treturn;\n\t\t}\n\t\tif (this.duration > 0) {\n\t\t\tthis.checkTicks();\n\t\t\tconst data = this.data.get(name);\n\t\t\tif (data) {\n\t\t\t\treturn process.nextTick(() => {\n\t\t\t\t\tcallback.apply(null, data);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tthis.running.set(name, (running = [callback]));\n\t\tprovider(name, (err, result) => {\n\t\t\tthis.finished(name, err, result);\n\t\t});\n\t}\n\n\tprovideSync(name, provider) {\n\t\tif (typeof name !== \"string\") {\n\t\t\tthrow new TypeError(\"path must be a string\");\n\t\t}\n\t\tif (this.duration > 0) {\n\t\t\tthis.checkTicks();\n\t\t\tconst data = this.data.get(name);\n\t\t\tif (data) {\n\t\t\t\tif (data[0]) throw data[0];\n\t\t\t\treturn data[1];\n\t\t\t}\n\t\t}\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = provider(name);\n\t\t} catch (e) {\n\t\t\tthis.finishedSync(name, e);\n\t\t\tthrow e;\n\t\t}\n\t\tthis.finishedSync(name, null, result);\n\t\treturn result;\n\t}\n\n\ttick() {\n\t\tconst decay = this.levels.pop();\n\t\tfor (let item of decay) {\n\t\t\tthis.data.delete(item);\n\t\t}\n\t\tthis.count -= decay.size;\n\t\tdecay.clear();\n\t\tthis.levels.unshift(decay);\n\t\tif (this.count === 0) {\n\t\t\tclearInterval(this.interval);\n\t\t\tthis.interval = null;\n\t\t\tthis.nextTick = null;\n\t\t\treturn true;\n\t\t} else if (this.nextTick) {\n\t\t\tthis.nextTick += Math.floor(this.duration / this.levels.length);\n\t\t\tconst time = new Date().getTime();\n\t\t\tif (this.nextTick > time) {\n\t\t\t\tthis.nextTick = null;\n\t\t\t\tthis.interval = setInterval(\n\t\t\t\t\tthis.tick,\n\t\t\t\t\tMath.floor(this.duration / this.levels.length)\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (this.passive) {\n\t\t\tclearInterval(this.interval);\n\t\t\tthis.interval = null;\n\t\t\tthis.nextTick =\n\t\t\t\tnew Date().getTime() + Math.floor(this.duration / this.levels.length);\n\t\t} else {\n\t\t\tthis.passive = true;\n\t\t}\n\t}\n\n\tcheckTicks() {\n\t\tthis.passive = false;\n\t\tif (this.nextTick) {\n\t\t\twhile (!this.tick());\n\t\t}\n\t}\n\n\tpurge(what) {\n\t\tif (!what) {\n\t\t\tthis.count = 0;\n\t\t\tclearInterval(this.interval);\n\t\t\tthis.nextTick = null;\n\t\t\tthis.data.clear();\n\t\t\tthis.levels.forEach(level => {\n\t\t\t\tlevel.clear();\n\t\t\t});\n\t\t} else if (typeof what === \"string\") {\n\t\t\tfor (let key of this.data.keys()) {\n\t\t\t\tif (key.startsWith(what)) this.data.delete(key);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = what.length - 1; i >= 0; i--) {\n\t\t\t\tthis.purge(what[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = class CachedInputFileSystem {\n\tconstructor(fileSystem, duration) {\n\t\tthis.fileSystem = fileSystem;\n\t\tthis._statStorage = new Storage(duration);\n\t\tthis._readdirStorage = new Storage(duration);\n\t\tthis._readFileStorage = new Storage(duration);\n\t\tthis._readJsonStorage = new Storage(duration);\n\t\tthis._readlinkStorage = new Storage(duration);\n\n\t\tthis._stat = this.fileSystem.stat\n\t\t\t? this.fileSystem.stat.bind(this.fileSystem)\n\t\t\t: null;\n\t\tif (!this._stat) this.stat = null;\n\n\t\tthis._statSync = this.fileSystem.statSync\n\t\t\t? this.fileSystem.statSync.bind(this.fileSystem)\n\t\t\t: null;\n\t\tif (!this._statSync) this.statSync = null;\n\n\t\tthis._readdir = this.fileSystem.readdir\n\t\t\t? this.fileSystem.readdir.bind(this.fileSystem)\n\t\t\t: null;\n\t\tif (!this._readdir) this.readdir = null;\n\n\t\tthis._readdirSync = this.fileSystem.readdirSync\n\t\t\t? this.fileSystem.readdirSync.bind(this.fileSystem)\n\t\t\t: null;\n\t\tif (!this._readdirSync) this.readdirSync = null;\n\n\t\tthis._readFile = this.fileSystem.readFile\n\t\t\t? this.fileSystem.readFile.bind(this.fileSystem)\n\t\t\t: null;\n\t\tif (!this._readFile) this.readFile = null;\n\n\t\tthis._readFileSync = this.fileSystem.readFileSync\n\t\t\t? this.fileSystem.readFileSync.bind(this.fileSystem)\n\t\t\t: null;\n\t\tif (!this._readFileSync) this.readFileSync = null;\n\n\t\tif (this.fileSystem.readJson) {\n\t\t\tthis._readJson = this.fileSystem.readJson.bind(this.fileSystem);\n\t\t} else if (this.readFile) {\n\t\t\tthis._readJson = (path, callback) => {\n\t\t\t\tthis.readFile(path, (err, buffer) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tlet data;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdata = JSON.parse(buffer.toString(\"utf-8\"));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn callback(e);\n\t\t\t\t\t}\n\t\t\t\t\tcallback(null, data);\n\t\t\t\t});\n\t\t\t};\n\t\t} else {\n\t\t\tthis.readJson = null;\n\t\t}\n\t\tif (this.fileSystem.readJsonSync) {\n\t\t\tthis._readJsonSync = this.fileSystem.readJsonSync.bind(this.fileSystem);\n\t\t} else if (this.readFileSync) {\n\t\t\tthis._readJsonSync = path => {\n\t\t\t\tconst buffer = this.readFileSync(path);\n\t\t\t\tconst data = JSON.parse(buffer.toString(\"utf-8\"));\n\t\t\t\treturn data;\n\t\t\t};\n\t\t} else {\n\t\t\tthis.readJsonSync = null;\n\t\t}\n\n\t\tthis._readlink = this.fileSystem.readlink\n\t\t\t? this.fileSystem.readlink.bind(this.fileSystem)\n\t\t\t: null;\n\t\tif (!this._readlink) this.readlink = null;\n\n\t\tthis._readlinkSync = this.fileSystem.readlinkSync\n\t\t\t? this.fileSystem.readlinkSync.bind(this.fileSystem)\n\t\t\t: null;\n\t\tif (!this._readlinkSync) this.readlinkSync = null;\n\t}\n\n\tstat(path, callback) {\n\t\tthis._statStorage.provide(path, this._stat, callback);\n\t}\n\n\treaddir(path, callback) {\n\t\tthis._readdirStorage.provide(path, this._readdir, callback);\n\t}\n\n\treadFile(path, callback) {\n\t\tthis._readFileStorage.provide(path, this._readFile, callback);\n\t}\n\n\treadJson(path, callback) {\n\t\tthis._readJsonStorage.provide(path, this._readJson, callback);\n\t}\n\n\treadlink(path, callback) {\n\t\tthis._readlinkStorage.provide(path, this._readlink, callback);\n\t}\n\n\tstatSync(path) {\n\t\treturn this._statStorage.provideSync(path, this._statSync);\n\t}\n\n\treaddirSync(path) {\n\t\treturn this._readdirStorage.provideSync(path, this._readdirSync);\n\t}\n\n\treadFileSync(path) {\n\t\treturn this._readFileStorage.provideSync(path, this._readFileSync);\n\t}\n\n\treadJsonSync(path) {\n\t\treturn this._readJsonStorage.provideSync(path, this._readJsonSync);\n\t}\n\n\treadlinkSync(path) {\n\t\treturn this._readlinkStorage.provideSync(path, this._readlinkSync);\n\t}\n\n\tpurge(what) {\n\t\tthis._statStorage.purge(what);\n\t\tthis._readdirStorage.purge(what);\n\t\tthis._readFileStorage.purge(what);\n\t\tthis._readlinkStorage.purge(what);\n\t\tthis._readJsonStorage.purge(what);\n\t}\n};\n"]}